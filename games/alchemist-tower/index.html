<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Alchemist's Tower - ì—°ê¸ˆìˆ ì‚¬ì˜ íƒ‘</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #0f0f1e 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            touch-action: none;
        }

        #gameCanvas {
            display: block;
            margin: 0 auto;
            background: #16213e;
            cursor: crosshair;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
        }

        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            background: rgba(0, 0, 0, 0.95);
            z-index: 1000;
        }

        .screen.active {
            display: flex;
        }

        .title {
            font-size: 3em;
            color: #ffd700;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
            margin-bottom: 20px;
            animation: glow 2s ease-in-out infinite;
        }

        @keyframes glow {
            0%, 100% { text-shadow: 0 0 20px rgba(255, 215, 0, 0.5); }
            50% { text-shadow: 0 0 40px rgba(255, 215, 0, 0.8); }
        }

        .btn {
            padding: 15px 40px;
            margin: 10px;
            font-size: 1.2em;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        .btn:active {
            transform: translateY(0);
        }

        .stats {
            color: #fff;
            font-size: 1.1em;
            margin: 20px 0;
            text-align: center;
        }

        .recipe-list {
            max-height: 400px;
            overflow-y: auto;
            margin: 20px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }

        .recipe-item {
            padding: 10px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 5px;
            color: #fff;
        }

        @media (max-width: 768px) {
            .title { font-size: 2em; }
            .btn { font-size: 1em; padding: 12px 30px; }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="menuScreen" class="screen active">
        <h1 class="title">ğŸ§ª Alchemist's Tower</h1>
        <div class="stats">
            <p>ìµœê³  ì¸µìˆ˜: <span id="highFloor">0</span></p>
            <p>ê³¨ë“œ: <span id="totalGold">0</span></p>
        </div>
        <button class="btn" onclick="game.startGame()">ğŸ® ê²Œì„ ì‹œì‘</button>
        <button class="btn" onclick="game.showUpgrades()">âš¡ ì˜êµ¬ ê°•í™”</button>
        <button class="btn" onclick="game.showRecipes()">ğŸ“– ë ˆì‹œí”¼ë¶</button>
        <button class="btn" onclick="game.showHelp()">â“ ë„ì›€ë§</button>
    </div>

    <div id="upgradeScreen" class="screen">
        <h2 class="title">âš¡ ì˜êµ¬ ê°•í™”</h2>
        <div class="stats">ê³¨ë“œ: <span id="upgradeGold">0</span></div>
        <div id="upgradeList" class="recipe-list"></div>
        <button class="btn" onclick="game.showMenu()">â† ëŒì•„ê°€ê¸°</button>
    </div>

    <div id="recipeScreen" class="screen">
        <h2 class="title">ğŸ“– ë ˆì‹œí”¼ë¶</h2>
        <div id="recipeList" class="recipe-list"></div>
        <button class="btn" onclick="game.showMenu()">â† ëŒì•„ê°€ê¸°</button>
    </div>

    <div id="helpScreen" class="screen">
        <h2 class="title">â“ ë„ì›€ë§</h2>
        <div class="stats" style="max-width: 600px; text-align: left; line-height: 1.6;">
            <p>ğŸ¯ <strong>ëª©í‘œ:</strong> ì—°ê¸ˆìˆ  í¬ì…˜ìœ¼ë¡œ ëª¬ìŠ¤í„°ë¥¼ ë§‰ê³  íƒ‘ì„ ì˜¬ë¼ê°€ì„¸ìš”!</p><br>
            <p>ğŸ§ª <strong>í•©ì„±:</strong> 3x3 ê·¸ë¦¬ë“œì— ì¬ë£Œë¥¼ ë“œë˜ê·¸í•˜ì—¬ í¬ì…˜ì„ ë§Œë“œì„¸ìš”.</p>
            <p>â€¢ ê°™ì€ ì¬ë£Œ 3ê°œ = ê¸°ë³¸ í¬ì…˜</p>
            <p>â€¢ ë‹¤ë¥¸ ì¡°í•© = íŠ¹ìˆ˜ í¬ì…˜ (ì‹¤í—˜í•´ë³´ì„¸ìš”!)</p><br>
            <p>âš”ï¸ <strong>ì „íˆ¬:</strong> í¬ì…˜ì€ ìë™ìœ¼ë¡œ ëª¬ìŠ¤í„°ì—ê²Œ íˆ¬ì²™ë©ë‹ˆë‹¤.</p>
            <p>ğŸ’° <strong>ê³¨ë“œ:</strong> ëª¬ìŠ¤í„° ì²˜ì¹˜ ì‹œ íšë“, ì˜êµ¬ ê°•í™”ì— ì‚¬ìš©í•˜ì„¸ìš”.</p>
            <p>ğŸ† <strong>íŒ:</strong> ìƒˆë¡œìš´ ë ˆì‹œí”¼ë¥¼ ë°œê²¬í•˜ë©´ ì˜êµ¬ í•´ê¸ˆë©ë‹ˆë‹¤!</p>
        </div>
        <button class="btn" onclick="game.showMenu()">â† ëŒì•„ê°€ê¸°</button>
    </div>

    <div id="gameOverScreen" class="screen">
        <h2 class="title">ğŸ’€ íƒ‘ ë¶•ê´´</h2>
        <div class="stats">
            <p>ë„ë‹¬ ì¸µìˆ˜: <span id="finalFloor">0</span></p>
            <p>íšë“ ê³¨ë“œ: <span id="earnedGold">0</span></p>
            <p>ë°œê²¬ ë ˆì‹œí”¼: <span id="foundRecipes">0</span></p>
        </div>
        <button class="btn" onclick="game.retry()">ğŸ”„ ì¬ë„ì „</button>
        <button class="btn" onclick="game.showMenu()">â† ë©”ì¸ ë©”ë‰´</button>
    </div>

    <script>
        const game = {
            canvas: null,
            ctx: null,
            width: 800,
            height: 600,
            state: 'menu',
            
            // Game state
            floor: 1,
            gold: 0,
            hp: 100,
            maxHp: 100,
            wave: 0,
            
            // Crafting grid
            grid: Array(9).fill(null),
            dragging: null,
            dragOffset: { x: 0, y: 0 },
            
            // Inventory
            materials: {},
            potions: [],
            
            // Entities
            monsters: [],
            particles: [],
            projectiles: [],
            
            // Recipes (discovered)
            recipes: {},
            knownRecipes: {},
            
            // Upgrades
            upgrades: {
                maxHp: 0,
                damage: 0,
                potionSpeed: 0,
                goldBonus: 0,
                materialDrop: 0
            },
            
            // Timing
            lastFrame: 0,
            shake: 0,
            
            // Audio context
            audioCtx: null,
            
            init() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.resize();
                window.addEventListener('resize', () => this.resize());
                
                // Input handlers
                this.canvas.addEventListener('mousedown', (e) => this.handleStart(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMove(e));
                this.canvas.addEventListener('mouseup', (e) => this.handleEnd(e));
                this.canvas.addEventListener('touchstart', (e) => this.handleStart(e));
                this.canvas.addEventListener('touchmove', (e) => this.handleMove(e));
                this.canvas.addEventListener('touchend', (e) => this.handleEnd(e));
                
                this.initRecipes();
                this.loadGame();
                this.updateMenuStats();
                this.loop();
            },
            
            resize() {
                const maxWidth = Math.min(window.innerWidth, this.width);
                const maxHeight = Math.min(window.innerHeight, this.height);
                const scale = Math.min(maxWidth / this.width, maxHeight / this.height);
                
                this.canvas.width = this.width;
                this.canvas.height = this.height;
                this.canvas.style.width = (this.width * scale) + 'px';
                this.canvas.style.height = (this.height * scale) + 'px';
            },
            
            initRecipes() {
                // Basic potions (3 same materials)
                this.recipes = {
                    'fire,fire,fire': { name: 'ğŸ”¥ í™”ì—¼ í¬ì…˜', damage: 15, effect: 'fire', color: '#ff4444' },
                    'ice,ice,ice': { name: 'â„ï¸ ë¹™ê²° í¬ì…˜', damage: 10, effect: 'slow', color: '#44ddff' },
                    'poison,poison,poison': { name: 'â˜ ï¸ ë… í¬ì…˜', damage: 8, effect: 'poison', color: '#88ff44' },
                    'lightning,lightning,lightning': { name: 'âš¡ ë²ˆê°œ í¬ì…˜', damage: 20, effect: 'chain', color: '#ffff44' },
                    
                    // Combo potions
                    'fire,fire,ice': { name: 'ğŸ’¥ í­ë°œ í¬ì…˜', damage: 25, effect: 'explosion', color: '#ff8844' },
                    'ice,ice,poison': { name: 'ğŸ§Š ë™ê²°ë…', damage: 15, effect: 'freeze', color: '#44ff88' },
                    'fire,poison,poison': { name: 'ğŸŒ‹ ìš©ì•” í¬ì…˜', damage: 18, effect: 'lava', color: '#ff6622' },
                    'lightning,fire,ice': { name: 'ğŸŒŸ í˜¼ëˆ í¬ì…˜', damage: 30, effect: 'chaos', color: '#ff44ff' },
                    'ice,fire,lightning': { name: 'ğŸŒˆ ë¬´ì§€ê°œ í¬ì…˜', damage: 35, effect: 'rainbow', color: '#ffffff' },
                    'poison,lightning,lightning': { name: 'âš—ï¸ ì‚°ì„± ë²ˆê°œ', damage: 28, effect: 'acid', color: '#aaff22' },
                    
                    // Advanced combos
                    'fire,ice,poison': { name: 'ğŸ­ ë³€ì´ í¬ì…˜', damage: 22, effect: 'mutate', color: '#aa44ff' },
                    'lightning,poison,fire': { name: 'ğŸ’€ íŒŒë©¸ í¬ì…˜', damage: 40, effect: 'doom', color: '#ff0088' },
                    'ice,poison,lightning': { name: 'ğŸ”® ì‹ ë¹„ í¬ì…˜', damage: 33, effect: 'mystic', color: '#8844ff' },
                };
            },
            
            startGame() {
                this.state = 'playing';
                this.floor = 1;
                this.gold = 0;
                this.hp = 100 + this.upgrades.maxHp * 20;
                this.maxHp = this.hp;
                this.wave = 0;
                this.grid = Array(9).fill(null);
                this.potions = [];
                this.monsters = [];
                this.particles = [];
                this.projectiles = [];
                
                // Starting materials
                this.materials = {
                    fire: 5 + this.upgrades.materialDrop * 2,
                    ice: 5 + this.upgrades.materialDrop * 2,
                    poison: 3 + this.upgrades.materialDrop,
                    lightning: 2 + this.upgrades.materialDrop
                };
                
                this.hideAllScreens();
                this.spawnWave();
                this.playSound('start');
            },
            
            spawnWave() {
                this.wave++;
                const count = 3 + Math.floor(this.floor / 2) + this.wave;
                const baseHp = 20 + this.floor * 5;
                
                for (let i = 0; i < count; i++) {
                    setTimeout(() => {
                        this.monsters.push({
                            x: this.width + 50,
                            y: 100 + Math.random() * 300,
                            hp: baseHp + Math.random() * baseHp,
                            maxHp: baseHp * 1.5,
                            speed: 0.5 + this.floor * 0.05 + Math.random() * 0.3,
                            type: Math.random() < 0.7 ? 'basic' : (Math.random() < 0.5 ? 'fast' : 'tank'),
                            color: this.getMonsterColor(),
                            effects: []
                        });
                    }, i * 500);
                }
            },
            
            getMonsterColor() {
                const colors = ['#ff6b6b', '#ee5a6f', '#c44569', '#f66d44', '#fa8231'];
                return colors[Math.floor(Math.random() * colors.length)];
            },
            
            handleStart(e) {
                if (this.state !== 'playing') return;
                e.preventDefault();
                
                const pos = this.getInputPos(e);
                
                // Check material inventory click
                const matY = 450;
                let offsetX = 50;
                for (let mat in this.materials) {
                    if (this.materials[mat] > 0) {
                        if (pos.x >= offsetX && pos.x <= offsetX + 60 && 
                            pos.y >= matY && pos.y <= matY + 80) {
                            this.dragging = { type: 'material', material: mat, from: 'inventory' };
                            this.dragOffset = { x: pos.x - offsetX - 30, y: pos.y - matY - 30 };
                            return;
                        }
                        offsetX += 70;
                    }
                }
                
                // Check grid click
                const gridStart = { x: 500, y: 120 };
                const cellSize = 80;
                for (let i = 0; i < 9; i++) {
                    const row = Math.floor(i / 3);
                    const col = i % 3;
                    const gx = gridStart.x + col * cellSize;
                    const gy = gridStart.y + row * cellSize;
                    
                    if (pos.x >= gx && pos.x <= gx + cellSize &&
                        pos.y >= gy && pos.y <= gy + cellSize && this.grid[i]) {
                        this.dragging = { type: 'material', material: this.grid[i], from: 'grid', index: i };
                        this.dragOffset = { x: pos.x - gx - cellSize/2, y: pos.y - gy - cellSize/2 };
                        return;
                    }
                }
            },
            
            handleMove(e) {
                if (!this.dragging) return;
                e.preventDefault();
                
                const pos = this.getInputPos(e);
                this.dragging.x = pos.x - this.dragOffset.x;
                this.dragging.y = pos.y - this.dragOffset.y;
            },
            
            handleEnd(e) {
                if (!this.dragging) return;
                e.preventDefault();
                
                const pos = this.getInputPos(e);
                const gridStart = { x: 500, y: 120 };
                const cellSize = 80;
                
                // Check if dropped on grid
                for (let i = 0; i < 9; i++) {
                    const row = Math.floor(i / 3);
                    const col = i % 3;
                    const gx = gridStart.x + col * cellSize;
                    const gy = gridStart.y + row * cellSize;
                    
                    if (pos.x >= gx && pos.x <= gx + cellSize &&
                        pos.y >= gy && pos.y <= gy + cellSize) {
                        
                        if (this.dragging.from === 'inventory') {
                            if (!this.grid[i] && this.materials[this.dragging.material] > 0) {
                                this.grid[i] = this.dragging.material;
                                this.materials[this.dragging.material]--;
                                this.playSound('place');
                                this.checkCraft();
                            }
                        } else if (this.dragging.from === 'grid' && this.dragging.index !== i) {
                            // Swap grid items
                            const temp = this.grid[i];
                            this.grid[i] = this.grid[this.dragging.index];
                            this.grid[this.dragging.index] = temp;
                            this.playSound('place');
                            this.checkCraft();
                        }
                        
                        this.dragging = null;
                        return;
                    }
                }
                
                // Return to inventory if from grid
                if (this.dragging.from === 'grid') {
                    this.materials[this.dragging.material]++;
                    this.grid[this.dragging.index] = null;
                    this.playSound('place');
                }
                
                this.dragging = null;
            },
            
            checkCraft() {
                // Check for valid recipes
                const materials = this.grid.filter(m => m !== null);
                if (materials.length !== 3) return;
                
                const sorted = [...materials].sort().join(',');
                const recipe = this.recipes[sorted];
                
                if (recipe) {
                    // Clear grid
                    this.grid = Array(9).fill(null);
                    
                    // Create potion
                    this.potions.push({
                        x: 600,
                        y: 260,
                        recipe: recipe,
                        ready: true
                    });
                    
                    // Discover recipe
                    if (!this.knownRecipes[sorted]) {
                        this.knownRecipes[sorted] = recipe;
                        this.createParticles(600, 260, recipe.color, 20);
                        this.playSound('discover');
                    } else {
                        this.playSound('craft');
                    }
                }
            },
            
            getInputPos(e) {
                const rect = this.canvas.getBoundingClientRect();
                const scaleX = this.canvas.width / rect.width;
                const scaleY = this.canvas.height / rect.height;
                
                const clientX = e.clientX || (e.touches && e.touches[0].clientX);
                const clientY = e.clientY || (e.touches && e.touches[0].clientY);
                
                return {
                    x: (clientX - rect.left) * scaleX,
                    y: (clientY - rect.top) * scaleY
                };
            },
            
            update(dt) {
                if (this.state !== 'playing') return;
                
                // Update shake
                if (this.shake > 0) this.shake *= 0.9;
                
                // Update monsters
                for (let i = this.monsters.length - 1; i >= 0; i--) {
                    const m = this.monsters[i];
                    m.x -= m.speed;
                    
                    // Apply effects
                    for (let j = m.effects.length - 1; j >= 0; j--) {
                        const eff = m.effects[j];
                        eff.duration -= dt;
                        
                        if (eff.type === 'poison' || eff.type === 'lava') {
                            m.hp -= eff.damage * dt / 1000;
                        }
                        
                        if (eff.duration <= 0) {
                            m.effects.splice(j, 1);
                        }
                    }
                    
                    // Check if reached tower
                    if (m.x < 50) {
                        this.hp -= 10;
                        this.shake = 10;
                        this.monsters.splice(i, 1);
                        this.playSound('hit');
                        
                        if (this.hp <= 0) {
                            this.gameOver();
                        }
                        continue;
                    }
                    
                    // Check if dead
                    if (m.hp <= 0) {
                        const goldDrop = 5 + this.floor + Math.floor(this.upgrades.goldBonus * 2);
                        this.gold += goldDrop;
                        this.materials.fire += Math.random() < 0.3 + this.upgrades.materialDrop * 0.05 ? 1 : 0;
                        this.materials.ice += Math.random() < 0.3 + this.upgrades.materialDrop * 0.05 ? 1 : 0;
                        this.materials.poison += Math.random() < 0.2 + this.upgrades.materialDrop * 0.05 ? 1 : 0;
                        this.materials.lightning += Math.random() < 0.1 + this.upgrades.materialDrop * 0.05 ? 1 : 0;
                        
                        this.createParticles(m.x, m.y, m.color, 15);
                        this.monsters.splice(i, 1);
                        this.playSound('kill');
                    }
                }
                
                // Auto-fire potions
                for (let i = this.potions.length - 1; i >= 0; i--) {
                    const p = this.potions[i];
                    if (p.ready && this.monsters.length > 0) {
                        const target = this.monsters[0];
                        this.projectiles.push({
                            x: p.x,
                            y: p.y,
                            targetX: target.x,
                            targetY: target.y,
                            speed: 5 + this.upgrades.potionSpeed,
                            recipe: p.recipe,
                            target: target
                        });
                        this.potions.splice(i, 1);
                        this.playSound('throw');
                    }
                }
                
                // Update projectiles
                for (let i = this.projectiles.length - 1; i >= 0; i--) {
                    const proj = this.projectiles[i];
                    const dx = proj.targetX - proj.x;
                    const dy = proj.targetY - proj.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < proj.speed) {
                        this.applyPotionEffect(proj);
                        this.projectiles.splice(i, 1);
                    } else {
                        proj.x += (dx / dist) * proj.speed;
                        proj.y += (dy / dist) * proj.speed;
                    }
                }
                
                // Update particles
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life -= dt;
                    p.alpha = p.life / p.maxLife;
                    
                    if (p.life <= 0) {
                        this.particles.splice(i, 1);
                    }
                }
                
                // Check wave clear
                if (this.monsters.length === 0 && this.wave >= 3) {
                    this.nextFloor();
                }
            },
            
            applyPotionEffect(proj) {
                const recipe = proj.recipe;
                const baseDamage = recipe.damage + this.upgrades.damage * 3;
                
                this.createParticles(proj.targetX, proj.targetY, recipe.color, 10);
                this.playSound('explosion');
                
                switch (recipe.effect) {
                    case 'fire':
                        proj.target.hp -= baseDamage;
                        break;
                    case 'slow':
                        proj.target.hp -= baseDamage;
                        proj.target.speed *= 0.5;
                        proj.target.effects.push({ type: 'slow', duration: 2000 });
                        break;
                    case 'poison':
                        proj.target.hp -= baseDamage * 0.5;
                        proj.target.effects.push({ type: 'poison', damage: baseDamage * 0.5, duration: 3000 });
                        break;
                    case 'chain':
                        for (let m of this.monsters.slice(0, 3)) {
                            m.hp -= baseDamage * 0.8;
                        }
                        break;
                    case 'explosion':
                        this.shake = 8;
                        for (let m of this.monsters) {
                            const dist = Math.hypot(m.x - proj.targetX, m.y - proj.targetY);
                            if (dist < 100) {
                                m.hp -= baseDamage * (1 - dist / 100);
                            }
                        }
                        break;
                    case 'freeze':
                        proj.target.hp -= baseDamage;
                        proj.target.speed = 0;
                        proj.target.effects.push({ type: 'freeze', duration: 2000 });
                        setTimeout(() => { if (proj.target) proj.target.speed = 0.5; }, 2000);
                        break;
                    case 'lava':
                        proj.target.hp -= baseDamage;
                        proj.target.effects.push({ type: 'lava', damage: baseDamage, duration: 4000 });
                        break;
                    case 'chaos':
                        for (let m of this.monsters.slice(0, 5)) {
                            m.hp -= baseDamage * 0.6;
                            m.effects.push({ type: 'chaos', duration: 1000 });
                        }
                        this.shake = 5;
                        break;
                    case 'rainbow':
                        for (let m of this.monsters) {
                            m.hp -= baseDamage * 0.4;
                        }
                        this.shake = 10;
                        break;
                    case 'acid':
                        proj.target.hp -= baseDamage;
                        proj.target.maxHp *= 0.9;
                        break;
                    case 'mutate':
                        proj.target.hp -= baseDamage;
                        proj.target.type = 'mutated';
                        proj.target.color = '#ff00ff';
                        break;
                    case 'doom':
                        proj.target.hp -= baseDamage * 2;
                        this.shake = 12;
                        break;
                    case 'mystic':
                        for (let m of this.monsters.slice(0, 4)) {
                            m.hp -= baseDamage * 0.7;
                            m.effects.push({ type: 'mystic', duration: 2000 });
                        }
                        break;
                }
            },
            
            nextFloor() {
                this.floor++;
                this.wave = 0;
                this.hp = Math.min(this.maxHp, this.hp + 30);
                
                this.createParticles(this.width / 2, this.height / 2, '#ffd700', 30);
                this.playSound('levelup');
                
                setTimeout(() => {
                    this.spawnWave();
                }, 2000);
            },
            
            createParticles(x, y, color, count) {
                for (let i = 0; i < count; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 3 + 1;
                    this.particles.push({
                        x, y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        color,
                        life: 1000,
                        maxLife: 1000,
                        alpha: 1
                    });
                }
            },
            
            draw() {
                const ctx = this.ctx;
                
                // Clear with shake
                ctx.save();
                if (this.shake > 0) {
                    ctx.translate(
                        (Math.random() - 0.5) * this.shake,
                        (Math.random() - 0.5) * this.shake
                    );
                }
                
                ctx.fillStyle = '#0a0e1a';
                ctx.fillRect(0, 0, this.width, this.height);
                
                if (this.state === 'playing') {
                    this.drawGame();
                }
                
                ctx.restore();
            },
            
            drawGame() {
                const ctx = this.ctx;
                
                // Tower
                ctx.fillStyle = '#2c3e50';
                ctx.fillRect(10, 100, 60, 400);
                ctx.fillStyle = '#34495e';
                ctx.fillRect(15, 105, 50, 390);
                ctx.fillStyle = '#e74c3c';
                ctx.fillRect(20, 100 + (400 * (1 - this.hp / this.maxHp)), 40, (400 * this.hp / this.maxHp));
                
                // UI Background
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(0, 0, this.width, 80);
                ctx.fillRect(0, 420, this.width, 180);
                
                // Stats
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 20px sans-serif';
                ctx.fillText(`ğŸ° ì¸µ: ${this.floor}`, 90, 30);
                ctx.fillText(`â¤ï¸ HP: ${Math.ceil(this.hp)}/${this.maxHp}`, 90, 60);
                ctx.fillText(`ğŸ’° ê³¨ë“œ: ${this.gold}`, 250, 30);
                ctx.fillText(`ğŸ‘¾ ì›¨ì´ë¸Œ: ${this.wave}/3`, 250, 60);
                
                // Materials inventory
                ctx.fillText('ì¬ë£Œ:', 20, 450);
                let offsetX = 50;
                const matIcons = { fire: 'ğŸ”¥', ice: 'â„ï¸', poison: 'â˜ ï¸', lightning: 'âš¡' };
                const matColors = { fire: '#ff4444', ice: '#44ddff', poison: '#88ff44', lightning: '#ffff44' };
                
                for (let mat in this.materials) {
                    if (this.materials[mat] > 0) {
                        ctx.fillStyle = matColors[mat];
                        ctx.fillRect(offsetX, 450, 60, 60);
                        ctx.fillStyle = '#fff';
                        ctx.font = '30px sans-serif';
                        ctx.fillText(matIcons[mat], offsetX + 15, 490);
                        ctx.font = 'bold 16px sans-serif';
                        ctx.fillText(this.materials[mat], offsetX + 45, 505);
                        offsetX += 70;
                    }
                }
                
                // Crafting grid
                const gridStart = { x: 500, y: 120 };
                const cellSize = 80;
                
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 18px sans-serif';
                ctx.fillText('í•©ì„± ê·¸ë¦¬ë“œ', gridStart.x, gridStart.y - 10);
                
                for (let i = 0; i < 9; i++) {
                    const row = Math.floor(i / 3);
                    const col = i % 3;
                    const x = gridStart.x + col * cellSize;
                    const y = gridStart.y + row * cellSize;
                    
                    ctx.strokeStyle = '#555';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x, y, cellSize, cellSize);
                    
                    if (this.grid[i]) {
                        const mat = this.grid[i];
                        ctx.fillStyle = matColors[mat];
                        ctx.fillRect(x + 5, y + 5, cellSize - 10, cellSize - 10);
                        ctx.font = '40px sans-serif';
                        ctx.fillText(matIcons[mat], x + 20, y + 55);
                    }
                }
                
                // Potions ready
                for (let p of this.potions) {
                    ctx.fillStyle = p.recipe.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 15, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Dragging
                if (this.dragging && this.dragging.x) {
                    const mat = this.dragging.material;
                    ctx.fillStyle = matColors[mat];
                    ctx.globalAlpha = 0.7;
                    ctx.fillRect(this.dragging.x - 30, this.dragging.y - 30, 60, 60);
                    ctx.globalAlpha = 1;
                    ctx.font = '40px sans-serif';
                    ctx.fillText(matIcons[mat], this.dragging.x - 20, this.dragging.y + 10);
                }
                
                // Monsters
                for (let m of this.monsters) {
                    ctx.fillStyle = m.color;
                    ctx.fillRect(m.x - 20, m.y - 20, 40, 40);
                    
                    // HP bar
                    ctx.fillStyle = '#000';
                    ctx.fillRect(m.x - 25, m.y - 30, 50, 6);
                    ctx.fillStyle = '#0f0';
                    ctx.fillRect(m.x - 25, m.y - 30, 50 * (m.hp / m.maxHp), 6);
                    
                    // Effects
                    if (m.effects.some(e => e.type === 'freeze')) {
                        ctx.fillStyle = 'rgba(100, 200, 255, 0.5)';
                        ctx.fillRect(m.x - 25, m.y - 25, 50, 50);
                    }
                }
                
                // Projectiles
                for (let proj of this.projectiles) {
                    ctx.fillStyle = proj.recipe.color;
                    ctx.beginPath();
                    ctx.arc(proj.x, proj.y, 8, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Particles
                for (let p of this.particles) {
                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = p.alpha;
                    ctx.fillRect(p.x - 2, p.y - 2, 4, 4);
                }
                ctx.globalAlpha = 1;
            },
            
            gameOver() {
                this.state = 'gameover';
                
                // Save progress
                const save = this.loadSave();
                save.totalGold += this.gold;
                save.highFloor = Math.max(save.highFloor, this.floor);
                save.knownRecipes = { ...save.knownRecipes, ...this.knownRecipes };
                this.saveSave(save);
                
                document.getElementById('finalFloor').textContent = this.floor;
                document.getElementById('earnedGold').textContent = this.gold;
                document.getElementById('foundRecipes').textContent = Object.keys(this.knownRecipes).length;
                
                this.showScreen('gameOverScreen');
                this.playSound('gameover');
            },
            
            showMenu() {
                this.state = 'menu';
                this.updateMenuStats();
                this.showScreen('menuScreen');
            },
            
            showUpgrades() {
                const save = this.loadSave();
                this.upgrades = save.upgrades;
                
                document.getElementById('upgradeGold').textContent = save.totalGold;
                
                const upgradeList = document.getElementById('upgradeList');
                upgradeList.innerHTML = '';
                
                const upgradeDefs = [
                    { key: 'maxHp', name: 'ìµœëŒ€ HP ì¦ê°€', cost: (lvl) => 50 + lvl * 30, desc: '+20 HP' },
                    { key: 'damage', name: 'í¬ì…˜ ë°ë¯¸ì§€ ì¦ê°€', cost: (lvl) => 60 + lvl * 40, desc: '+3 ë°ë¯¸ì§€' },
                    { key: 'potionSpeed', name: 'í¬ì…˜ ì†ë„ ì¦ê°€', cost: (lvl) => 40 + lvl * 25, desc: 'íˆ¬ì²™ ì†ë„ í–¥ìƒ' },
                    { key: 'goldBonus', name: 'ê³¨ë“œ ë³´ë„ˆìŠ¤', cost: (lvl) => 70 + lvl * 50, desc: '+2 ê³¨ë“œ/í‚¬' },
                    { key: 'materialDrop', name: 'ì¬ë£Œ ë“œëë¥  ì¦ê°€', cost: (lvl) => 80 + lvl * 60, desc: 'ë“œë í™•ë¥  +5%' }
                ];
                
                for (let def of upgradeDefs) {
                    const level = this.upgrades[def.key];
                    const cost = def.cost(level);
                    
                    const div = document.createElement('div');
                    div.className = 'recipe-item';
                    div.innerHTML = `
                        <strong>${def.name}</strong> (ë ˆë²¨ ${level})<br>
                        ${def.desc} | ë¹„ìš©: ${cost} ê³¨ë“œ
                        ${save.totalGold >= cost ? '<button class="btn" style="margin-left: 10px; padding: 5px 15px;">êµ¬ë§¤</button>' : ''}
                    `;
                    
                    if (save.totalGold >= cost) {
                        const btn = div.querySelector('button');
                        btn.onclick = () => {
                            save.totalGold -= cost;
                            save.upgrades[def.key]++;
                            this.saveSave(save);
                            this.showUpgrades();
                            this.playSound('upgrade');
                        };
                    }
                    
                    upgradeList.appendChild(div);
                }
                
                this.showScreen('upgradeScreen');
            },
            
            showRecipes() {
                const save = this.loadSave();
                const recipeList = document.getElementById('recipeList');
                recipeList.innerHTML = '';
                
                const known = Object.keys(save.knownRecipes);
                if (known.length === 0) {
                    recipeList.innerHTML = '<p style="color: #fff;">ì•„ì§ ë°œê²¬í•œ ë ˆì‹œí”¼ê°€ ì—†ìŠµë‹ˆë‹¤.</p>';
                } else {
                    for (let key of known) {
                        const recipe = save.knownRecipes[key];
                        const div = document.createElement('div');
                        div.className = 'recipe-item';
                        div.innerHTML = `
                            <strong>${recipe.name}</strong><br>
                            ì¬ë£Œ: ${key.split(',').map(m => ({ fire: 'ğŸ”¥', ice: 'â„ï¸', poison: 'â˜ ï¸', lightning: 'âš¡' })[m]).join(' + ')}<br>
                            ë°ë¯¸ì§€: ${recipe.damage} | íš¨ê³¼: ${recipe.effect}
                        `;
                        recipeList.appendChild(div);
                    }
                }
                
                this.showScreen('recipeScreen');
            },
            
            showHelp() {
                this.showScreen('helpScreen');
            },
            
            retry() {
                this.startGame();
            },
            
            updateMenuStats() {
                const save = this.loadSave();
                document.getElementById('highFloor').textContent = save.highFloor;
                document.getElementById('totalGold').textContent = save.totalGold;
            },
            
            loadGame() {
                const save = this.loadSave();
                this.upgrades = save.upgrades;
                this.knownRecipes = save.knownRecipes;
            },
            
            loadSave() {
                const saved = localStorage.getItem('alchemistTower');
                if (saved) {
                    return JSON.parse(saved);
                }
                return {
                    highFloor: 0,
                    totalGold: 0,
                    knownRecipes: {},
                    upgrades: { maxHp: 0, damage: 0, potionSpeed: 0, goldBonus: 0, materialDrop: 0 }
                };
            },
            
            saveSave(data) {
                localStorage.setItem('alchemistTower', JSON.stringify(data));
            },
            
            hideAllScreens() {
                document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            },
            
            showScreen(id) {
                this.hideAllScreens();
                document.getElementById(id).classList.add('active');
            },
            
            playSound(type) {
                if (!this.audioCtx) {
                    this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                }
                
                const ctx = this.audioCtx;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                
                osc.connect(gain);
                gain.connect(ctx.destination);
                
                const now = ctx.currentTime;
                
                switch (type) {
                    case 'place':
                        osc.frequency.value = 400;
                        gain.gain.setValueAtTime(0.1, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                        osc.start(now);
                        osc.stop(now + 0.1);
                        break;
                    case 'craft':
                        osc.frequency.value = 600;
                        gain.gain.setValueAtTime(0.15, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                        osc.start(now);
                        osc.stop(now + 0.2);
                        break;
                    case 'discover':
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(400, now);
                        osc.frequency.exponentialRampToValueAtTime(800, now + 0.3);
                        gain.gain.setValueAtTime(0.2, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                        osc.start(now);
                        osc.stop(now + 0.3);
                        break;
                    case 'throw':
                        osc.frequency.value = 300;
                        gain.gain.setValueAtTime(0.08, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
                        osc.start(now);
                        osc.stop(now + 0.15);
                        break;
                    case 'explosion':
                        osc.type = 'sawtooth';
                        osc.frequency.value = 100;
                        gain.gain.setValueAtTime(0.2, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                        osc.start(now);
                        osc.stop(now + 0.3);
                        break;
                    case 'kill':
                        osc.frequency.setValueAtTime(500, now);
                        osc.frequency.exponentialRampToValueAtTime(200, now + 0.2);
                        gain.gain.setValueAtTime(0.15, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                        osc.start(now);
                        osc.stop(now + 0.2);
                        break;
                    case 'hit':
                        osc.type = 'sawtooth';
                        osc.frequency.value = 150;
                        gain.gain.setValueAtTime(0.3, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
                        osc.start(now);
                        osc.stop(now + 0.2);
                        break;
                    case 'levelup':
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(400, now);
                        osc.frequency.exponentialRampToValueAtTime(800, now + 0.1);
                        osc.frequency.exponentialRampToValueAtTime(1000, now + 0.3);
                        gain.gain.setValueAtTime(0.2, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
                        osc.start(now);
                        osc.stop(now + 0.4);
                        break;
                    case 'start':
                        osc.frequency.setValueAtTime(300, now);
                        osc.frequency.exponentialRampToValueAtTime(600, now + 0.3);
                        gain.gain.setValueAtTime(0.15, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                        osc.start(now);
                        osc.stop(now + 0.3);
                        break;
                    case 'gameover':
                        osc.type = 'sawtooth';
                        osc.frequency.setValueAtTime(400, now);
                        osc.frequency.exponentialRampToValueAtTime(100, now + 0.5);
                        gain.gain.setValueAtTime(0.2, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                        osc.start(now);
                        osc.stop(now + 0.5);
                        break;
                    case 'upgrade':
                        osc.frequency.setValueAtTime(500, now);
                        osc.frequency.exponentialRampToValueAtTime(1000, now + 0.2);
                        gain.gain.setValueAtTime(0.2, now);
                        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
                        osc.start(now);
                        osc.stop(now + 0.3);
                        break;
                }
            },
            
            loop(timestamp = 0) {
                const dt = timestamp - this.lastFrame;
                this.lastFrame = timestamp;
                
                this.update(dt);
                this.draw();
                
                requestAnimationFrame((t) => this.loop(t));
            }
        };
        
        // Initialize on load
        window.addEventListener('load', () => game.init());
    </script>
</body>
</html>