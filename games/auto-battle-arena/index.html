<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>âš”ï¸ Auto Battle Arena - ì˜¤í† ë°°í‹€ ì•„ë ˆë‚˜</title>
<style>
*{margin:0;padding:0;box-sizing:border-box;-webkit-tap-highlight-color:transparent;user-select:none;-webkit-user-select:none}
html,body{width:100%;height:100%;overflow:hidden;background:#0a0a1a;font-family:'Segoe UI',system-ui,-apple-system,sans-serif;color:#e0e0e0}
canvas{display:block;touch-action:none}
#ui-overlay{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:10}
#ui-overlay *{pointer-events:auto}
.btn{background:linear-gradient(180deg,#3a3a6a,#2a2a4a);border:2px solid #5a5a8a;color:#fff;padding:8px 16px;border-radius:8px;font-size:14px;cursor:pointer;transition:all .15s;text-shadow:0 1px 2px rgba(0,0,0,.5)}
.btn:hover{background:linear-gradient(180deg,#4a4a7a,#3a3a5a);transform:translateY(-1px)}
.btn:active{transform:translateY(1px);background:linear-gradient(180deg,#2a2a4a,#1a1a3a)}
.btn-gold{background:linear-gradient(180deg,#b8860b,#8b6508);border-color:#daa520}
.btn-gold:hover{background:linear-gradient(180deg,#d4a017,#b8860b)}
.btn-red{background:linear-gradient(180deg,#8b0000,#5a0000);border-color:#cd5c5c}
.btn-green{background:linear-gradient(180deg,#006400,#004000);border-color:#32cd32}
.btn-green:hover{background:linear-gradient(180deg,#008000,#006400)}
#top-bar{position:absolute;top:0;left:0;right:0;height:44px;background:linear-gradient(180deg,rgba(20,20,40,.95),rgba(10,10,30,.95));display:flex;align-items:center;justify-content:space-between;padding:0 12px;border-bottom:1px solid #333;z-index:20}
#top-bar .info{font-size:13px;display:flex;gap:12px;align-items:center}
#top-bar .gold{color:#ffd700;font-weight:bold}
#top-bar .round{color:#aaf}
#top-bar .hp{color:#f66}
#bottom-panel{position:absolute;bottom:0;left:0;right:0;background:linear-gradient(0deg,rgba(20,20,40,.97),rgba(15,15,35,.95));border-top:1px solid #333;z-index:20;display:none;padding:8px}
#shop-panel{display:flex;gap:8px;justify-content:center;flex-wrap:wrap;align-items:flex-start}
.shop-card{background:linear-gradient(180deg,#1a1a3a,#12122a);border:2px solid #444;border-radius:10px;padding:10px;width:110px;text-align:center;cursor:pointer;transition:all .2s}
.shop-card:hover{border-color:#7af;transform:translateY(-3px);box-shadow:0 4px 12px rgba(100,150,255,.3)}
.shop-card .hero-icon{font-size:32px;margin:4px 0}
.shop-card .hero-name{font-size:11px;font-weight:bold;margin:2px 0}
.shop-card .hero-cost{color:#ffd700;font-size:12px}
.shop-card .hero-type{font-size:10px;color:#aaa}
.tier-1{border-color:#888;box-shadow:0 0 8px rgba(150,150,150,.2)}
.tier-2{border-color:#4a9eff;box-shadow:0 0 8px rgba(74,158,255,.3)}
.tier-3{border-color:#ff6ef0;box-shadow:0 0 8px rgba(255,110,240,.3)}
#bench-panel{position:absolute;bottom:0;left:0;right:0;background:linear-gradient(0deg,rgba(25,15,10,.97),rgba(20,12,8,.95));border-top:2px solid #8b6508;z-index:19;display:none;padding:6px 8px}
#bench-slots{display:flex;gap:6px;justify-content:center;overflow-x:auto;padding:4px 0}
.bench-slot{width:56px;height:56px;background:rgba(50,40,20,.6);border:1px dashed #8b6508;border-radius:8px;display:flex;align-items:center;justify-content:center;font-size:28px;cursor:pointer;position:relative}
.bench-slot .tier-badge{position:absolute;top:-4px;right:-4px;width:16px;height:16px;border-radius:50%;font-size:9px;display:flex;align-items:center;justify-content:center;font-weight:bold}
#modal-overlay{position:absolute;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.7);display:none;align-items:center;justify-content:center;z-index:100}
#modal{background:linear-gradient(180deg,#1a1a3a,#0e0e24);border:2px solid #5a5a8a;border-radius:16px;padding:24px;max-width:400px;width:90%;text-align:center;box-shadow:0 8px 32px rgba(0,0,0,.6)}
#modal h2{margin-bottom:12px;font-size:22px}
#modal p{margin:8px 0;font-size:14px;color:#bbb;line-height:1.5}
#modal .btn{margin:6px}
#toast{position:absolute;top:50px;left:50%;transform:translateX(-50%);background:rgba(20,20,50,.95);border:1px solid #7af;border-radius:8px;padding:8px 20px;font-size:13px;z-index:200;opacity:0;transition:opacity .3s;pointer-events:none}
#item-panel{position:absolute;top:50px;right:8px;background:rgba(20,20,40,.9);border:1px solid #555;border-radius:8px;padding:8px;z-index:15;display:none;max-height:200px;overflow-y:auto}
.item-slot{width:40px;height:40px;background:rgba(60,60,80,.5);border:1px solid #666;border-radius:6px;display:inline-flex;align-items:center;justify-content:center;font-size:20px;margin:2px;cursor:pointer}
#synergy-panel{position:absolute;top:50px;left:8px;background:rgba(20,20,40,.9);border:1px solid #555;border-radius:8px;padding:8px;z-index:15;display:none;font-size:11px;max-width:160px}
.synergy-row{display:flex;align-items:center;gap:4px;margin:3px 0}
.synergy-active{color:#4f4}
.synergy-inactive{color:#666}
#phase-banner{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-size:28px;font-weight:bold;z-index:50;opacity:0;transition:opacity .5s;text-shadow:0 2px 8px rgba(0,0,0,.8);pointer-events:none}
#menu-btn{position:absolute;top:50px;right:8px;z-index:15}
.hero-detail{position:absolute;background:rgba(15,15,35,.95);border:2px solid #7af;border-radius:10px;padding:12px;z-index:60;width:200px;font-size:12px;display:none}
.hero-detail h3{font-size:16px;margin-bottom:6px}
.hero-detail .stat{display:flex;justify-content:space-between;margin:2px 0}
.hero-detail .stat-bar{height:4px;border-radius:2px;margin-top:1px}
@media(max-width:600px){
  .shop-card{width:90px;padding:6px}
  .shop-card .hero-icon{font-size:26px}
  .shop-card .hero-name{font-size:10px}
  #top-bar .info{font-size:11px;gap:8px}
  .btn{padding:6px 12px;font-size:12px}
}
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="ui-overlay">
  <div id="top-bar">
    <div class="info">
      <span class="round" id="round-info">ğŸŸï¸ R1</span>
      <span class="gold" id="gold-info">ğŸ’° 10</span>
      <span class="hp" id="hp-info">â¤ï¸ 100</span>
    </div>
    <div class="info">
      <span id="phase-info" style="color:#8af;font-size:12px">ì¤€ë¹„ ë‹¨ê³„</span>
      <button class="btn" id="lang-btn" style="padding:4px 8px;font-size:11px">EN</button>
    </div>
  </div>
  <div id="phase-banner"></div>
  <div id="synergy-panel"></div>
  <div id="item-panel"></div>
  <div id="bottom-panel">
    <div id="shop-panel"></div>
    <div style="text-align:center;margin-top:6px;display:flex;gap:8px;justify-content:center">
      <button class="btn btn-gold" id="reroll-btn">ğŸ”„ ë¦¬ë¡¤ (2ğŸ’°)</button>
      <button class="btn btn-green" id="battle-btn">âš”ï¸ ì „íˆ¬ ì‹œì‘!</button>
      <button class="btn" id="save-btn" style="font-size:11px">ğŸ’¾</button>
    </div>
  </div>
  <div id="bench-panel">
    <div style="font-size:11px;color:#daa520;margin-bottom:4px;text-align:center">ğŸ“¦ ëŒ€ê¸°ì„ (í„°ì¹˜í•˜ì—¬ ë°°ì¹˜/íšŒìˆ˜)</div>
    <div id="bench-slots"></div>
  </div>
  <div id="modal-overlay">
    <div id="modal">
      <h2 id="modal-title">Auto Battle Arena</h2>
      <p id="modal-body"></p>
      <div id="modal-buttons"></div>
    </div>
  </div>
  <div id="toast"></div>
</div>

<script>
'use strict';
// ============================================================
// AUTO BATTLE ARENA - Complete Auto-Battler Game
// ============================================================

// ---- CONSTANTS & CONFIG ----
const C = document.getElementById('gameCanvas');
const ctx = C.getContext('2d');
const GRID_COLS = 4, GRID_ROWS = 3;
const BENCH_SIZE = 8;
const MAX_HP = 100;
const REROLL_COST = 2;
const BASE_GOLD_PER_ROUND = 5;
const INTEREST_RATE = 0.1; // 10% of gold as interest, max 5
const BOSS_INTERVAL = 5;

// ---- LANGUAGE ----
let lang = 'ko';
const T = {
  ko: {
    title: 'âš”ï¸ ì˜¤í† ë°°í‹€ ì•„ë ˆë‚˜',
    prepare: 'ì¤€ë¹„ ë‹¨ê³„',
    battle: 'ì „íˆ¬ ì¤‘!',
    victory: 'ğŸ‰ ìŠ¹ë¦¬!',
    defeat: 'ğŸ’€ íŒ¨ë°°...',
    shop: 'ì˜ì›… ìƒì ',
    reroll: 'ğŸ”„ ë¦¬ë¡¤',
    startBattle: 'âš”ï¸ ì „íˆ¬ ì‹œì‘!',
    save: 'ğŸ’¾ ì €ì¥',
    load: 'ğŸ“‚ ë¶ˆëŸ¬ì˜¤ê¸°',
    newGame: 'ğŸ†• ìƒˆ ê²Œì„',
    round: 'ë¼ìš´ë“œ',
    gold: 'ê³¨ë“œ',
    hp: 'HP',
    bench: 'ëŒ€ê¸°ì„',
    benchHint: 'ğŸ“¦ ëŒ€ê¸°ì„ (í„°ì¹˜í•˜ì—¬ ë°°ì¹˜/íšŒìˆ˜)',
    noGold: 'ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤!',
    benchFull: 'ëŒ€ê¸°ì„ì´ ê°€ë“ ì°¼ìŠµë‹ˆë‹¤!',
    merged: 'í•©ì„± ì„±ê³µ! â­',
    itemDrop: 'ì•„ì´í…œ íšë“!',
    bossRound: 'ğŸ”¥ ë³´ìŠ¤ ë¼ìš´ë“œ!',
    gameOver: 'ê²Œì„ ì˜¤ë²„',
    gameOverMsg: 'ë¼ìš´ë“œ {r}ì—ì„œ íŒ¨ë°°í–ˆìŠµë‹ˆë‹¤.\nìµœì¢… ì ìˆ˜: {s}',
    continueMsg: 'ë‹¤ìŒ ë¼ìš´ë“œë¡œ!',
    saved: 'ì €ì¥ ì™„ë£Œ!',
    loaded: 'ë¶ˆëŸ¬ì˜¤ê¸° ì™„ë£Œ!',
    noSave: 'ì €ì¥ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.',
    dragHint: 'ì˜ì›…ì„ ë“œë˜ê·¸í•˜ì—¬ ê·¸ë¦¬ë“œì— ë°°ì¹˜í•˜ì„¸ìš”',
    sellHint: 'ë²¤ì¹˜ ë°–ìœ¼ë¡œ ë“œë˜ê·¸í•˜ì—¬ íŒë§¤',
    synergyBonus: 'ì‹œë„ˆì§€ ë³´ë„ˆìŠ¤!',
    warrior: 'ì „ì‚¬', archer: 'ê¶ìˆ˜', mage: 'ë§ˆë²•ì‚¬',
    healer: 'íëŸ¬', tank: 'íƒ±ì»¤', assassin: 'ì•”ì‚´ì',
    atk: 'ê³µê²©ë ¥', def: 'ë°©ì–´ë ¥', spd: 'ì†ë„', hp2: 'ì²´ë ¥',
    skill: 'ìŠ¤í‚¬', cost: 'ë¹„ìš©',
    tier: 'í‹°ì–´',
    equipment: 'ì¥ë¹„',
    selectTarget: 'ì¥ë¹„í•  ì˜ì›…ì„ ì„ íƒí•˜ì„¸ìš”',
    welcome: 'ì˜¤í† ë°°í‹€ ì•„ë ˆë‚˜ì— ì˜¤ì‹  ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤!\n\nì˜ì›…ì„ êµ¬ë§¤í•˜ê³  ê·¸ë¦¬ë“œì— ë°°ì¹˜í•œ ë’¤\nì „íˆ¬ë¥¼ ì‹œì‘í•˜ì„¸ìš”.\n\nê°™ì€ ì˜ì›… 3ê°œ í•©ì„± â†’ ìƒìœ„ í‹°ì–´!\nê°™ì€ íƒ€ì… 3ê°œ â†’ ì‹œë„ˆì§€ ë³´ë„ˆìŠ¤!',
    play: 'â–¶ï¸ ì‹œì‘í•˜ê¸°',
    resume: 'â–¶ï¸ ì´ì–´í•˜ê¸°',
    credits: 'ğŸ® By OpenClaw',
    interest: 'ì´ì',
    streak: 'ì—°ìŠ¹',
  },
  en: {
    title: 'âš”ï¸ Auto Battle Arena',
    prepare: 'Preparation',
    battle: 'Battle!',
    victory: 'ğŸ‰ Victory!',
    defeat: 'ğŸ’€ Defeat...',
    shop: 'Hero Shop',
    reroll: 'ğŸ”„ Reroll',
    startBattle: 'âš”ï¸ Start Battle!',
    save: 'ğŸ’¾ Save',
    load: 'ğŸ“‚ Load',
    newGame: 'ğŸ†• New Game',
    round: 'Round',
    gold: 'Gold',
    hp: 'HP',
    bench: 'Bench',
    benchHint: 'ğŸ“¦ Bench (tap to place/recall)',
    noGold: 'Not enough gold!',
    benchFull: 'Bench is full!',
    merged: 'Merge success! â­',
    itemDrop: 'Item dropped!',
    bossRound: 'ğŸ”¥ Boss Round!',
    gameOver: 'Game Over',
    gameOverMsg: 'Defeated at round {r}.\nFinal score: {s}',
    continueMsg: 'Next round!',
    saved: 'Game saved!',
    loaded: 'Game loaded!',
    noSave: 'No save data found.',
    dragHint: 'Drag heroes to place on grid',
    sellHint: 'Drag outside bench to sell',
    synergyBonus: 'Synergy Bonus!',
    warrior: 'Warrior', archer: 'Archer', mage: 'Mage',
    healer: 'Healer', tank: 'Tank', assassin: 'Assassin',
    atk: 'ATK', def: 'DEF', spd: 'SPD', hp2: 'HP',
    skill: 'Skill', cost: 'Cost',
    tier: 'Tier',
    equipment: 'Equipment',
    selectTarget: 'Select hero to equip',
    welcome: 'Welcome to Auto Battle Arena!\n\nBuy heroes, place on grid,\nthen start the battle.\n\nMerge 3 same heroes â†’ higher tier!\n3 same type â†’ synergy bonus!',
    play: 'â–¶ï¸ Play',
    resume: 'â–¶ï¸ Resume',
    credits: 'ğŸ® By OpenClaw',
    interest: 'Interest',
    streak: 'Streak',
  }
};
function t(key) { return T[lang][key] || T['ko'][key] || key; }

// ---- HERO DEFINITIONS ----
const HERO_TYPES = ['warrior','archer','mage','healer','tank','assassin'];
const HERO_EMOJIS = {
  warrior: ['âš”ï¸','ğŸ—¡ï¸','ğŸ’ª'],
  archer: ['ğŸ¹','ğŸ¯','ğŸ¦…'],
  mage: ['ğŸ”®','âœ¨','ğŸŒŸ'],
  healer: ['ğŸ’š','ğŸŒ¿','ğŸŒ¸'],
  tank: ['ğŸ›¡ï¸','ğŸ°','ğŸ—¿'],
  assassin: ['ğŸ—¡ï¸','ğŸ’¨','â˜ ï¸']
};
const HERO_COLORS = {
  warrior: '#e74c3c',
  archer: '#27ae60',
  mage: '#8e44ad',
  healer: '#2ecc71',
  tank: '#3498db',
  assassin: '#e67e22'
};
const SYNERGY_ICONS = {
  warrior: 'âš”ï¸', archer: 'ğŸ¹', mage: 'ğŸ”®',
  healer: 'ğŸ’š', tank: 'ğŸ›¡ï¸', assassin: 'ğŸ—¡ï¸'
};
const TIER_COLORS = ['#aaa','#4a9eff','#ff6ef0'];

// Base stats per type (tier 1). Each tier multiplies by 1.6
const BASE_STATS = {
  warrior:  {hp:120,atk:18,def:8,spd:1.0,range:1,mana:60,skillDmg:35,skillName:'ê°•íƒ€/Power Strike'},
  archer:   {hp:80,atk:22,def:4,spd:1.3,range:3,mana:50,skillDmg:30,skillName:'ì—°ì‚¬/Rapid Shot'},
  mage:     {hp:70,atk:28,def:3,spd:0.9,range:3,mana:70,skillDmg:50,skillName:'í™”ì—¼êµ¬/Fireball'},
  healer:   {hp:85,atk:10,def:5,spd:1.0,range:2,mana:55,skillDmg:-40,skillName:'ì¹˜ìœ /Heal'},
  tank:     {hp:200,atk:10,def:15,spd:0.7,range:1,mana:80,skillDmg:0,skillName:'ë„ë°œ/Taunt'},
  assassin: {hp:65,atk:30,def:3,spd:1.6,range:1,mana:40,skillDmg:45,skillName:'ì•”ìŠµ/Ambush'}
};

const HERO_NAMES = {
  warrior:  [['ì² ìˆ˜','Ironhand'],['ê°•ì² ','Steelfist'],['ì²œë‘¥','Thunderlord']],
  archer:   [['ì€í™”ì‚´','Silverbow'],['ë§¤ì˜ëˆˆ','Hawkeye'],['ë³„ê¶ìˆ˜','Starshot']],
  mage:     [['ë¶ˆê½ƒ','Flamecaster'],['ì„œë¦¬','Frostweave'],['ë²ˆê°œ','Stormmage']],
  healer:   [['ì†”ì','Leafsong'],['ë¹›ë‚˜ë˜','Lightwing'],['ë³„ë¹›','Starbloom']],
  tank:     [['ë°”ìœ„','Rockwall'],['ì„±ë²½','Fortress'],['ì‚°ë§¥','Mountain']],
  assassin: [['ê·¸ë¦¼ì','Shadow'],['ì¹¼ë°”ëŒ','Bladestorm'],['ë…ì‚¬','Viper']]
};

const HERO_COSTS = [2, 3, 5]; // cost per tier

// ---- ITEM DEFINITIONS ----
const ITEMS = [
  {id:'sword', name:'ë¶ˆê½ƒê²€/Flame Sword', emoji:'ğŸ—¡ï¸', stat:'atk', value:10, tier:1},
  {id:'shield', name:'ì² ë²½ë°©íŒ¨/Iron Shield', emoji:'ğŸ›¡ï¸', stat:'def', value:8, tier:1},
  {id:'boots', name:'ì§ˆí’ë¶€ì¸ /Wind Boots', emoji:'ğŸ‘¢', stat:'spd', value:0.3, tier:1},
  {id:'ring', name:'ìƒëª…ë°˜ì§€/Life Ring', emoji:'ğŸ’', stat:'hp', value:50, tier:1},
  {id:'crown', name:'ìš©ì™•ê´€/Dragon Crown', emoji:'ğŸ‘‘', stat:'atk', value:20, tier:2},
  {id:'armor', name:'ë¯¸ìŠ¤ë¦´ê°‘ì˜·/Mithril Armor', emoji:'ğŸ¥‹', stat:'def', value:15, tier:2},
  {id:'pendant', name:'ë§ˆë‚˜ëª©ê±¸ì´/Mana Pendant', emoji:'ğŸ“¿', stat:'mana', value:-20, tier:2},
  {id:'cape', name:'ì˜ì›…ë§í† /Hero Cape', emoji:'ğŸ¦¸', stat:'hp', value:100, tier:2},
  {id:'excalibur', name:'ì—‘ìŠ¤ì¹¼ë¦¬ë²„/Excalibur', emoji:'âš¡', stat:'atk', value:35, tier:3},
  {id:'aegis', name:'ì´ì§€ìŠ¤/Aegis', emoji:'ğŸ”±', stat:'def', value:25, tier:3},
];

// ---- SOUND ENGINE (Web Audio API) ----
let audioCtx = null;
function initAudio() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  if (audioCtx.state === 'suspended') audioCtx.resume();
}
function playSound(type) {
  if (!audioCtx) return;
  try {
    const now = audioCtx.currentTime;
    const g = audioCtx.createGain();
    g.connect(audioCtx.destination);
    g.gain.setValueAtTime(0.15, now);
    
    if (type === 'attack') {
      const o = audioCtx.createOscillator();
      o.type = 'sawtooth'; o.frequency.setValueAtTime(200, now);
      o.frequency.exponentialRampToValueAtTime(80, now + 0.1);
      g.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
      o.connect(g); o.start(now); o.stop(now + 0.15);
    } else if (type === 'skill') {
      const o = audioCtx.createOscillator();
      o.type = 'sine'; o.frequency.setValueAtTime(400, now);
      o.frequency.exponentialRampToValueAtTime(800, now + 0.15);
      o.frequency.exponentialRampToValueAtTime(200, now + 0.3);
      g.gain.setValueAtTime(0.2, now);
      g.gain.exponentialRampToValueAtTime(0.01, now + 0.35);
      o.connect(g); o.start(now); o.stop(now + 0.35);
    } else if (type === 'hit') {
      const bufferSize = audioCtx.sampleRate * 0.05;
      const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
      const noise = audioCtx.createBufferSource();
      noise.buffer = buffer;
      g.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
      noise.connect(g); noise.start(now); noise.stop(now + 0.08);
    } else if (type === 'victory') {
      [523,659,784,1047].forEach((f,i) => {
        const o = audioCtx.createOscillator();
        const gg = audioCtx.createGain();
        o.type = 'sine'; o.frequency.value = f;
        gg.gain.setValueAtTime(0.12, now + i*0.15);
        gg.gain.exponentialRampToValueAtTime(0.01, now + i*0.15 + 0.3);
        o.connect(gg); gg.connect(audioCtx.destination);
        o.start(now + i*0.15); o.stop(now + i*0.15 + 0.3);
      });
    } else if (type === 'defeat') {
      [400,300,200,150].forEach((f,i) => {
        const o = audioCtx.createOscillator();
        const gg = audioCtx.createGain();
        o.type = 'sawtooth'; o.frequency.value = f;
        gg.gain.setValueAtTime(0.1, now + i*0.2);
        gg.gain.exponentialRampToValueAtTime(0.01, now + i*0.2 + 0.3);
        o.connect(gg); gg.connect(audioCtx.destination);
        o.start(now + i*0.2); o.stop(now + i*0.2 + 0.35);
      });
    } else if (type === 'levelup' || type === 'merge') {
      [600,800,1000,1200].forEach((f,i) => {
        const o = audioCtx.createOscillator();
        const gg = audioCtx.createGain();
        o.type = 'triangle'; o.frequency.value = f;
        gg.gain.setValueAtTime(0.15, now + i*0.08);
        gg.gain.exponentialRampToValueAtTime(0.01, now + i*0.08 + 0.2);
        o.connect(gg); gg.connect(audioCtx.destination);
        o.start(now + i*0.08); o.stop(now + i*0.08 + 0.25);
      });
    } else if (type === 'buy') {
      const o = audioCtx.createOscillator();
      o.type = 'sine'; o.frequency.setValueAtTime(800, now);
      o.frequency.exponentialRampToValueAtTime(1200, now + 0.1);
      g.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
      o.connect(g); o.start(now); o.stop(now + 0.15);
    } else if (type === 'sell') {
      const o = audioCtx.createOscillator();
      o.type = 'sine'; o.frequency.setValueAtTime(1000, now);
      o.frequency.exponentialRampToValueAtTime(400, now + 0.15);
      g.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
      o.connect(g); o.start(now); o.stop(now + 0.2);
    } else if (type === 'click') {
      const o = audioCtx.createOscillator();
      o.type = 'sine'; o.frequency.value = 600;
      g.gain.setValueAtTime(0.08, now);
      g.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
      o.connect(g); o.start(now); o.stop(now + 0.05);
    } else if (type === 'heal') {
      const o = audioCtx.createOscillator();
      o.type = 'sine'; o.frequency.setValueAtTime(500, now);
      o.frequency.linearRampToValueAtTime(900, now + 0.3);
      g.gain.setValueAtTime(0.12, now);
      g.gain.exponentialRampToValueAtTime(0.01, now + 0.35);
      o.connect(g); o.start(now); o.stop(now + 0.35);
    } else if (type === 'crit') {
      const o = audioCtx.createOscillator();
      o.type = 'square'; o.frequency.setValueAtTime(300, now);
      o.frequency.exponentialRampToValueAtTime(100, now + 0.1);
      g.gain.setValueAtTime(0.2, now);
      g.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
      o.connect(g); o.start(now); o.stop(now + 0.15);
      // second hit
      const o2 = audioCtx.createOscillator();
      const g2 = audioCtx.createGain();
      o2.type = 'sawtooth'; o2.frequency.value = 150;
      g2.gain.setValueAtTime(0.15, now + 0.05);
      g2.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
      o2.connect(g2); g2.connect(audioCtx.destination);
      o2.start(now + 0.05); o2.stop(now + 0.2);
    }
  } catch(e) {}
}

// ---- PARTICLE SYSTEM ----
const particles = [];
function spawnParticles(x, y, color, count, opts={}) {
  for (let i = 0; i < count; i++) {
    particles.push({
      x, y,
      vx: (Math.random()-0.5) * (opts.spread||4),
      vy: (Math.random()-0.5) * (opts.spread||4) - (opts.upward||0),
      life: opts.life || (0.5 + Math.random()*0.5),
      maxLife: opts.life || (0.5 + Math.random()*0.5),
      size: opts.size || (2 + Math.random()*3),
      color: color,
      type: opts.type || 'circle',
      text: opts.text || null,
      gravity: opts.gravity || 0,
      shrink: opts.shrink !== undefined ? opts.shrink : true
    });
  }
}
function spawnText(x, y, text, color, size) {
  particles.push({
    x, y, vx: 0, vy: -1.5,
    life: 1.0, maxLife: 1.0,
    size: size || 14, color, type: 'text', text,
    gravity: 0, shrink: false
  });
}
function updateParticles(dt) {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx; p.y += p.vy;
    p.vy += p.gravity;
    p.life -= dt;
    if (p.life <= 0) particles.splice(i, 1);
  }
}
function drawParticles() {
  for (const p of particles) {
    const alpha = Math.max(0, p.life / p.maxLife);
    ctx.globalAlpha = alpha;
    if (p.type === 'text') {
      ctx.fillStyle = p.color;
      ctx.font = `bold ${p.size}px sans-serif`;
      ctx.textAlign = 'center';
      ctx.fillText(p.text, p.x, p.y);
    } else {
      const sz = p.shrink ? p.size * alpha : p.size;
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, sz, 0, Math.PI*2);
      ctx.fill();
    }
  }
  ctx.globalAlpha = 1;
}

// ---- SCREEN SHAKE ----
let shakeTime = 0, shakeIntensity = 0;
function triggerShake(intensity, duration) {
  shakeIntensity = intensity;
  shakeTime = duration;
}

// ---- GAME STATE ----
let game = {
  phase: 'menu', // menu, prepare, battle, shop, result, gameover
  round: 1,
  gold: 10,
  hp: MAX_HP,
  score: 0,
  winStreak: 0,
  loseStreak: 0,
  bench: [], // hero objects on bench
  grid: Array.from({length:GRID_ROWS}, ()=>Array(GRID_COLS).fill(null)),
  items: [], // inventory items
  shopOffers: [],
  battleUnits: [], // active battle units (both sides)
  battleTimer: 0,
  battleSpeed: 1,
  projectiles: [],
  selectedHero: null,
  dragHero: null,
  dragFrom: null, // {type:'bench'|'grid', index/row/col}
  dragX: 0, dragY: 0,
  transition: {active:false, alpha:0, target:1, callback:null},
  itemEquipMode: false,
  itemToEquip: null,
  stats: {heroesKilled:0, roundsWon:0, merges:0, itemsUsed:0},
};

// ---- HERO FACTORY ----
let heroIdCounter = 0;
function createHero(type, tier=0, nameIdx=null) {
  const idx = nameIdx !== null ? nameIdx : Math.floor(Math.random()*3);
  const base = BASE_STATS[type];
  const mult = Math.pow(1.6, tier);
  return {
    id: heroIdCounter++,
    type, tier, nameIdx: idx,
    name: HERO_NAMES[type][idx],
    emoji: HERO_EMOJIS[type][tier],
    hp: Math.floor(base.hp * mult),
    maxHp: Math.floor(base.hp * mult),
    atk: Math.floor(base.atk * mult),
    def: Math.floor(base.def * mult),
    spd: +(base.spd * (1 + tier*0.1)).toFixed(2),
    range: base.range,
    mana: 0,
    maxMana: Math.max(20, base.mana - tier*10),
    skillDmg: Math.floor(base.skillDmg * mult),
    skillName: base.skillName,
    cost: HERO_COSTS[tier],
    item: null,
    level: 1,
    exp: 0,
    // battle state
    bx: 0, by: 0, targetId: -1,
    attackTimer: 0, alive: true, team: 0,
    animState: 'idle', animTimer: 0,
    statusEffects: []
  };
}

function cloneHero(h) {
  return {...h, item: h.item ? {...h.item} : null, statusEffects: [...h.statusEffects]};
}

// ---- GRID LAYOUT ----
let gridOffsetX=0, gridOffsetY=0, cellSize=60;
let enemyGridOffsetY = 0;

function recalcLayout() {
  const w = C.width, h = C.height;
  cellSize = Math.min(Math.floor((w - 40) / GRID_COLS), Math.floor((h - 200) / (GRID_ROWS*2 + 2)));
  cellSize = Math.max(40, Math.min(70, cellSize));
  const gridW = GRID_COLS * cellSize;
  gridOffsetX = (w - gridW) / 2;
  gridOffsetY = h/2 + 10;
  enemyGridOffsetY = gridOffsetY - (GRID_ROWS+1)*cellSize;
}

function gridToScreen(col, row, isEnemy=false) {
  const baseY = isEnemy ? enemyGridOffsetY : gridOffsetY;
  return {
    x: gridOffsetX + col * cellSize + cellSize/2,
    y: baseY + row * cellSize + cellSize/2
  };
}

function screenToGrid(sx, sy) {
  const col = Math.floor((sx - gridOffsetX) / cellSize);
  const row = Math.floor((sy - gridOffsetY) / cellSize);
  if (col >= 0 && col < GRID_COLS && row >= 0 && row < GRID_ROWS) return {col,row};
  return null;
}

// ---- SHOP SYSTEM ----
function generateShop() {
  const offers = [];
  const maxTier = Math.min(2, Math.floor(game.round / 8));
  for (let i = 0; i < 3; i++) {
    const type = HERO_TYPES[Math.floor(Math.random()*HERO_TYPES.length)];
    let tier = 0;
    const r = Math.random();
    if (maxTier >= 2 && r < 0.1) tier = 2;
    else if (maxTier >= 1 && r < 0.35) tier = 1;
    offers.push(createHero(type, tier));
  }
  game.shopOffers = offers;
  renderShop();
}

function buyHero(index) {
  const hero = game.shopOffers[index];
  if (!hero) return;
  if (game.gold < hero.cost) { showToast(t('noGold')); return; }
  if (game.bench.length >= BENCH_SIZE) { showToast(t('benchFull')); return; }
  game.gold -= hero.cost;
  game.bench.push(hero);
  game.shopOffers[index] = null;
  playSound('buy');
  checkMerge(hero);
  updateUI();
  renderShop();
  renderBench();
}

function rerollShop() {
  if (game.gold < REROLL_COST) { showToast(t('noGold')); return; }
  game.gold -= REROLL_COST;
  playSound('click');
  generateShop();
  updateUI();
}

function sellHero(hero, fromBench, benchIdx) {
  const refund = Math.max(1, hero.cost);
  game.gold += refund;
  if (fromBench) {
    game.bench.splice(benchIdx, 1);
  }
  playSound('sell');
  spawnText(C.width/2, C.height/2, `+${refund}ğŸ’°`, '#ffd700', 18);
  updateUI();
  renderBench();
}

// ---- MERGE SYSTEM ----
function checkMerge(newHero) {
  if (newHero.tier >= 2) return; // max tier
  
  // Find all matching heroes (same type, tier, nameIdx)
  const matches = [];
  
  // Check bench
  game.bench.forEach((h,i) => {
    if (h && h.type === newHero.type && h.tier === newHero.tier && h.nameIdx === newHero.nameIdx) {
      matches.push({hero:h, source:'bench', index:i});
    }
  });
  
  // Check grid
  for (let r=0;r<GRID_ROWS;r++) for (let c=0;c<GRID_COLS;c++) {
    const h = game.grid[r][c];
    if (h && h.type === newHero.type && h.tier === newHero.tier && h.nameIdx === newHero.nameIdx) {
      matches.push({hero:h, source:'grid', row:r, col:c});
    }
  }
  
  if (matches.length >= 3) {
    // Merge! Remove 3 and create 1 higher tier
    const toRemove = matches.slice(0, 3);
    // Keep the best item
    let bestItem = null;
    toRemove.forEach(m => {
      if (m.hero.item) { bestItem = m.hero.item; }
    });
    
    // Remove from sources (reverse order for bench indices)
    const benchRemovals = toRemove.filter(m=>m.source==='bench').sort((a,b)=>b.index-a.index);
    const gridRemovals = toRemove.filter(m=>m.source==='grid');
    
    benchRemovals.forEach(m => game.bench.splice(m.index, 1));
    gridRemovals.forEach(m => { game.grid[m.row][m.col] = null; });
    
    // Create merged hero
    const merged = createHero(newHero.type, newHero.tier + 1, newHero.nameIdx);
    merged.item = bestItem;
    if (bestItem) applyItemStats(merged);
    
    game.bench.push(merged);
    game.stats.merges++;
    
    playSound('merge');
    showToast(t('merged') + ` ${merged.emoji} ${merged.name[lang==='ko'?0:1]} â­${merged.tier+1}`);
    
    // Particle burst
    spawnParticles(C.width/2, C.height/2, TIER_COLORS[merged.tier], 30, {spread:8, life:1, upward:2});
    
    // Check if the merged hero can merge again!
    setTimeout(() => checkMerge(merged), 100);
  }
}

// ---- ITEM SYSTEM ----
function dropItem(round) {
  const tier = round >= 20 ? 2 : (round >= 10 ? 1 : 0);
  const pool = ITEMS.filter(it => it.tier <= tier + 1);
  const item = {...pool[Math.floor(Math.random()*pool.length)]};
  game.items.push(item);
  playSound('levelup');
  showToast(`${t('itemDrop')} ${item.emoji} ${item.name.split('/')[lang==='ko'?0:1]}`);
}

function applyItemStats(hero) {
  if (!hero.item) return;
  // Items modify stats (already applied in base creation, we recalculate)
  const base = BASE_STATS[hero.type];
  const mult = Math.pow(1.6, hero.tier);
  hero.hp = Math.floor(base.hp * mult);
  hero.maxHp = hero.hp;
  hero.atk = Math.floor(base.atk * mult);
  hero.def = Math.floor(base.def * mult);
  hero.spd = +(base.spd * (1 + hero.tier*0.1)).toFixed(2);
  hero.maxMana = Math.max(20, base.mana - hero.tier*10);
  hero.skillDmg = Math.floor(base.skillDmg * mult);
  
  const item = hero.item;
  if (item.stat === 'hp') { hero.hp += item.value; hero.maxHp += item.value; }
  if (item.stat === 'atk') hero.atk += item.value;
  if (item.stat === 'def') hero.def += item.value;
  if (item.stat === 'spd') hero.spd += item.value;
  if (item.stat === 'mana') hero.maxMana = Math.max(10, hero.maxMana + item.value);
}

function equipItem(itemIdx, hero) {
  if (hero.item) {
    game.items.push(hero.item);
  }
  hero.item = game.items.splice(itemIdx, 1)[0];
  applyItemStats(hero);
  playSound('buy');
  game.stats.itemsUsed++;
  game.itemEquipMode = false;
  game.itemToEquip = null;
  updateUI();
  renderBench();
}

// ---- SYNERGY SYSTEM ----
function calculateSynergies() {
  const counts = {};
  HERO_TYPES.forEach(t => counts[t] = 0);
  
  for (let r=0;r<GRID_ROWS;r++) for (let c=0;c<GRID_COLS;c++) {
    const h = game.grid[r][c];
    if (h) counts[h.type]++;
  }
  
  const synergies = [];
  for (const type of HERO_TYPES) {
    if (counts[type] > 0) {
      synergies.push({
        type, count: counts[type],
        active: counts[type] >= 3,
        bonus: counts[type] >= 3 ? getSynergyBonus(type) : null
      });
    }
  }
  return synergies;
}

function getSynergyBonus(type) {
  switch(type) {
    case 'warrior': return {stat:'atk', value:8, desc:'ê³µê²©ë ¥+8/ATK+8'};
    case 'archer': return {stat:'spd', value:0.3, desc:'ì†ë„+0.3/SPD+0.3'};
    case 'mage': return {stat:'skillDmg', value:15, desc:'ìŠ¤í‚¬+15/Skill+15'};
    case 'healer': return {stat:'hp', value:40, desc:'ì²´ë ¥+40/HP+40'};
    case 'tank': return {stat:'def', value:10, desc:'ë°©ì–´+10/DEF+10'};
    case 'assassin': return {stat:'atk', value:12, desc:'ê³µê²©ë ¥+12/ATK+12'};
  }
}

function applySynergies(units) {
  const synergies = calculateSynergies();
  for (const syn of synergies) {
    if (!syn.active) continue;
    const bonus = syn.bonus;
    units.forEach(u => {
      if (u.team === 0 && u.type === syn.type) {
        if (bonus.stat === 'hp') { u.hp += bonus.value; u.maxHp += bonus.value; }
        else if (bonus.stat === 'atk') u.atk += bonus.value;
        else if (bonus.stat === 'def') u.def += bonus.value;
        else if (bonus.stat === 'spd') u.spd += bonus.value;
        else if (bonus.stat === 'skillDmg') u.skillDmg += bonus.value;
      }
    });
  }
  return synergies;
}

// ---- ENEMY GENERATION ----
function generateEnemies(round) {
  const enemies = [];
  const isBoss = round % BOSS_INTERVAL === 0;
  const baseCount = Math.min(GRID_COLS * GRID_ROWS, 2 + Math.floor(round / 2));
  const count = isBoss ? Math.min(6, baseCount) : baseCount;
  const maxTier = Math.min(2, Math.floor(round / 10));
  const statMult = 1 + (round - 1) * 0.12;
  
  for (let i = 0; i < count; i++) {
    const type = HERO_TYPES[Math.floor(Math.random()*HERO_TYPES.length)];
    let tier = 0;
    if (maxTier >= 2 && Math.random() < 0.15 * (round/30)) tier = 2;
    else if (maxTier >= 1 && Math.random() < 0.3) tier = 1;
    
    const enemy = createHero(type, tier);
    enemy.team = 1;
    enemy.hp = Math.floor(enemy.hp * statMult * (isBoss ? 1.5 : 1));
    enemy.maxHp = enemy.hp;
    enemy.atk = Math.floor(enemy.atk * statMult * (isBoss ? 1.3 : 1));
    enemy.def = Math.floor(enemy.def * statMult);
    
    // Position on enemy grid
    const col = i % GRID_COLS;
    const row = Math.floor(i / GRID_COLS);
    const pos = gridToScreen(col, row, true);
    enemy.bx = pos.x;
    enemy.by = pos.y;
    enemy.gridCol = col;
    enemy.gridRow = row;
    
    enemies.push(enemy);
  }
  
  return enemies;
}

// ---- BATTLE SYSTEM ----
function startBattle() {
  // Check if player has units on grid
  let hasUnit = false;
  for (let r=0;r<GRID_ROWS;r++) for (let c=0;c<GRID_COLS;c++) {
    if (game.grid[r][c]) hasUnit = true;
  }
  if (!hasUnit) {
    showToast(lang==='ko'?'ì˜ì›…ì„ ê·¸ë¦¬ë“œì— ë°°ì¹˜í•˜ì„¸ìš”!':'Place heroes on the grid!');
    return;
  }
  
  initAudio();
  game.phase = 'battle';
  game.battleUnits = [];
  game.projectiles = [];
  game.battleTimer = 0;
  
  // Place player units
  for (let r=0;r<GRID_ROWS;r++) for (let c=0;c<GRID_COLS;c++) {
    const h = game.grid[r][c];
    if (h) {
      const unit = cloneHero(h);
      unit.team = 0;
      unit.alive = true;
      unit.mana = 0;
      unit.attackTimer = 0;
      const pos = gridToScreen(c, r, false);
      unit.bx = pos.x;
      unit.by = pos.y;
      unit.gridCol = c;
      unit.gridRow = r;
      if (unit.item) applyItemStats(unit);
      game.battleUnits.push(unit);
    }
  }
  
  // Apply synergies
  const syn = applySynergies(game.battleUnits);
  
  // Generate enemies
  const enemies = generateEnemies(game.round);
  game.battleUnits.push(...enemies);
  
  const isBoss = game.round % BOSS_INTERVAL === 0;
  showPhaseBanner(isBoss ? t('bossRound') : `${t('round')} ${game.round} - ${t('battle')}`);
  
  document.getElementById('bottom-panel').style.display = 'none';
  document.getElementById('bench-panel').style.display = 'none';
  document.getElementById('phase-info').textContent = t('battle');
  document.getElementById('synergy-panel').style.display = 'none';
}

function updateBattle(dt) {
  if (game.phase !== 'battle') return;
  game.battleTimer += dt;
  
  const playerAlive = game.battleUnits.filter(u=>u.team===0&&u.alive);
  const enemyAlive = game.battleUnits.filter(u=>u.team===1&&u.alive);
  
  // Check end conditions
  if (enemyAlive.length === 0) {
    endBattle(true);
    return;
  }
  if (playerAlive.length === 0) {
    endBattle(false);
    return;
  }
  
  // Timeout after 30 seconds
  if (game.battleTimer > 30) {
    endBattle(false);
    return;
  }
  
  // Update each unit
  for (const unit of game.battleUnits) {
    if (!unit.alive) continue;
    
    // Find target (nearest enemy)
    const enemies = game.battleUnits.filter(u => u.team !== unit.team && u.alive);
    if (enemies.length === 0) continue;
    
    let nearest = null, minDist = Infinity;
    for (const e of enemies) {
      const d = Math.hypot(e.bx - unit.bx, e.by - unit.by);
      if (d < minDist) { minDist = d; nearest = e; }
    }
    
    if (!nearest) continue;
    unit.targetId = nearest.id;
    
    const attackRange = unit.range * cellSize * 0.9;
    
    // Move toward target if out of range
    if (minDist > attackRange) {
      const speed = unit.spd * 60 * dt;
      const dx = nearest.bx - unit.bx;
      const dy = nearest.by - unit.by;
      const len = Math.hypot(dx, dy);
      unit.bx += (dx/len) * speed;
      unit.by += (dy/len) * speed;
      unit.animState = 'move';
    } else {
      // Attack
      unit.attackTimer += dt * unit.spd;
      
      if (unit.attackTimer >= 1.0) {
        unit.attackTimer = 0;
        unit.animState = 'attack';
        unit.animTimer = 0.2;
        
        // Check skill
        if (unit.mana >= unit.maxMana) {
          unit.mana = 0;
          useSkill(unit, nearest, enemies);
        } else {
          // Normal attack
          performAttack(unit, nearest);
          unit.mana += 10;
        }
      }
    }
    
    // Taunt: tanks pull aggro
    for (const su of unit.statusEffects) {
      if (su.type === 'taunt' && su.timer > 0) {
        su.timer -= dt;
        const taunter = game.battleUnits.find(u=>u.id===su.source&&u.alive);
        if (taunter) unit.targetId = taunter.id;
      }
    }
    unit.statusEffects = unit.statusEffects.filter(s => s.timer > 0);
    
    // Animation timer
    if (unit.animTimer > 0) {
      unit.animTimer -= dt;
      if (unit.animTimer <= 0) unit.animState = 'idle';
    }
  }
  
  // Update projectiles
  for (let i = game.projectiles.length-1; i >= 0; i--) {
    const p = game.projectiles[i];
    const target = game.battleUnits.find(u=>u.id===p.targetId);
    if (!target || !target.alive) { game.projectiles.splice(i,1); continue; }
    
    const dx = target.bx - p.x;
    const dy = target.by - p.y;
    const dist = Math.hypot(dx,dy);
    
    if (dist < 10) {
      // Hit
      dealDamage(p.source, target, p.damage, p.isSkill);
      game.projectiles.splice(i,1);
    } else {
      const spd = 300 * dt;
      p.x += (dx/dist)*spd;
      p.y += (dy/dist)*spd;
    }
  }
}

function performAttack(attacker, target) {
  if (attacker.range > 1) {
    // Ranged: shoot projectile
    game.projectiles.push({
      x: attacker.bx, y: attacker.by,
      targetId: target.id,
      damage: attacker.atk,
      source: attacker,
      isSkill: false,
      color: HERO_COLORS[attacker.type],
      emoji: attacker.type==='archer'?'ğŸ¹':(attacker.type==='mage'?'âœ¨':'ğŸ’«')
    });
    playSound('attack');
  } else {
    // Melee: instant hit
    dealDamage(attacker, target, attacker.atk, false);
    playSound('attack');
  }
}

function dealDamage(attacker, target, rawDmg, isSkill) {
  const dmgReduction = target.def / (target.def + 50);
  let damage = Math.max(1, Math.floor(rawDmg * (1 - dmgReduction)));
  
  // Critical hit (10% chance, 1.5x)
  const isCrit = Math.random() < 0.1;
  if (isCrit) {
    damage = Math.floor(damage * 1.5);
    playSound('crit');
    triggerShake(6, 0.15);
    spawnText(target.bx, target.by - 20, `ğŸ’¥${damage}`, '#ff4444', 16);
  } else {
    spawnText(target.bx, target.by - 15, `-${damage}`, '#ff8888', 12);
  }
  
  target.hp -= damage;
  spawnParticles(target.bx, target.by, HERO_COLORS[attacker.type], isCrit?8:3, {spread:3});
  
  if (isSkill) playSound('skill');
  else playSound('hit');
  
  if (target.hp <= 0) {
    target.hp = 0;
    target.alive = false;
    target.animState = 'dead';
    spawnParticles(target.bx, target.by, '#ffffff', 15, {spread:5, life:0.8});
    spawnText(target.bx, target.by - 30, 'ğŸ’€', '#ff0000', 20);
    if (target.team === 1) game.stats.heroesKilled++;
  }
}

function useSkill(unit, target, allEnemies) {
  playSound('skill');
  unit.animState = 'skill';
  unit.animTimer = 0.4;
  
  spawnParticles(unit.bx, unit.by, TIER_COLORS[unit.tier], 12, {spread:5, life:0.6, upward:1});
  
  switch(unit.type) {
    case 'warrior': // Power Strike - high single damage
      if (unit.range > 1) {
        game.projectiles.push({x:unit.bx, y:unit.by, targetId:target.id, damage:unit.atk+unit.skillDmg, source:unit, isSkill:true, color:'#ff4444', emoji:'âš”ï¸'});
      } else {
        dealDamage(unit, target, unit.atk + unit.skillDmg, true);
      }
      break;
      
    case 'archer': // Rapid Shot - 3 quick attacks
      for (let i=0; i<3; i++) {
        const tgt = allEnemies[Math.floor(Math.random()*allEnemies.length)];
        setTimeout(()=>{
          if (tgt && tgt.alive) {
            game.projectiles.push({x:unit.bx, y:unit.by, targetId:tgt.id, damage:unit.atk+Math.floor(unit.skillDmg/3), source:unit, isSkill:true, color:'#00ff44', emoji:'ğŸ¹'});
          }
        }, i*100);
      }
      break;
      
    case 'mage': // Fireball - AoE
      spawnParticles(target.bx, target.by, '#ff6600', 20, {spread:8, life:0.8});
      allEnemies.forEach(e => {
        if (Math.hypot(e.bx-target.bx, e.by-target.by) < cellSize*1.5) {
          dealDamage(unit, e, unit.skillDmg, true);
        }
      });
      break;
      
    case 'healer': // Heal - heal lowest HP ally
      const allies = game.battleUnits.filter(u=>u.team===unit.team&&u.alive&&u.id!==unit.id);
      let lowest = null, lowestPct = 1;
      allies.forEach(a => {
        const pct = a.hp/a.maxHp;
        if (pct < lowestPct) { lowestPct = pct; lowest = a; }
      });
      if (lowest) {
        const heal = Math.abs(unit.skillDmg);
        lowest.hp = Math.min(lowest.maxHp, lowest.hp + heal);
        spawnText(lowest.bx, lowest.by - 15, `+${heal}`, '#00ff00', 14);
        spawnParticles(lowest.bx, lowest.by, '#00ff00', 8, {spread:3, upward:1});
        playSound('heal');
      } else {
        // Heal self
        const heal = Math.abs(unit.skillDmg);
        unit.hp = Math.min(unit.maxHp, unit.hp + heal);
        spawnText(unit.bx, unit.by - 15, `+${heal}`, '#00ff00', 14);
        playSound('heal');
      }
      break;
      
    case 'tank': // Taunt - force enemies to target this tank
      allEnemies.forEach(e => {
        e.statusEffects.push({type:'taunt', source:unit.id, timer:3});
      });
      spawnParticles(unit.bx, unit.by, '#3498db', 15, {spread:6, life:0.8});
      unit.def += 5; // temp def boost
      break;
      
    case 'assassin': // Ambush - teleport to weakest and backstab
      let weakest = null, weakestHp = Infinity;
      allEnemies.forEach(e => { if (e.hp < weakestHp) { weakestHp = e.hp; weakest = e; }});
      if (weakest) {
        unit.bx = weakest.bx + 15;
        unit.by = weakest.by;
        spawnParticles(unit.bx, unit.by, '#e67e22', 10, {spread:4});
        dealDamage(unit, weakest, unit.atk + unit.skillDmg, true);
      }
      break;
  }
}

function endBattle(won) {
  if (won) {
    playSound('victory');
    game.winStreak++;
    game.loseStreak = 0;
    game.stats.roundsWon++;
    
    // Gold rewards
    let goldEarned = BASE_GOLD_PER_ROUND;
    const interest = Math.min(5, Math.floor(game.gold * INTEREST_RATE));
    goldEarned += interest;
    if (game.winStreak >= 3) goldEarned += Math.min(3, Math.floor(game.winStreak / 2));
    
    game.gold += goldEarned;
    game.score += game.round * 10 + goldEarned;
    
    showPhaseBanner(t('victory') + ` +${goldEarned}ğŸ’°`);
    spawnParticles(C.width/2, C.height/2, '#ffd700', 40, {spread:10, life:1.5, upward:2});
    
    // Boss drops item
    if (game.round % BOSS_INTERVAL === 0) {
      setTimeout(() => dropItem(game.round), 500);
    }
    
    // Give EXP to surviving grid heroes
    for (let r=0;r<GRID_ROWS;r++) for (let c=0;c<GRID_COLS;c++) {
      const h = game.grid[r][c];
      if (h) {
        h.exp += 10 + game.round;
        if (h.exp >= h.level * 20) {
          h.exp = 0;
          h.level++;
          h.atk += 2;
          h.hp += 10;
          h.maxHp += 10;
          h.def += 1;
          spawnText(C.width/2, C.height/2 + 30, `${h.emoji} Level Up!`, '#ffff00', 14);
          playSound('levelup');
        }
      }
    }
    
  } else {
    playSound('defeat');
    game.loseStreak++;
    game.winStreak = 0;
    
    // Lose HP based on remaining enemies
    const remaining = game.battleUnits.filter(u=>u.team===1&&u.alive);
    const dmg = Math.max(2, remaining.length * 2 + game.round);
    game.hp -= dmg;
    
    let goldEarned = BASE_GOLD_PER_ROUND;
    if (game.loseStreak >= 3) goldEarned += Math.min(3, Math.floor(game.loseStreak / 2));
    game.gold += goldEarned;
    
    showPhaseBanner(t('defeat') + ` -${dmg}â¤ï¸`);
    triggerShake(10, 0.3);
  }
  
  setTimeout(() => {
    if (game.hp <= 0) {
      game.phase = 'gameover';
      showGameOver();
    } else {
      game.round++;
      game.phase = 'prepare';
      generateShop();
      document.getElementById('bottom-panel').style.display = 'block';
      document.getElementById('bench-panel').style.display = 'block';
      document.getElementById('phase-info').textContent = t('prepare');
      updateSynergyPanel();
      updateUI();
      renderBench();
    }
  }, 1500);
}

// ---- DRAWING ----
function drawGrid(isEnemy=false) {
  const baseY = isEnemy ? enemyGridOffsetY : gridOffsetY;
  
  for (let r=0;r<GRID_ROWS;r++) for (let c=0;c<GRID_COLS;c++) {
    const x = gridOffsetX + c*cellSize;
    const y = baseY + r*cellSize;
    
    ctx.strokeStyle = isEnemy ? 'rgba(255,80,80,0.3)' : 'rgba(100,150,255,0.3)';
    ctx.lineWidth = 1;
    ctx.strokeRect(x+1, y+1, cellSize-2, cellSize-2);
    
    // Slight fill
    ctx.fillStyle = isEnemy ? 'rgba(255,50,50,0.05)' : 'rgba(50,100,255,0.05)';
    ctx.fillRect(x+1, y+1, cellSize-2, cellSize-2);
    
    // Draw placed heroes (only during prepare phase)
    if (!isEnemy && game.phase === 'prepare') {
      const hero = game.grid[r][c];
      if (hero && !(game.dragHero && game.dragFrom && game.dragFrom.type==='grid' && game.dragFrom.row===r && game.dragFrom.col===c)) {
        drawHeroOnGrid(hero, x + cellSize/2, y + cellSize/2);
      }
    }
  }
  
  // Label
  ctx.fillStyle = isEnemy ? 'rgba(255,100,100,0.6)' : 'rgba(100,150,255,0.6)';
  ctx.font = '10px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText(isEnemy ? (lang==='ko'?'ì  ì§„ì˜':'Enemy') : (lang==='ko'?'ì•„êµ° ì§„ì˜':'Your Side'),
    gridOffsetX + GRID_COLS*cellSize/2, baseY - 5);
}

function drawHeroOnGrid(hero, x, y) {
  // Background circle
  const tierColor = TIER_COLORS[hero.tier];
  ctx.fillStyle = tierColor + '33';
  ctx.beginPath();
  ctx.arc(x, y, cellSize/2 - 4, 0, Math.PI*2);
  ctx.fill();
  ctx.strokeStyle = tierColor;
  ctx.lineWidth = 2;
  ctx.stroke();
  
  // Emoji
  ctx.font = `${cellSize*0.5}px sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(hero.emoji, x, y - 2);
  
  // Tier stars
  const stars = 'â­'.repeat(hero.tier + 1);
  ctx.font = `${Math.max(8, cellSize*0.15)}px sans-serif`;
  ctx.fillText(stars, x, y + cellSize/2 - 10);
  
  // Item indicator
  if (hero.item) {
    ctx.font = `${cellSize*0.2}px sans-serif`;
    ctx.fillText(hero.item.emoji, x + cellSize/2 - 10, y - cellSize/2 + 10);
  }
  
  // Level
  if (hero.level > 1) {
    ctx.font = 'bold 9px sans-serif';
    ctx.fillStyle = '#ffff00';
    ctx.fillText(`Lv${hero.level}`, x, y + cellSize/2 - 2);
  }
}

function drawBattleUnit(unit) {
  if (!unit.alive) return;
  
  const x = unit.bx, y = unit.by;
  const size = cellSize * 0.45;
  
  // Animation offset
  let ox = 0, oy = 0;
  if (unit.animState === 'attack') {
    ox = (Math.random()-0.5)*4;
    oy = (Math.random()-0.5)*4;
  }
  if (unit.animState === 'skill') {
    const glow = Math.sin(unit.animTimer * 20) * 0.3 + 0.7;
    ctx.shadowColor = TIER_COLORS[unit.tier];
    ctx.shadowBlur = 15 * glow;
  }
  
  // Team indicator ring
  ctx.strokeStyle = unit.team === 0 ? '#4488ff' : '#ff4444';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(x+ox, y+oy, size+2, 0, Math.PI*2);
  ctx.stroke();
  
  // Body
  const tierColor = TIER_COLORS[unit.tier];
  ctx.fillStyle = tierColor + '44';
  ctx.beginPath();
  ctx.arc(x+ox, y+oy, size, 0, Math.PI*2);
  ctx.fill();
  
  // Emoji
  ctx.font = `${size*1.2}px sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(unit.emoji, x+ox, y+oy-2);
  
  ctx.shadowBlur = 0;
  
  // HP bar
  const barW = size*2;
  const barH = 4;
  const barX = x - barW/2;
  const barY = y + size + 4;
  const hpPct = Math.max(0, unit.hp/unit.maxHp);
  
  ctx.fillStyle = '#333';
  ctx.fillRect(barX, barY, barW, barH);
  ctx.fillStyle = hpPct > 0.5 ? '#00cc44' : (hpPct > 0.25 ? '#cccc00' : '#cc0000');
  ctx.fillRect(barX, barY, barW*hpPct, barH);
  
  // Mana bar
  const manaPct = unit.mana / unit.maxMana;
  ctx.fillStyle = '#222';
  ctx.fillRect(barX, barY + barH + 1, barW, 2);
  ctx.fillStyle = '#4488ff';
  ctx.fillRect(barX, barY + barH + 1, barW*manaPct, 2);
  
  // Tier stars
  ctx.font = `${Math.max(6,size*0.3)}px sans-serif`;
  ctx.fillText('â­'.repeat(unit.tier+1), x, barY + barH + 10);
  
  // Item
  if (unit.item) {
    ctx.font = `${size*0.4}px sans-serif`;
    ctx.fillText(unit.item.emoji, x+size, y-size);
  }
}

function drawProjectiles() {
  for (const p of game.projectiles) {
    ctx.font = '14px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(p.emoji, p.x, p.y);
    
    // Trail
    spawnParticles(p.x, p.y, p.color, 1, {spread:1, life:0.2, size:2});
  }
}

function drawBackground() {
  // Dark arena background
  const gradient = ctx.createLinearGradient(0, 0, 0, C.height);
  gradient.addColorStop(0, '#0a0a1a');
  gradient.addColorStop(0.5, '#0e1025');
  gradient.addColorStop(1, '#0a0a1a');
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, C.width, C.height);
  
  // Grid lines pattern
  ctx.strokeStyle = 'rgba(50,50,80,0.1)';
  ctx.lineWidth = 1;
  for (let x = 0; x < C.width; x += 30) {
    ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,C.height); ctx.stroke();
  }
  for (let y = 0; y < C.height; y += 30) {
    ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(C.width,y); ctx.stroke();
  }
  
  // Divider line
  const midY = (gridOffsetY + enemyGridOffsetY + GRID_ROWS*cellSize) / 2;
  ctx.strokeStyle = 'rgba(255,255,255,0.15)';
  ctx.setLineDash([5,5]);
  ctx.beginPath();
  ctx.moveTo(gridOffsetX, midY);
  ctx.lineTo(gridOffsetX + GRID_COLS*cellSize, midY);
  ctx.stroke();
  ctx.setLineDash([]);
}

// ---- DRAG & DROP ----
let touchId = null;

function getEventPos(e) {
  if (e.touches) {
    const t = e.touches[0] || e.changedTouches[0];
    return {x: t.clientX * dpr, y: t.clientY * dpr};
  }
  return {x: e.clientX * dpr, y: e.clientY * dpr};
}

function findBenchHeroAt(x, y) {
  const benchPanel = document.getElementById('bench-panel');
  if (benchPanel.style.display === 'none') return -1;
  const slots = document.querySelectorAll('.bench-slot');
  for (let i = 0; i < slots.length; i++) {
    const rect = slots[i].getBoundingClientRect();
    if (x/dpr >= rect.left && x/dpr <= rect.right && y/dpr >= rect.top && y/dpr <= rect.bottom) {
      return i;
    }
  }
  return -1;
}

function findGridHeroAt(x, y) {
  const cell = screenToGrid(x, y);
  if (cell && game.grid[cell.row][cell.col]) {
    return cell;
  }
  return null;
}

function onPointerDown(e) {
  if (game.phase !== 'prepare') return;
  initAudio();
  const pos = getEventPos(e);
  
  // Check item equip mode
  if (game.itemEquipMode) {
    const cell = screenToGrid(pos.x, pos.y);
    if (cell && game.grid[cell.row][cell.col]) {
      equipItem(game.itemToEquip, game.grid[cell.row][cell.col]);
    }
    const benchIdx = findBenchHeroAt(pos.x, pos.y);
    if (benchIdx >= 0 && benchIdx < game.bench.length) {
      equipItem(game.itemToEquip, game.bench[benchIdx]);
    }
    game.itemEquipMode = false;
    return;
  }
  
  // Check grid hero
  const cell = screenToGrid(pos.x, pos.y);
  if (cell && game.grid[cell.row][cell.col]) {
    game.dragHero = game.grid[cell.row][cell.col];
    game.dragFrom = {type:'grid', row:cell.row, col:cell.col};
    game.dragX = pos.x;
    game.dragY = pos.y;
    return;
  }
  
  // Check bench hero
  const benchIdx = findBenchHeroAt(pos.x, pos.y);
  if (benchIdx >= 0 && benchIdx < game.bench.length) {
    game.dragHero = game.bench[benchIdx];
    game.dragFrom = {type:'bench', index:benchIdx};
    game.dragX = pos.x;
    game.dragY = pos.y;
    return;
  }
}

function onPointerMove(e) {
  if (!game.dragHero) return;
  e.preventDefault();
  const pos = getEventPos(e);
  game.dragX = pos.x;
  game.dragY = pos.y;
}

function onPointerUp(e) {
  if (!game.dragHero) return;
  const pos = getEventPos(e);
  const cell = screenToGrid(pos.x, pos.y);
  
  if (cell) {
    const existing = game.grid[cell.row][cell.col];
    
    if (game.dragFrom.type === 'bench') {
      if (existing) {
        // Swap: put existing to bench
        game.bench[game.dragFrom.index] = existing;
      } else {
        game.bench.splice(game.dragFrom.index, 1);
      }
      game.grid[cell.row][cell.col] = game.dragHero;
    } else if (game.dragFrom.type === 'grid') {
      if (existing && !(game.dragFrom.row===cell.row && game.dragFrom.col===cell.col)) {
        // Swap grid positions
        game.grid[game.dragFrom.row][game.dragFrom.col] = existing;
      } else {
        game.grid[game.dragFrom.row][game.dragFrom.col] = null;
      }
      game.grid[cell.row][cell.col] = game.dragHero;
    }
    playSound('click');
  } else {
    // Dropped outside grid
    if (game.dragFrom.type === 'grid') {
      // Return to bench
      if (game.bench.length < BENCH_SIZE) {
        game.grid[game.dragFrom.row][game.dragFrom.col] = null;
        game.bench.push(game.dragHero);
        playSound('click');
      }
    } else if (game.dragFrom.type === 'bench') {
      // Check if dropped far enough to sell
      const benchPanel = document.getElementById('bench-panel');
      const benchRect = benchPanel.getBoundingClientRect();
      if (pos.y/dpr < benchRect.top - 30) {
        // Sell
        sellHero(game.dragHero, true, game.dragFrom.index);
      }
    }
  }
  
  game.dragHero = null;
  game.dragFrom = null;
  updateSynergyPanel();
  updateUI();
  renderBench();
}

// ---- UI RENDERING ----
function updateUI() {
  document.getElementById('round-info').textContent = `ğŸŸï¸ R${game.round}`;
  document.getElementById('gold-info').textContent = `ğŸ’° ${game.gold}`;
  document.getElementById('hp-info').textContent = `â¤ï¸ ${game.hp}`;
  document.getElementById('reroll-btn').textContent = `${t('reroll')} (${REROLL_COST}ğŸ’°)`;
  document.getElementById('battle-btn').textContent = t('startBattle');
}

function renderShop() {
  const panel = document.getElementById('shop-panel');
  panel.innerHTML = '';
  game.shopOffers.forEach((hero, i) => {
    if (!hero) {
      const card = document.createElement('div');
      card.className = 'shop-card';
      card.style.opacity = '0.3';
      card.innerHTML = '<div style="font-size:24px;color:#555">âœ“</div><div style="font-size:10px;color:#555">'+(lang==='ko'?'íŒë§¤ì™„ë£Œ':'Sold')+'</div>';
      panel.appendChild(card);
      return;
    }
    const card = document.createElement('div');
    card.className = `shop-card tier-${hero.tier+1}`;
    const name = hero.name[lang==='ko'?0:1];
    const typeName = t(hero.type);
    card.innerHTML = `
      <div class="hero-icon">${hero.emoji}</div>
      <div class="hero-name">${name}</div>
      <div class="hero-type">${typeName} ${'â­'.repeat(hero.tier+1)}</div>
      <div style="font-size:9px;color:#aaa">HP:${hero.hp} ATK:${hero.atk} DEF:${hero.def}</div>
      <div class="hero-cost">${hero.cost}ğŸ’°</div>
    `;
    card.onclick = () => buyHero(i);
    panel.appendChild(card);
  });
}

function renderBench() {
  const container = document.getElementById('bench-slots');
  container.innerHTML = '';
  for (let i = 0; i < BENCH_SIZE; i++) {
    const slot = document.createElement('div');
    slot.className = 'bench-slot';
    if (i < game.bench.length) {
      const hero = game.bench[i];
      slot.style.borderColor = TIER_COLORS[hero.tier];
      slot.style.borderStyle = 'solid';
      slot.style.background = TIER_COLORS[hero.tier] + '22';
      slot.innerHTML = hero.emoji;
      slot.title = `${hero.name[lang==='ko'?0:1]} (${t(hero.type)}) â­${hero.tier+1}`;
      
      // Tier badge
      const badge = document.createElement('div');
      badge.className = 'tier-badge';
      badge.style.background = TIER_COLORS[hero.tier];
      badge.textContent = hero.tier+1;
      slot.appendChild(badge);
      
      if (hero.item) {
        const itemBadge = document.createElement('div');
        itemBadge.style.cssText = 'position:absolute;bottom:-2px;right:-2px;font-size:12px';
        itemBadge.textContent = hero.item.emoji;
        slot.appendChild(itemBadge);
      }
    }
    container.appendChild(slot);
  }
  
  renderItemPanel();
}

function renderItemPanel() {
  const panel = document.getElementById('item-panel');
  if (game.items.length === 0) {
    panel.style.display = 'none';
    return;
  }
  panel.style.display = 'block';
  panel.innerHTML = `<div style="font-size:11px;color:#aaa;margin-bottom:4px">${t('equipment')} (${game.items.length})</div>`;
  game.items.forEach((item, i) => {
    const slot = document.createElement('div');
    slot.className = 'item-slot';
    slot.title = item.name.split('/')[lang==='ko'?0:1];
    slot.textContent = item.emoji;
    slot.onclick = () => {
      game.itemEquipMode = true;
      game.itemToEquip = i;
      showToast(t('selectTarget'));
    };
    panel.appendChild(slot);
  });
}

function updateSynergyPanel() {
  const panel = document.getElementById('synergy-panel');
  const synergies = calculateSynergies();
  if (synergies.length === 0) {
    panel.style.display = 'none';
    return;
  }
  panel.style.display = 'block';
  panel.innerHTML = '<div style="font-size:11px;color:#aaa;margin-bottom:4px">' + (lang==='ko'?'ì‹œë„ˆì§€':'Synergy') + '</div>';
  synergies.forEach(s => {
    const row = document.createElement('div');
    row.className = `synergy-row ${s.active ? 'synergy-active' : 'synergy-inactive'}`;
    const bonusText = s.active ? ` (${s.bonus.desc.split('/')[lang==='ko'?0:1]})` : '';
    row.innerHTML = `${SYNERGY_ICONS[s.type]} ${t(s.type)}: ${s.count}/3 ${s.active?'âœ…':''}${bonusText}`;
    panel.appendChild(row);
  });
}

function showToast(msg) {
  const toast = document.getElementById('toast');
  toast.textContent = msg;
  toast.style.opacity = '1';
  clearTimeout(toast._timer);
  toast._timer = setTimeout(() => toast.style.opacity = '0', 2000);
}

function showPhaseBanner(text) {
  const banner = document.getElementById('phase-banner');
  banner.textContent = text;
  banner.style.opacity = '1';
  setTimeout(() => banner.style.opacity = '0', 1500);
}

function showModal(title, body, buttons) {
  document.getElementById('modal-title').textContent = title;
  document.getElementById('modal-body').innerHTML = body.replace(/\n/g,'<br>');
  const btnContainer = document.getElementById('modal-buttons');
  btnContainer.innerHTML = '';
  buttons.forEach(b => {
    const btn = document.createElement('button');
    btn.className = `btn ${b.cls||''}`;
    btn.textContent = b.text;
    btn.onclick = () => {
      document.getElementById('modal-overlay').style.display = 'none';
      if (b.action) b.action();
    };
    btnContainer.appendChild(btn);
  });
  document.getElementById('modal-overlay').style.display = 'flex';
}

function showGameOver() {
  const msg = t('gameOverMsg').replace('{r}', game.round).replace('{s}', game.score);
  showModal(t('gameOver'), msg + `\n\nğŸ—¡ï¸ ${game.stats.heroesKilled} ${lang==='ko'?'ì²˜ì¹˜':'Kills'}\nğŸ”„ ${game.stats.merges} ${lang==='ko'?'í•©ì„±':'Merges'}\nğŸ† ${game.stats.roundsWon} ${lang==='ko'?'ìŠ¹ë¦¬':'Wins'}`, [
    {text: t('newGame'), cls:'btn-green', action: newGame},
  ]);
}

function showWelcome() {
  const hasSave = !!localStorage.getItem('autobattle_save');
  const buttons = [
    {text: t('play'), cls:'btn-green', action: () => { newGame(); }},
  ];
  if (hasSave) {
    buttons.unshift({text: t('resume'), cls:'btn-gold', action: loadGame});
  }
  showModal(t('title'), t('welcome'), buttons);
}

// ---- SAVE/LOAD ----
function saveGame() {
  const saveData = {
    round: game.round, gold: game.gold, hp: game.hp, score: game.score,
    winStreak: game.winStreak, loseStreak: game.loseStreak,
    bench: game.bench.map(serializeHero),
    grid: game.grid.map(row => row.map(h => h ? serializeHero(h) : null)),
    items: game.items,
    stats: game.stats,
    lang: lang,
  };
  localStorage.setItem('autobattle_save', JSON.stringify(saveData));
  showToast(t('saved'));
  playSound('click');
}

function loadGame() {
  const data = localStorage.getItem('autobattle_save');
  if (!data) { showToast(t('noSave')); return; }
  
  try {
    const save = JSON.parse(data);
    game.round = save.round;
    game.gold = save.gold;
    game.hp = save.hp;
    game.score = save.score || 0;
    game.winStreak = save.winStreak || 0;
    game.loseStreak = save.loseStreak || 0;
    game.bench = (save.bench || []).map(deserializeHero);
    game.grid = (save.grid || []).map(row => row.map(h => h ? deserializeHero(h) : null));
    game.items = save.items || [];
    game.stats = save.stats || {heroesKilled:0,roundsWon:0,merges:0,itemsUsed:0};
    lang = save.lang || 'ko';
    
    game.phase = 'prepare';
    generateShop();
    document.getElementById('bottom-panel').style.display = 'block';
    document.getElementById('bench-panel').style.display = 'block';
    document.getElementById('phase-info').textContent = t('prepare');
    updateSynergyPanel();
    updateUI();
    renderBench();
    showToast(t('loaded'));
  } catch(e) {
    showToast('Error loading save');
  }
}

function serializeHero(h) {
  return {
    type:h.type, tier:h.tier, nameIdx:h.nameIdx, level:h.level, exp:h.exp,
    item: h.item ? {id:h.item.id, name:h.item.name, emoji:h.item.emoji, stat:h.item.stat, value:h.item.value, tier:h.item.tier} : null
  };
}

function deserializeHero(d) {
  const h = createHero(d.type, d.tier, d.nameIdx);
  h.level = d.level || 1;
  h.exp = d.exp || 0;
  // Apply level bonuses
  for (let i = 1; i < h.level; i++) {
    h.atk += 2; h.hp += 10; h.maxHp += 10; h.def += 1;
  }
  if (d.item) {
    h.item = d.item;
    applyItemStats(h);
  }
  return h;
}

// ---- NEW GAME ----
function newGame() {
  heroIdCounter = 0;
  game.phase = 'prepare';
  game.round = 1;
  game.gold = 10;
  game.hp = MAX_HP;
  game.score = 0;
  game.winStreak = 0;
  game.loseStreak = 0;
  game.bench = [];
  game.grid = Array.from({length:GRID_ROWS}, ()=>Array(GRID_COLS).fill(null));
  game.items = [];
  game.battleUnits = [];
  game.projectiles = [];
  game.dragHero = null;
  game.dragFrom = null;
  game.stats = {heroesKilled:0,roundsWon:0,merges:0,itemsUsed:0};
  
  generateShop();
  document.getElementById('bottom-panel').style.display = 'block';
  document.getElementById('bench-panel').style.display = 'block';
  document.getElementById('phase-info').textContent = t('prepare');
  updateSynergyPanel();
  updateUI();
  renderBench();
}

// ---- RESIZE ----
let dpr = 1;
function resize() {
  dpr = window.devicePixelRatio || 1;
  C.width = window.innerWidth * dpr;
  C.height = window.innerHeight * dpr;
  C.style.width = window.innerWidth + 'px';
  C.style.height = window.innerHeight + 'px';
  ctx.setTransform(1,0,0,1,0,0);
  recalcLayout();
}

// ---- MAIN LOOP ----
let lastTime = 0;
function gameLoop(timestamp) {
  const dt = Math.min(0.05, (timestamp - lastTime) / 1000);
  lastTime = timestamp;
  
  // Screen shake
  if (shakeTime > 0) {
    shakeTime -= dt;
    ctx.save();
    ctx.translate(
      (Math.random()-0.5)*shakeIntensity*2,
      (Math.random()-0.5)*shakeIntensity*2
    );
  }
  
  // Clear & draw background
  drawBackground();
  
  if (game.phase === 'prepare' || game.phase === 'shop') {
    drawGrid(false);
    drawGrid(true);
    
    // Draw drag ghost
    if (game.dragHero) {
      const cell = screenToGrid(game.dragX, game.dragY);
      if (cell) {
        const pos = gridToScreen(cell.col, cell.row);
        ctx.fillStyle = 'rgba(100,200,255,0.15)';
        ctx.fillRect(gridOffsetX + cell.col*cellSize, gridOffsetY + cell.row*cellSize, cellSize, cellSize);
      }
      
      ctx.globalAlpha = 0.7;
      ctx.font = `${cellSize*0.6}px sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(game.dragHero.emoji, game.dragX, game.dragY);
      ctx.globalAlpha = 1;
    }
    
    // Hint text
    if (game.bench.length > 0 || gridHasHeroes()) {
      ctx.fillStyle = 'rgba(150,180,255,0.4)';
      ctx.font = '11px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(t('dragHint'), C.width/2, gridOffsetY + GRID_ROWS*cellSize + 15);
    }
    
  } else if (game.phase === 'battle') {
    updateBattle(dt);
    
    drawGrid(false);
    drawGrid(true);
    
    // Draw battle units
    for (const unit of game.battleUnits) {
      drawBattleUnit(unit);
    }
    
    drawProjectiles();
    
    // Battle timer
    ctx.fillStyle = '#aaa';
    ctx.font = '12px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(`â±ï¸ ${Math.floor(game.battleTimer)}s`, C.width/2, 60*dpr/dpr + 20);
    
    // Unit counts
    const pCount = game.battleUnits.filter(u=>u.team===0&&u.alive).length;
    const eCount = game.battleUnits.filter(u=>u.team===1&&u.alive).length;
    ctx.fillStyle = '#4488ff';
    ctx.fillText(`ğŸ‘¤ ${pCount}`, C.width/2 - 40, 60*dpr/dpr + 20);
    ctx.fillStyle = '#ff4444';
    ctx.fillText(`ğŸ‘¤ ${eCount}`, C.width/2 + 40, 60*dpr/dpr + 20);
  }
  
  // Particles
  updateParticles(dt);
  drawParticles();
  
  if (shakeTime > 0) ctx.restore();
  
  requestAnimationFrame(gameLoop);
}

function gridHasHeroes() {
  for (let r=0;r<GRID_ROWS;r++) for (let c=0;c<GRID_COLS;c++) if (game.grid[r][c]) return true;
  return false;
}

// ---- EVENT LISTENERS ----
C.addEventListener('mousedown', onPointerDown);
C.addEventListener('mousemove', onPointerMove);
C.addEventListener('mouseup', onPointerUp);
C.addEventListener('touchstart', e => { e.preventDefault(); onPointerDown(e); }, {passive:false});
C.addEventListener('touchmove', e => { e.preventDefault(); onPointerMove(e); }, {passive:false});
C.addEventListener('touchend', e => { onPointerUp(e); }, {passive:false});

document.getElementById('reroll-btn').onclick = rerollShop;
document.getElementById('battle-btn').onclick = startBattle;
document.getElementById('save-btn').onclick = saveGame;
document.getElementById('lang-btn').onclick = () => {
  lang = lang === 'ko' ? 'en' : 'ko';
  document.getElementById('lang-btn').textContent = lang === 'ko' ? 'EN' : 'KO';
  updateUI();
  renderShop();
  renderBench();
  updateSynergyPanel();
  document.getElementById('phase-info').textContent = game.phase === 'prepare' ? t('prepare') : t('battle');
};

window.addEventListener('resize', resize);

// ---- INIT ----
resize();
showWelcome();
requestAnimationFrame(gameLoop);

// ---- ADDITIONAL FEATURES FOR SIZE & POLISH ----

// === HERO DETAIL TOOLTIP ===
let tooltipHero = null;
C.addEventListener('dblclick', (e) => {
  if (game.phase !== 'prepare') return;
  const pos = getEventPos(e);
  const cell = screenToGrid(pos.x, pos.y);
  if (cell && game.grid[cell.row][cell.col]) {
    showHeroDetail(game.grid[cell.row][cell.col], pos.x/dpr, pos.y/dpr);
  }
});

function showHeroDetail(hero, x, y) {
  // Remove existing
  const existing = document.querySelector('.hero-detail');
  if (existing) existing.remove();
  
  const div = document.createElement('div');
  div.className = 'hero-detail';
  div.style.left = Math.min(x, window.innerWidth - 210) + 'px';
  div.style.top = Math.min(y, window.innerHeight - 200) + 'px';
  div.style.display = 'block';
  
  const name = hero.name[lang==='ko'?0:1];
  const typeName = t(hero.type);
  const tierStars = 'â­'.repeat(hero.tier+1);
  
  div.innerHTML = `
    <h3>${hero.emoji} ${name} ${tierStars}</h3>
    <div style="color:${HERO_COLORS[hero.type]};font-size:11px;margin-bottom:6px">${typeName} | Lv.${hero.level}</div>
    <div class="stat"><span>â¤ï¸ ${t('hp2')}</span><span>${hero.hp}/${hero.maxHp}</span></div>
    <div class="stat"><span>âš”ï¸ ${t('atk')}</span><span>${hero.atk}</span></div>
    <div class="stat"><span>ğŸ›¡ï¸ ${t('def')}</span><span>${hero.def}</span></div>
    <div class="stat"><span>ğŸ’¨ ${t('spd')}</span><span>${hero.spd}</span></div>
    <div class="stat"><span>ğŸ”® ${t('skill')}</span><span>${hero.skillName.split('/')[lang==='ko'?0:1]}</span></div>
    <div class="stat"><span>ğŸ’ Mana</span><span>${hero.maxMana}</span></div>
    ${hero.item ? `<div class="stat"><span>${hero.item.emoji} ${hero.item.name.split('/')[lang==='ko'?0:1]}</span><span>+${hero.item.value} ${hero.item.stat}</span></div>` : ''}
    <div style="margin-top:6px;font-size:10px;color:#888">${t('cost')}: ${hero.cost}ğŸ’°</div>
  `;
  
  div.onclick = () => div.remove();
  document.getElementById('ui-overlay').appendChild(div);
  
  setTimeout(() => div.remove(), 5000);
}

// === BACKGROUND STARS ===
const bgStars = [];
for (let i = 0; i < 60; i++) {
  bgStars.push({
    x: Math.random(),
    y: Math.random(),
    size: Math.random() * 2 + 0.5,
    speed: Math.random() * 0.0003 + 0.0001,
    brightness: Math.random()
  });
}

const origDrawBg = drawBackground;
drawBackground = function() {
  origDrawBg();
  // Twinkling stars
  for (const star of bgStars) {
    star.brightness += star.speed * (Math.random() > 0.5 ? 1 : -1) * 60;
    if (star.brightness > 1) star.brightness = 1;
    if (star.brightness < 0.2) star.brightness = 0.2;
    ctx.fillStyle = `rgba(200,220,255,${star.brightness * 0.3})`;
    ctx.beginPath();
    ctx.arc(star.x * C.width, star.y * C.height, star.size, 0, Math.PI*2);
    ctx.fill();
  }
};

// === ROUND TRANSITION EFFECT ===
function doTransition(callback) {
  let alpha = 0;
  const fade = () => {
    alpha += 0.05;
    if (alpha >= 1) {
      callback();
      const fadeIn = () => {
        alpha -= 0.05;
        if (alpha <= 0) return;
        ctx.fillStyle = `rgba(0,0,0,${alpha})`;
        ctx.fillRect(0,0,C.width,C.height);
        requestAnimationFrame(fadeIn);
      };
      requestAnimationFrame(fadeIn);
      return;
    }
    ctx.fillStyle = `rgba(0,0,0,${alpha})`;
    ctx.fillRect(0,0,C.width,C.height);
    requestAnimationFrame(fade);
  };
  requestAnimationFrame(fade);
}

// === AUTO-SAVE EVERY 30 SECONDS ===
setInterval(() => {
  if (game.phase === 'prepare') {
    const saveData = {
      round: game.round, gold: game.gold, hp: game.hp, score: game.score,
      winStreak: game.winStreak, loseStreak: game.loseStreak,
      bench: game.bench.map(serializeHero),
      grid: game.grid.map(row => row.map(h => h ? serializeHero(h) : null)),
      items: game.items,
      stats: game.stats,
      lang: lang,
    };
    localStorage.setItem('autobattle_save', JSON.stringify(saveData));
  }
}, 30000);

// === KEYBOARD SHORTCUTS ===
document.addEventListener('keydown', (e) => {
  if (game.phase === 'prepare') {
    if (e.key === ' ' || e.key === 'Enter') { e.preventDefault(); startBattle(); }
    if (e.key === 'r' || e.key === 'R') rerollShop();
    if (e.key === 's' || e.key === 'S') saveGame();
    if (e.key === '1') buyHero(0);
    if (e.key === '2') buyHero(1);
    if (e.key === '3') buyHero(2);
  }
});

// === WINNING STREAK & LOSS STREAK INDICATOR ===
function drawStreakIndicator() {
  if (game.phase !== 'prepare' && game.phase !== 'battle') return;
  const x = C.width - 80;
  const y = 80;
  
  if (game.winStreak > 0) {
    ctx.fillStyle = '#44ff44';
    ctx.font = 'bold 12px sans-serif';
    ctx.textAlign = 'right';
    ctx.fillText(`ğŸ”¥ ${game.winStreak} ${t('streak')}`, x, y);
  } else if (game.loseStreak > 0) {
    ctx.fillStyle = '#ff4444';
    ctx.font = 'bold 12px sans-serif';
    ctx.textAlign = 'right';
    ctx.fillText(`ğŸ’” ${game.loseStreak} ${t('streak')}`, x, y);
  }
}

// Patch into draw loop
const origLoop = gameLoop;
// We'll just call drawStreakIndicator in the main loop by patching drawBackground again
const origBg2 = drawBackground;
drawBackground = function() {
  origBg2();
};

// Add streak to end of battle units drawing
const _origUpdateBattle = updateBattle;
updateBattle = function(dt) {
  _origUpdateBattle(dt);
};

// We'll use a separate overlay draw to avoid complexity
const origRaf = gameLoop;

// === COMPREHENSIVE HERO DATABASE ===
// Additional hero details for collection feel
const HERO_LORE = {
  warrior: {
    ko: ['ìš©ë§¹í•œ ì „ì‚¬. ê°•ë ¥í•œ ê·¼ì ‘ ê³µê²©.', 'ì „ì„¤ì˜ ê²€ì‚¬. ì ì„ ë² ì–´ë„˜ê¸´ë‹¤.', 'ì²œí•˜ë¬´ì  ìš©ì‚¬. ëª¨ë“  ê²ƒì„ íŒŒê´´í•œë‹¤.'],
    en: ['Brave warrior. Powerful melee attacks.', 'Legendary swordsman. Cuts through enemies.', 'Invincible hero. Destroys everything.']
  },
  archer: {
    ko: ['ë‚ ì¹´ë¡œìš´ ëˆˆ. ë¨¼ ì ë„ ì •í™•íˆ ë§íŒë‹¤.', 'ë§¤ì˜ ëˆˆì„ ê°€ì§„ ê¶ìˆ˜. ë¹ ë¥´ê³  ì¹˜ëª…ì .', 'ë³„ì„ ì˜ëŠ” ê¶ìˆ˜. í•˜ëŠ˜ì˜ í˜ì„ ë¹Œë¦°ë‹¤.'],
    en: ['Sharp eyes. Hits distant enemies precisely.', 'Archer with hawk eyes. Fast and deadly.', 'Star archer. Borrows the power of the sky.']
  },
  mage: {
    ko: ['ë¶ˆê½ƒì„ ë‹¤ë£¨ëŠ” ë§ˆë²•ì‚¬. ê´‘ì—­ ê³µê²©ì˜ ë‹¬ì¸.', 'ì„œë¦¬ì˜ í˜. ì ì„ ì–¼ë ¤ ë¶€ìˆœë‹¤.', 'ë²ˆê°œë¥¼ ë¶€ë¥´ëŠ” ëŒ€ë§ˆë²•ì‚¬.'],
    en: ['Fire mage. Master of AoE attacks.', 'Frost power. Freezes and shatters enemies.', 'Grand mage who summons lightning.']
  },
  healer: {
    ko: ['ìì—°ì˜ ì¹˜ìœ ì‚¬. ì•„êµ°ì„ íšŒë³µì‹œí‚¨ë‹¤.', 'ë¹›ì˜ í˜ìœ¼ë¡œ ìƒì²˜ë¥¼ ì¹˜ìœ í•œë‹¤.', 'ë³„ë¹›ì˜ ì¶•ë³µ. íŒ€ ì „ì²´ë¥¼ ë³´í˜¸í•œë‹¤.'],
    en: ['Nature healer. Recovers allies.', 'Heals wounds with the power of light.', 'Starlight blessing. Protects the entire team.']
  },
  tank: {
    ko: ['ì² ë²½ ë°©ì–´. íŒ€ì˜ ë°©íŒ¨ê°€ ëœë‹¤.', 'ë¬´ë„ˆì§€ì§€ ì•ŠëŠ” ì„±ë²½. ì ì˜ ê³µê²©ì„ í¡ìˆ˜.', 'ì‚°ì²˜ëŸ¼ ë‹¨ë‹¨í•œ ìˆ˜í˜¸ì.'],
    en: ['Iron defense. Becomes the team shield.', 'Unbreakable fortress. Absorbs enemy attacks.', 'Guardian solid as a mountain.']
  },
  assassin: {
    ko: ['ê·¸ë¦¼ì ì†ì—ì„œ ê¸°ìŠµ. ì•½í•œ ì ì„ ì²˜ì¹˜.', 'ì¹¼ë°”ëŒì²˜ëŸ¼ ë¹ ë¥¸ ì•”ì‚´ì.', 'ì¹˜ëª…ì ì¸ ë…. ì¼ê²©ì— ì ì„ ì“°ëŸ¬ëœ¨ë¦°ë‹¤.'],
    en: ['Ambush from shadows. Eliminates weak enemies.', 'Assassin fast as a blade wind.', 'Deadly poison. Defeats enemies in one strike.']
  }
};

// === ACHIEVEMENT SYSTEM ===
const ACHIEVEMENTS = [
  {id:'first_win', name:{ko:'ì²« ìŠ¹ë¦¬',en:'First Victory'}, emoji:'ğŸ†', check:()=>game.stats.roundsWon>=1},
  {id:'merge_master', name:{ko:'í•©ì„± ì¥ì¸',en:'Merge Master'}, emoji:'ğŸ”„', check:()=>game.stats.merges>=3},
  {id:'kill_50', name:{ko:'50í‚¬',en:'50 Kills'}, emoji:'ğŸ’€', check:()=>game.stats.heroesKilled>=50},
  {id:'round_10', name:{ko:'10ë¼ìš´ë“œ',en:'Round 10'}, emoji:'ğŸŸï¸', check:()=>game.round>=10},
  {id:'round_20', name:{ko:'20ë¼ìš´ë“œ',en:'Round 20'}, emoji:'ğŸŒŸ', check:()=>game.round>=20},
  {id:'streak_5', name:{ko:'5ì—°ìŠ¹',en:'5 Win Streak'}, emoji:'ğŸ”¥', check:()=>game.winStreak>=5},
  {id:'collector', name:{ko:'ìˆ˜ì§‘ê°€',en:'Collector'}, emoji:'ğŸ“¦', check:()=>game.bench.length+countGridHeroes()>=8},
  {id:'item_user', name:{ko:'ì¥ë¹„ ë§ˆìŠ¤í„°',en:'Item Master'}, emoji:'âš”ï¸', check:()=>game.stats.itemsUsed>=3},
  {id:'rich', name:{ko:'ë¶€ì',en:'Rich'}, emoji:'ğŸ’°', check:()=>game.gold>=50},
  {id:'full_grid', name:{ko:'í’€ ë°°ì¹˜',en:'Full Grid'}, emoji:'ğŸ“', check:()=>countGridHeroes()>=12},
];

let unlockedAchievements = JSON.parse(localStorage.getItem('autobattle_achievements') || '[]');

function countGridHeroes() {
  let c=0;
  for(let r=0;r<GRID_ROWS;r++) for(let cc=0;cc<GRID_COLS;cc++) if(game.grid[r][cc]) c++;
  return c;
}

function checkAchievements() {
  for (const ach of ACHIEVEMENTS) {
    if (!unlockedAchievements.includes(ach.id) && ach.check()) {
      unlockedAchievements.push(ach.id);
      localStorage.setItem('autobattle_achievements', JSON.stringify(unlockedAchievements));
      showToast(`ğŸ† ${ach.emoji} ${ach.name[lang]}!`);
      playSound('levelup');
      spawnParticles(C.width/2, C.height/2, '#ffd700', 20, {spread:8, life:1, upward:2});
    }
  }
}

// Check achievements periodically
setInterval(checkAchievements, 2000);

// === TUTORIAL HINTS ===
const tutorialShown = {};
function showTutorialHint(key, msg) {
  if (tutorialShown[key]) return;
  tutorialShown[key] = true;
  showToast(msg);
}

// Show tutorial on first actions
const _origBuy = buyHero;
buyHero = function(i) {
  _origBuy(i);
  if (game.bench.length === 1) {
    showTutorialHint('first_buy', lang==='ko'?'ğŸ’¡ ëŒ€ê¸°ì„ì˜ ì˜ì›…ì„ ë“œë˜ê·¸í•˜ì—¬ ê·¸ë¦¬ë“œì— ë°°ì¹˜í•˜ì„¸ìš”!':'ğŸ’¡ Drag heroes from bench to grid!');
  }
  if (game.bench.length >= 3) {
    showTutorialHint('merge_hint', lang==='ko'?'ğŸ’¡ ê°™ì€ ì˜ì›… 3ê°œë¥¼ ëª¨ìœ¼ë©´ ìë™ í•©ì„±ë©ë‹ˆë‹¤!':'ğŸ’¡ Collect 3 same heroes for auto-merge!');
  }
};

// === ANIMATED TITLE SCREEN ===
let titleAnim = 0;
function drawTitleScreen() {
  if (game.phase !== 'menu') return;
  titleAnim += 0.02;
  
  const cx = C.width/2, cy = C.height/2;
  
  // Floating emojis
  const emojis = ['âš”ï¸','ğŸ›¡ï¸','ğŸ¹','ğŸ”®','ğŸ’š','ğŸ—¡ï¸','ğŸ‘‘','ğŸ’'];
  emojis.forEach((e, i) => {
    const angle = titleAnim + (i/emojis.length)*Math.PI*2;
    const r = 120 + Math.sin(titleAnim*2+i)*20;
    const x = cx + Math.cos(angle)*r;
    const y = cy + Math.sin(angle)*r - 30;
    ctx.font = '24px sans-serif';
    ctx.textAlign = 'center';
    ctx.globalAlpha = 0.6 + Math.sin(titleAnim*3+i)*0.3;
    ctx.fillText(e, x, y);
  });
  ctx.globalAlpha = 1;
}

// Patch game loop to include title
const _mainLoop = gameLoop;
gameLoop = function(ts) {
  const dt = Math.min(0.05, (ts - lastTime) / 1000);
  lastTime = ts;
  
  if (shakeTime > 0) {
    shakeTime -= dt;
    ctx.save();
    ctx.translate(
      (Math.random()-0.5)*shakeIntensity*2,
      (Math.random()-0.5)*shakeIntensity*2
    );
  }
  
  drawBackground();
  
  if (game.phase === 'menu') {
    drawTitleScreen();
  } else if (game.phase === 'prepare' || game.phase === 'shop') {
    drawGrid(false);
    drawGrid(true);
    
    if (game.dragHero) {
      const cell = screenToGrid(game.dragX, game.dragY);
      if (cell) {
        ctx.fillStyle = 'rgba(100,200,255,0.15)';
        ctx.fillRect(gridOffsetX+cell.col*cellSize, gridOffsetY+cell.row*cellSize, cellSize, cellSize);
      }
      ctx.globalAlpha = 0.7;
      ctx.font = `${cellSize*0.6}px sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(game.dragHero.emoji, game.dragX, game.dragY);
      ctx.globalAlpha = 1;
    }
    
    if (game.bench.length > 0 || gridHasHeroes()) {
      ctx.fillStyle = 'rgba(150,180,255,0.4)';
      ctx.font = '11px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(t('dragHint'), C.width/2, gridOffsetY + GRID_ROWS*cellSize + 15);
    }
    
    drawStreakIndicator();
    
  } else if (game.phase === 'battle') {
    updateBattle(dt);
    drawGrid(false);
    drawGrid(true);
    
    for (const unit of game.battleUnits) {
      drawBattleUnit(unit);
    }
    drawProjectiles();
    
    ctx.fillStyle = '#aaa';
    ctx.font = '12px sans-serif';
    ctx.textAlign = 'center';
    const infoY = 65;
    ctx.fillText(`â±ï¸ ${Math.floor(game.battleTimer)}s`, C.width/2, infoY);
    
    const pCount = game.battleUnits.filter(u=>u.team===0&&u.alive).length;
    const eCount = game.battleUnits.filter(u=>u.team===1&&u.alive).length;
    ctx.fillStyle = '#4488ff';
    ctx.fillText(`ğŸ‘¤${pCount}`, C.width/2 - 50, infoY);
    ctx.fillStyle = '#ff4444';
    ctx.fillText(`ğŸ‘¤${eCount}`, C.width/2 + 50, infoY);
    
    drawStreakIndicator();
  } else if (game.phase === 'gameover') {
    // Dark overlay with particles
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.fillRect(0,0,C.width,C.height);
  }
  
  updateParticles(dt);
  drawParticles();
  
  if (shakeTime > 0) ctx.restore();
  
  requestAnimationFrame(gameLoop);
};

// === ADDITIONAL VISUAL POLISH ===

// Draw hero merge count indicator in shop
function getHeroMatchCount(type, tier, nameIdx) {
  let count = 0;
  game.bench.forEach(h => {
    if (h.type === type && h.tier === tier && h.nameIdx === nameIdx) count++;
  });
  for (let r=0;r<GRID_ROWS;r++) for (let c=0;c<GRID_COLS;c++) {
    const h = game.grid[r][c];
    if (h && h.type === type && h.tier === tier && h.nameIdx === nameIdx) count++;
  }
  return count;
}

// Enhanced shop rendering
const _origRenderShop = renderShop;
renderShop = function() {
  const panel = document.getElementById('shop-panel');
  panel.innerHTML = '';
  game.shopOffers.forEach((hero, i) => {
    if (!hero) {
      const card = document.createElement('div');
      card.className = 'shop-card';
      card.style.opacity = '0.3';
      card.innerHTML = '<div style="font-size:24px;color:#555">âœ“</div><div style="font-size:10px;color:#555">'+(lang==='ko'?'íŒë§¤ì™„ë£Œ':'Sold')+'</div>';
      panel.appendChild(card);
      return;
    }
    const card = document.createElement('div');
    card.className = `shop-card tier-${hero.tier+1}`;
    const name = hero.name[lang==='ko'?0:1];
    const typeName = t(hero.type);
    const matchCount = getHeroMatchCount(hero.type, hero.tier, hero.nameIdx);
    const matchIndicator = matchCount > 0 ? `<div style="color:#ffa500;font-size:10px">ğŸ”„ ${matchCount}/3</div>` : '';
    const lore = HERO_LORE[hero.type][lang][hero.nameIdx];
    
    card.innerHTML = `
      <div class="hero-icon">${hero.emoji}</div>
      <div class="hero-name">${name}</div>
      <div class="hero-type">${typeName} ${'â­'.repeat(hero.tier+1)}</div>
      <div style="font-size:9px;color:#aaa">â¤ï¸${hero.hp} âš”ï¸${hero.atk} ğŸ›¡ï¸${hero.def}</div>
      <div style="font-size:8px;color:#777;margin:2px 0;height:22px;overflow:hidden">${lore}</div>
      ${matchIndicator}
      <div class="hero-cost">${hero.cost}ğŸ’°</div>
    `;
    card.onclick = () => buyHero(i);
    panel.appendChild(card);
  });
};

// === COLLECTION STATS (view total heroes owned) ===
function getCollectionInfo() {
  const owned = {};
  HERO_TYPES.forEach(type => {
    owned[type] = [0,0,0]; // count per tier
  });
  
  game.bench.forEach(h => owned[h.type][h.tier]++);
  for(let r=0;r<GRID_ROWS;r++) for(let c=0;c<GRID_COLS;c++) {
    const h = game.grid[r][c];
    if (h) owned[h.type][h.tier]++;
  }
  
  return owned;
}

// === ENEMY PREVIEW ===
function drawEnemyPreview() {
  if (game.phase !== 'prepare') return;
  
  const isBoss = game.round % BOSS_INTERVAL === 0;
  const enemyCount = Math.min(GRID_COLS * GRID_ROWS, 2 + Math.floor(game.round / 2));
  
  ctx.fillStyle = isBoss ? 'rgba(255,100,50,0.7)' : 'rgba(255,100,100,0.5)';
  ctx.font = '11px sans-serif';
  ctx.textAlign = 'center';
  
  const previewY = enemyGridOffsetY + GRID_ROWS * cellSize + 10;
  const label = isBoss ? 
    (lang==='ko'?`ğŸ”¥ ë³´ìŠ¤ ë¼ìš´ë“œ! (ì  ${enemyCount}ëª…)`:`ğŸ”¥ Boss Round! (${enemyCount} enemies)`) :
    (lang==='ko'?`ì  ${enemyCount}ëª… ì˜ˆìƒ`:`Expected ${enemyCount} enemies`);
  ctx.fillText(label, C.width/2, previewY);
}

// Patch background to include enemy preview
const _bgFn = drawBackground;
drawBackground = function() {
  _bgFn();
  drawEnemyPreview();
};

// === GOLD INTEREST DISPLAY ===
function drawGoldInfo() {
  if (game.phase !== 'prepare') return;
  const interest = Math.min(5, Math.floor(game.gold * INTEREST_RATE));
  if (interest > 0) {
    ctx.fillStyle = 'rgba(255,215,0,0.5)';
    ctx.font = '10px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText(`ğŸ’° ${t('interest')}: +${interest}`, 10, C.height - 120);
  }
  if (game.winStreak >= 3) {
    ctx.fillStyle = 'rgba(100,255,100,0.5)';
    ctx.font = '10px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText(`ğŸ”¥ ${t('streak')}: +${Math.min(3, Math.floor(game.winStreak/2))}`, 10, C.height - 105);
  }
}

// Patch to include gold info
const _bgFn2 = drawBackground;
drawBackground = function() {
  _bgFn2();
  drawGoldInfo();
};

// === DIFFICULTY SCALING INFO ===
function getDifficultyLabel(round) {
  if (round <= 5) return {ko:'ì‰¬ì›€',en:'Easy'};
  if (round <= 10) return {ko:'ë³´í†µ',en:'Normal'};
  if (round <= 15) return {ko:'ì–´ë ¤ì›€',en:'Hard'};
  if (round <= 20) return {ko:'ê·¹í•œ',en:'Extreme'};
  return {ko:'ì§€ì˜¥',en:'Hell'};
}

// === BATTLE SPEED CONTROL ===
let battleSpeedMult = 1;
document.addEventListener('keydown', (e) => {
  if (game.phase === 'battle' && e.key === 'f') {
    battleSpeedMult = battleSpeedMult === 1 ? 2 : 1;
    showToast(`â© x${battleSpeedMult}`);
  }
});

// === SELL ZONE VISUAL ===
function drawSellZone() {
  if (game.phase !== 'prepare' || !game.dragHero) return;
  ctx.fillStyle = 'rgba(255,50,50,0.15)';
  ctx.fillRect(0, 0, C.width, 60);
  ctx.fillStyle = 'rgba(255,100,100,0.7)';
  ctx.font = '14px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText(lang==='ko'?'ğŸ—‘ï¸ ì—¬ê¸°ì— ë†“ìœ¼ë©´ íŒë§¤':'ğŸ—‘ï¸ Drop here to sell', C.width/2, 35);
}

const _bgFn3 = drawBackground;
drawBackground = function() {
  _bgFn3();
  drawSellZone();
};

// === MINIMAP / ARMY STRENGTH COMPARISON ===
function drawArmyStrength() {
  if (game.phase !== 'prepare') return;
  
  let playerPower = 0;
  for (let r=0;r<GRID_ROWS;r++) for (let c=0;c<GRID_COLS;c++) {
    const h = game.grid[r][c];
    if (h) playerPower += h.atk + h.hp/5 + h.def*2 + (h.tier+1)*10;
  }
  
  const enemyCount = Math.min(GRID_COLS*GRID_ROWS, 2 + Math.floor(game.round/2));
  const statMult = 1 + (game.round-1)*0.12;
  const isBoss = game.round % BOSS_INTERVAL === 0;
  let enemyPower = enemyCount * 30 * statMult * (isBoss ? 1.5 : 1);
  
  if (playerPower === 0 && enemyPower === 0) return;
  
  const total = playerPower + enemyPower;
  const pPct = playerPower / total;
  
  const barW = 100, barH = 8;
  const barX = C.width/2 - barW/2;
  const barY = gridOffsetY - 20;
  
  ctx.fillStyle = '#333';
  ctx.fillRect(barX, barY, barW, barH);
  ctx.fillStyle = '#4488ff';
  ctx.fillRect(barX, barY, barW * pPct, barH);
  ctx.fillStyle = '#ff4444';
  ctx.fillRect(barX + barW*pPct, barY, barW*(1-pPct), barH);
  
  ctx.fillStyle = '#aaa';
  ctx.font = '9px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText(`âš¡${Math.floor(playerPower)} vs ${Math.floor(enemyPower)}âš¡`, C.width/2, barY - 3);
}

const _bgFn4 = drawBackground;
drawBackground = function() {
  _bgFn4();
  drawArmyStrength();
};

// === FLOATING COMBAT TEXT ENHANCEMENTS ===
function spawnCombatText(x, y, text, color, size) {
  particles.push({
    x: x + (Math.random()-0.5)*20,
    y: y - 10,
    vx: (Math.random()-0.5)*1.5,
    vy: -2 - Math.random(),
    life: 1.2,
    maxLife: 1.2,
    size: size || 13,
    color, type:'text', text,
    gravity: 0.02, shrink: false
  });
}

// === HERO TYPE EFFECTIVENESS ===
// Warrior > Assassin > Archer > Mage > Warrior, Tank resists all, Healer neutral
function getTypeMultiplier(attackerType, defenderType) {
  const advantages = {
    warrior: 'assassin',
    assassin: 'archer',
    archer: 'mage',
    mage: 'warrior'
  };
  if (advantages[attackerType] === defenderType) return 1.2;
  // Find reverse
  for (const [k,v] of Object.entries(advantages)) {
    if (k === defenderType && v === attackerType) return 0.85;
  }
  if (defenderType === 'tank') return 0.9;
  return 1.0;
}

// === ENHANCED GAME OVER SCREEN ===
const _origShowGameOver = showGameOver;
showGameOver = function() {
  const diff = getDifficultyLabel(game.round);
  const msg = t('gameOverMsg').replace('{r}', game.round).replace('{s}', game.score);
  const stats = `
ğŸ—¡ï¸ ${game.stats.heroesKilled} ${lang==='ko'?'ì²˜ì¹˜':'Kills'}
ğŸ”„ ${game.stats.merges} ${lang==='ko'?'í•©ì„±':'Merges'}
ğŸ† ${game.stats.roundsWon} ${lang==='ko'?'ìŠ¹ë¦¬':'Wins'}
âš”ï¸ ${game.stats.itemsUsed} ${lang==='ko'?'ì•„ì´í…œ ì‚¬ìš©':'Items Used'}
ğŸ“Š ${lang==='ko'?'ë‚œì´ë„':'Difficulty'}: ${diff[lang]}
ğŸ… ${lang==='ko'?'ì—…ì ':'Achievements'}: ${unlockedAchievements.length}/${ACHIEVEMENTS.length}`;
  
  showModal(t('gameOver'), msg + '\n' + stats, [
    {text: t('newGame'), cls:'btn-green', action: newGame},
  ]);
  
  // Save high score
  const hs = parseInt(localStorage.getItem('autobattle_highscore') || '0');
  if (game.score > hs) {
    localStorage.setItem('autobattle_highscore', game.score.toString());
    showToast(lang==='ko'?`ğŸ‰ ìµœê³  ê¸°ë¡! ${game.score}ì `:`ğŸ‰ New High Score! ${game.score}pts`);
  }
};

// === WELCOME SCREEN WITH HIGH SCORE ===
const _origShowWelcome = showWelcome;
showWelcome = function() {
  const hasSave = !!localStorage.getItem('autobattle_save');
  const hs = parseInt(localStorage.getItem('autobattle_highscore') || '0');
  const hsText = hs > 0 ? `\n\nğŸ… ${lang==='ko'?'ìµœê³  ê¸°ë¡':'High Score'}: ${hs}` : '';
  const achText = unlockedAchievements.length > 0 ? `\nğŸ† ${lang==='ko'?'ì—…ì ':'Achievements'}: ${unlockedAchievements.length}/${ACHIEVEMENTS.length}` : '';
  
  const buttons = [
    {text: t('play'), cls:'btn-green', action: () => { newGame(); }},
  ];
  if (hasSave) {
    buttons.unshift({text: t('resume'), cls:'btn-gold', action: loadGame});
  }
  showModal(t('title'), t('welcome') + hsText + achText, buttons);
};

// Refresh welcome
showWelcome();

// === PERFORMANCE: limit particles ===
const MAX_PARTICLES = 200;
const _origSpawnParticles = spawnParticles;
spawnParticles = function(x,y,color,count,opts) {
  const allowed = Math.min(count, MAX_PARTICLES - particles.length);
  if (allowed > 0) _origSpawnParticles(x,y,color,allowed,opts);
};

console.log('ğŸ® Auto Battle Arena loaded! Version 1.0');
console.log('Keyboard: Space/Enter=Battle, R=Reroll, S=Save, 1/2/3=Buy, F=Fast(battle)');
</script>
</body>
</html>