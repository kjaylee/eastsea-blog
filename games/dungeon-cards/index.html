<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Dungeon Cards - Roguelike Deckbuilding</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --bg: #0a0a0a; --card-bg: #1a1a2e; --accent: #e94560;
            --gold: #ffd700; --hp: #ff4444; --text: #eee;
            --monster: #ff6b6b; --item: #4ecdc4; --event: #ffe66d;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: var(--text); overflow: hidden;
            user-select: none; -webkit-user-select: none;
            touch-action: manipulation;
        }
        #gameCanvas {
            display: block; margin: 0 auto;
            background: radial-gradient(circle at 50% 50%, #0f3460, #0a0a0a);
            box-shadow: 0 10px 50px rgba(0,0,0,0.8);
            cursor: pointer; border: 2px solid #16213e;
        }
        .screen-shake { animation: shake 0.3s; }
        @keyframes shake {
            0%, 100% { transform: translate(0, 0); }
            10%, 30%, 50%, 70%, 90% { transform: translate(-5px, 5px); }
            20%, 40%, 60%, 80% { transform: translate(5px, -5px); }
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        @keyframes slideIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes glow {
            0%, 100% { box-shadow: 0 0 5px rgba(233,69,96,0.5); }
            50% { box-shadow: 0 0 20px rgba(233,69,96,1); }
        }
        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        .loading {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            display: flex; align-items: center; justify-content: center;
            background: var(--bg); z-index: 1000;
        }
        .loading-text {
            font-size: 2rem; color: var(--accent);
            animation: pulse 1.5s infinite;
        }
    </style>
</head>
<body>
    <div class="loading" id="loading">
        <div class="loading-text">‚öîÔ∏è Loading Dungeon...</div>
    </div>
    <canvas id="gameCanvas"></canvas>
    <script>
        // ========== CONSTANTS ==========
        const GRID_SIZE = 3;
        
        // Card descriptions for detailed info
        const CARD_DESCRIPTIONS = {
            SLIME: 'Weak but numerous. Easy pickings for beginners.',
            GOBLIN: 'Cunning creature. Carries some gold.',
            SKELETON: 'Undead warrior. Stronger bones than you think.',
            ORC: 'Brutal fighter. Pack a punch and heavy loot.',
            ZOMBIE: 'Slow but tough. Don\'t let them bite!',
            VAMPIRE: 'Bloodthirsty noble. High risk, high reward.',
            DEMON: 'From the depths. Requires serious firepower.',
            DRAGON: 'Ancient beast. Floor boss - prepare thoroughly!',
            GHOST: 'Ethereal specter. Phases through defenses.',
            WITCH: 'Dark magic user. Carries spell components.',
            GARGOYLE: 'Stone guardian. Very durable.',
            MINOTAUR: 'Labyrinth lord. Mid-boss encounter.',
            SWORD: 'Basic blade. Reliable damage boost.',
            SHIELD: 'Wooden shield. Reduces incoming damage.',
            BOW: 'Ranged weapon. Good power at distance.',
            STAFF: 'Magical catalyst. Highest base damage.',
            HELMET: 'Protective headgear. Strong defense.',
            RING: 'Enchanted jewelry. Balanced stats.',
            AMULET: 'Protective charm. Defense focused.',
            BOOTS: 'Swift footwear. Light protection.',
            POTION: 'Red vial. Restores 10 HP.',
            MEGA_POTION: 'Large flask. Major healing.',
            GOLD: 'Coin pile. Immediate wealth.',
            CHEST: 'Locked treasure. Requires key.',
            KEY: 'Golden key. Opens one chest.',
            TRAP: 'Hidden spike trap. Instant damage!',
            BOOK: 'Ancient tome. Grants experience.',
            MERCHANT: 'Wandering trader. Sells healing.',
            SHRINE: 'Holy altar. Random blessing.',
            FOUNTAIN: 'Magical waters. Medium heal.',
            ANVIL: 'Blacksmith station. Upgrades weapon.'
        };
        
        const CARD_TYPES = {
            // Monsters (15 types total)
            SLIME: { emoji: 'üü¢', name: 'Ïä¨ÎùºÏûÑ', type: 'monster', hp: 2, dmg: 1, gold: 5, xp: 10 },
            GOBLIN: { emoji: 'üë∫', name: 'Í≥†Î∏îÎ¶∞', type: 'monster', hp: 4, dmg: 2, gold: 10, xp: 20 },
            SKELETON: { emoji: 'üíÄ', name: 'Ïä§ÏºàÎ†àÌÜ§', type: 'monster', hp: 6, dmg: 3, gold: 15, xp: 30 },
            ORC: { emoji: 'üëπ', name: 'Ïò§ÌÅ¨', type: 'monster', hp: 10, dmg: 5, gold: 25, xp: 50 },
            ZOMBIE: { emoji: 'üßü', name: 'Ï¢ÄÎπÑ', type: 'monster', hp: 8, dmg: 4, gold: 20, xp: 40 },
            VAMPIRE: { emoji: 'üßõ', name: 'Î±ÄÌååÏù¥Ïñ¥', type: 'monster', hp: 12, dmg: 6, gold: 35, xp: 70 },
            DEMON: { emoji: 'üòà', name: 'ÏïÖÎßà', type: 'monster', hp: 15, dmg: 8, gold: 50, xp: 100 },
            DRAGON: { emoji: 'üêâ', name: 'ÎìúÎûòÍ≥§', type: 'boss', hp: 30, dmg: 12, gold: 100, xp: 200 },
            
            // Items
            SWORD: { emoji: '‚öîÔ∏è', name: 'Í≤Ä', type: 'weapon', power: 3 },
            SHIELD: { emoji: 'üõ°Ô∏è', name: 'Î∞©Ìå®', type: 'armor', defense: 2 },
            BOW: { emoji: 'üèπ', name: 'Ìôú', type: 'weapon', power: 4 },
            STAFF: { emoji: 'ü™Ñ', name: 'ÎßàÎ≤ïÎ¥â', type: 'weapon', power: 5 },
            HELMET: { emoji: '‚õëÔ∏è', name: 'Ìà¨Íµ¨', type: 'armor', defense: 3 },
            
            // Consumables
            POTION: { emoji: 'üß™', name: 'Ìè¨ÏÖò', type: 'potion', heal: 10 },
            MEGA_POTION: { emoji: '‚öóÔ∏è', name: 'ÎåÄÌòï Ìè¨ÏÖò', type: 'potion', heal: 25 },
            
            // Treasures
            GOLD: { emoji: 'üí∞', name: 'Í≥®Îìú', type: 'gold', value: 20 },
            CHEST: { emoji: 'üì¶', name: 'Î≥¥Î¨ºÏÉÅÏûê', type: 'chest', gold: 50 },
            KEY: { emoji: 'üîë', name: 'Ïó¥Ïá†', type: 'key' },
            
            // Events
            TRAP: { emoji: 'üï≥Ô∏è', name: 'Ìï®Ï†ï', type: 'trap', dmg: 5 },
            BOOK: { emoji: 'üìñ', name: 'ÎßàÎ≤ïÏÑú', type: 'book', xp: 50 },
            MERCHANT: { emoji: 'üßô', name: 'ÏÉÅÏù∏', type: 'merchant' },
            
            // Additional monsters for variety
            GHOST: { emoji: 'üëª', name: 'Ïú†Î†π', type: 'monster', hp: 5, dmg: 3, gold: 12, xp: 25 },
            WITCH: { emoji: 'üßô‚Äç‚ôÄÔ∏è', name: 'ÎßàÎÖÄ', type: 'monster', hp: 7, dmg: 4, gold: 18, xp: 35 },
            GARGOYLE: { emoji: 'üóø', name: 'Í∞ÄÍ≥†Ïùº', type: 'monster', hp: 11, dmg: 6, gold: 30, xp: 60 },
            MINOTAUR: { emoji: 'üêÇ', name: 'ÎØ∏ÎÖ∏ÌÉÄÏö∞Î•¥', type: 'boss', hp: 25, dmg: 10, gold: 80, xp: 150 },
            
            // More items
            RING: { emoji: 'üíç', name: 'ÎßàÎ≤ïÎ∞òÏßÄ', type: 'accessory', power: 2, defense: 1 },
            AMULET: { emoji: 'üìø', name: 'Î∂ÄÏ†Å', type: 'accessory', power: 1, defense: 2 },
            BOOTS: { emoji: 'üë¢', name: 'Ïã†ÏÜçÏùò Ïã†Î∞ú', type: 'accessory', defense: 1 },
            
            // Special cards
            SHRINE: { emoji: '‚õ©Ô∏è', name: 'Ïã†Ï†Ñ', type: 'shrine' },
            FOUNTAIN: { emoji: '‚õ≤', name: 'ÏÉùÎ™ÖÏùò ÏÉò', type: 'fountain', heal: 15 },
            ANVIL: { emoji: 'üî®', name: 'ÎåÄÏû•Í∞Ñ', type: 'anvil' },
        };

        // ========== GAME STATE ==========
        let game = {
            player: { hp: 50, maxHp: 50, atk: 5, gold: 0, xp: 0, level: 1, position: { x: 1, y: 1 } },
            grid: Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(null)),
            floor: 1, cardsCleared: 0, gameOver: false, victory: false,
            equipment: { weapon: null, armor: null },
            particles: [], keys: 0, totalGold: 0,
            highScore: 0, upgrades: { maxHp: 0, atk: 0, slots: 0, startGold: 0, startKeys: 0 },
            achievements: {
                firstKill: false, floor5: false, floor10: false, floor20: false,
                collect100Gold: false, collect500Gold: false, maxLevel: false,
                allEquipment: false, perfectRun: false, speedRun: false
            },
            showHelp: true, helpDismissed: false, stats: {
                totalKills: 0, totalGoldEarned: 0, highestFloor: 0, gamesPlayed: 0, totalPlayTime: 0
            },
            hoveredCard: null, tooltipAlpha: 0, animTime: 0
        };

        // ========== AUDIO ==========
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        function playSound(type) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            
            const now = audioCtx.currentTime;
            const sounds = {
                flip: { freq: 400, dur: 0.1 },
                hit: { freq: 200, dur: 0.15 },
                levelup: { freq: [440, 550, 660], dur: 0.4 },
                boss: { freq: 100, dur: 0.5 },
                death: { freq: [300, 200, 100], dur: 0.6 },
                gold: { freq: 600, dur: 0.1 },
                heal: { freq: 500, dur: 0.2 }
            };
            
            const sound = sounds[type] || sounds.flip;
            
            if (Array.isArray(sound.freq)) {
                sound.freq.forEach((f, i) => {
                    setTimeout(() => {
                        osc.frequency.setValueAtTime(f, now + i * 0.1);
                    }, i * 100);
                });
            } else {
                osc.frequency.setValueAtTime(sound.freq, now);
            }
            
            gain.gain.setValueAtTime(0.3, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + sound.dur);
            
            osc.start(now);
            osc.stop(now + sound.dur);
        }

        // ========== PARTICLES ==========
        function createParticles(x, y, color, count = 10, text = null) {
            for (let i = 0; i < count; i++) {
                game.particles.push({
                    x, y, vx: (Math.random() - 0.5) * 4,
                    vy: -Math.random() * 4 - 2,
                    color, life: 1, text: i === 0 ? text : null
                });
            }
        }

        function updateParticles() {
            game.particles = game.particles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.2;
                p.life -= 0.02;
                return p.life > 0;
            });
        }

        // ========== SAVE/LOAD ==========
        function saveGame() {
            localStorage.setItem('dungeonCards', JSON.stringify({
                highScore: game.highScore,
                upgrades: game.upgrades,
                achievements: game.achievements,
                stats: game.stats,
                helpDismissed: game.helpDismissed
            }));
        }

        function loadGame() {
            const data = localStorage.getItem('dungeonCards');
            if (data) {
                const saved = JSON.parse(data);
                game.highScore = saved.highScore || 0;
                game.upgrades = saved.upgrades || game.upgrades;
                game.achievements = saved.achievements || game.achievements;
                game.stats = saved.stats || game.stats;
                game.helpDismissed = saved.helpDismissed || false;
                game.showHelp = !game.helpDismissed;
                applyUpgrades();
            }
        }

        function checkAchievements() {
            let newAchievement = false;
            
            if (!game.achievements.firstKill && game.stats.totalKills >= 1) {
                game.achievements.firstKill = true;
                newAchievement = true;
                showAchievement('üèÜ First Blood!');
            }
            
            if (!game.achievements.floor5 && game.floor >= 5) {
                game.achievements.floor5 = true;
                newAchievement = true;
                showAchievement('üèÜ Floor 5 Reached!');
            }
            
            if (!game.achievements.floor10 && game.floor >= 10) {
                game.achievements.floor10 = true;
                newAchievement = true;
                showAchievement('üèÜ Floor 10 Master!');
            }
            
            if (!game.achievements.floor20 && game.floor >= 20) {
                game.achievements.floor20 = true;
                newAchievement = true;
                showAchievement('üèÜ Floor 20 Legend!');
            }
            
            if (!game.achievements.collect100Gold && game.stats.totalGoldEarned >= 100) {
                game.achievements.collect100Gold = true;
                newAchievement = true;
                showAchievement('üèÜ Gold Collector!');
            }
            
            if (!game.achievements.collect500Gold && game.stats.totalGoldEarned >= 500) {
                game.achievements.collect500Gold = true;
                newAchievement = true;
                showAchievement('üèÜ Gold Hoarder!');
            }
            
            if (!game.achievements.maxLevel && game.player.level >= 10) {
                game.achievements.maxLevel = true;
                newAchievement = true;
                showAchievement('üèÜ Max Level!');
            }
            
            if (!game.achievements.allEquipment && game.equipment.weapon && game.equipment.armor && game.equipment.accessory) {
                game.achievements.allEquipment = true;
                newAchievement = true;
                showAchievement('üèÜ Fully Equipped!');
            }
            
            if (newAchievement) {
                saveGame();
            }
        }

        function showAchievement(text) {
            const w = canvas.width;
            const h = canvas.height;
            createParticles(w / 2, h / 4, '#ffd700', 30, text);
            playSound('levelup');
        }

        function applyUpgrades() {
            game.player.maxHp = 50 + game.upgrades.maxHp * 10;
            game.player.hp = game.player.maxHp;
            game.player.atk = 5 + game.upgrades.atk * 2;
            game.player.gold = game.upgrades.startGold * 20;
            game.keys = game.upgrades.startKeys;
        }

        // ========== GRID MANAGEMENT ==========
        function getCardPool(floor) {
            let pool = [];
            
            // Monsters based on floor
            if (floor % 5 === 0) {
                pool.push(floor % 10 === 0 ? 'DRAGON' : 'MINOTAUR');
            } else {
                if (floor >= 1) pool.push('SLIME', 'GOBLIN', 'GHOST');
                if (floor >= 2) pool.push('SKELETON', 'ZOMBIE');
                if (floor >= 4) pool.push('WITCH', 'ORC');
                if (floor >= 6) pool.push('VAMPIRE', 'GARGOYLE');
                if (floor >= 8) pool.push('DEMON');
            }
            
            // Items
            pool.push('SWORD', 'SHIELD', 'BOW', 'STAFF', 'HELMET');
            pool.push('RING', 'AMULET', 'BOOTS');
            pool.push('POTION', 'POTION', 'MEGA_POTION');
            pool.push('GOLD', 'GOLD', 'CHEST');
            pool.push('KEY', 'TRAP', 'BOOK', 'MERCHANT');
            pool.push('SHRINE', 'FOUNTAIN', 'ANVIL');
            
            return pool;
        }

        function spawnCard() {
            const empty = [];
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if (!game.grid[y][x]) empty.push({ x, y });
                }
            }
            
            if (empty.length === 0) return;
            
            const pool = getCardPool(game.floor);
            const type = pool[Math.floor(Math.random() * pool.length)];
            const card = { ...CARD_TYPES[type], revealed: false };
            
            // Scale monster stats with floor
            if (card.type === 'monster' || card.type === 'boss') {
                card.hp = Math.floor(card.hp * (1 + game.floor * 0.15));
                card.dmg = Math.floor(card.dmg * (1 + game.floor * 0.1));
                card.gold = Math.floor(card.gold * (1 + game.floor * 0.2));
            }
            
            const pos = empty[Math.floor(Math.random() * empty.length)];
            game.grid[pos.y][pos.x] = card;
        }

        function initGrid() {
            game.grid = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(null));
            game.player.position = { x: 1, y: 1 };
            game.cardsCleared = 0;
            
            for (let i = 0; i < 6; i++) spawnCard();
        }

        // ========== GAME LOGIC ==========
        function isAdjacent(x1, y1, x2, y2) {
            return Math.abs(x1 - x2) <= 1 && Math.abs(y1 - y2) <= 1 && !(x1 === x2 && y1 === y2);
        }

        function handleCardClick(gridX, gridY, screenX, screenY) {
            if (game.gameOver) return;
            
            const card = game.grid[gridY][gridX];
            if (!card) return;
            
            const { x: px, y: py } = game.player.position;
            if (!isAdjacent(px, py, gridX, gridY)) {
                shakeScreen();
                return;
            }
            
            playSound('flip');
            card.revealed = true;
            game.player.position = { x: gridX, y: gridY };
            
            // Process card effect
            processCard(card, screenX, screenY);
            
            // Remove card
            game.grid[gridY][gridX] = null;
            game.cardsCleared++;
            
            // Check floor completion
            if (game.cardsCleared >= 9) {
                game.floor++;
                initGrid();
                playSound('levelup');
                createParticles(screenX, screenY, '#ffd700', 20, `Floor ${game.floor}!`);
            } else {
                spawnCard();
            }
            
            checkGameOver();
        }

        function processCard(card, x, y) {
            switch (card.type) {
                case 'monster':
                case 'boss':
                    const playerPower = game.player.atk + (game.equipment.weapon?.power || 0);
                    if (playerPower >= card.hp) {
                        playSound('hit');
                        game.player.gold += card.gold;
                        game.player.xp += card.xp;
                        game.totalGold += card.gold;
                        game.stats.totalKills++;
                        game.stats.totalGoldEarned += card.gold;
                        createParticles(x, y, '#ffd700', 15, `+${card.gold}G`);
                        checkLevelUp();
                        checkAchievements();
                    } else {
                        const defense = game.equipment.armor?.defense || 0;
                        const damage = Math.max(1, card.dmg - defense);
                        game.player.hp -= damage;
                        playSound('hit');
                        shakeScreen();
                        createParticles(x, y, '#ff4444', 10, `-${damage}HP`);
                    }
                    break;
                    
                case 'weapon':
                    game.equipment.weapon = card;
                    createParticles(x, y, '#4ecdc4', 8, `+${card.power} ATK`);
                    playSound('flip');
                    break;
                    
                case 'armor':
                    game.equipment.armor = card;
                    createParticles(x, y, '#4ecdc4', 8, `+${card.defense} DEF`);
                    playSound('flip');
                    break;
                    
                case 'potion':
                    game.player.hp = Math.min(game.player.maxHp, game.player.hp + card.heal);
                    playSound('heal');
                    createParticles(x, y, '#4ecdc4', 10, `+${card.heal}HP`);
                    break;
                    
                case 'gold':
                    game.player.gold += card.value;
                    game.totalGold += card.value;
                    playSound('gold');
                    createParticles(x, y, '#ffd700', 12, `+${card.value}G`);
                    break;
                    
                case 'chest':
                    if (game.keys > 0) {
                        game.keys--;
                        game.player.gold += card.gold;
                        game.totalGold += card.gold;
                        playSound('gold');
                        createParticles(x, y, '#ffd700', 20, `+${card.gold}G`);
                    } else {
                        createParticles(x, y, '#ff4444', 5, 'Ïó¥Ïá† ÌïÑÏöî!');
                    }
                    break;
                    
                case 'key':
                    game.keys++;
                    playSound('flip');
                    createParticles(x, y, '#ffe66d', 8, '+1 Key');
                    break;
                    
                case 'trap':
                    game.player.hp -= card.dmg;
                    playSound('hit');
                    shakeScreen();
                    createParticles(x, y, '#ff4444', 15, `-${card.dmg}HP`);
                    break;
                    
                case 'book':
                    game.player.xp += card.xp;
                    playSound('flip');
                    createParticles(x, y, '#ffe66d', 10, `+${card.xp}XP`);
                    checkLevelUp();
                    break;
                    
                case 'merchant':
                    if (game.player.gold >= 30) {
                        game.player.gold -= 30;
                        game.player.hp = Math.min(game.player.maxHp, game.player.hp + 20);
                        playSound('heal');
                        createParticles(x, y, '#4ecdc4', 12, '+20HP (-30G)');
                    }
                    break;
                    
                case 'accessory':
                    if (!game.equipment.accessory) {
                        game.equipment.accessory = card;
                        game.player.atk += card.power || 0;
                        createParticles(x, y, '#ffe66d', 10, `+${card.name}`);
                        playSound('flip');
                    }
                    break;
                    
                case 'shrine':
                    // Blessing: Full heal or ATK boost
                    if (Math.random() > 0.5) {
                        game.player.hp = game.player.maxHp;
                        createParticles(x, y, '#4ecdc4', 15, 'Full Heal!');
                        playSound('heal');
                    } else {
                        game.player.atk += 3;
                        createParticles(x, y, '#ffd700', 15, '+3 ATK!');
                        playSound('levelup');
                    }
                    break;
                    
                case 'fountain':
                    game.player.hp = Math.min(game.player.maxHp, game.player.hp + card.heal);
                    playSound('heal');
                    createParticles(x, y, '#4ecdc4', 12, `+${card.heal}HP`);
                    break;
                    
                case 'anvil':
                    // Upgrade weapon
                    if (game.equipment.weapon) {
                        game.equipment.weapon.power += 2;
                        createParticles(x, y, '#ffd700', 15, 'Weapon +2!');
                        playSound('hit');
                    }
                    break;
            }
        }

        function checkLevelUp() {
            const xpNeeded = game.player.level * 100;
            if (game.player.xp >= xpNeeded) {
                game.player.level++;
                game.player.xp -= xpNeeded;
                game.player.maxHp += 5;
                game.player.hp = Math.min(game.player.maxHp, game.player.hp + 10);
                game.player.atk += 1;
                playSound('levelup');
            }
        }

        function checkGameOver() {
            if (game.player.hp <= 0) {
                game.gameOver = true;
                playSound('death');
                shakeScreen();
                
                game.stats.gamesPlayed++;
                if (game.floor > game.stats.highestFloor) {
                    game.stats.highestFloor = game.floor;
                }
                
                const score = game.floor * 100 + game.totalGold;
                if (score > game.highScore) {
                    game.highScore = score;
                }
                
                checkAchievements();
                saveGame();
            }
        }

        function shakeScreen() {
            canvas.classList.add('screen-shake');
            setTimeout(() => canvas.classList.remove('screen-shake'), 300);
        }

        // ========== RENDERING ==========
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        function resize() {
            const maxW = Math.min(window.innerWidth - 20, 600);
            const maxH = window.innerHeight - 20;
            const size = Math.min(maxW, maxH);
            canvas.width = size;
            canvas.height = size;
        }
        
        resize();
        window.addEventListener('resize', resize);

        function drawGame() {
            const w = canvas.width;
            const h = canvas.height;
            
            // Background
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, w, h);
            
            const headerH = h * 0.2;
            const gridH = h * 0.65;
            const footerH = h * 0.15;
            
            // Header - Player Stats
            drawHeader(w, headerH);
            
            // Grid
            drawGrid(w, headerH, gridH);
            
            // Particles
            drawParticles();
            
            // Footer - Equipment & Floor
            drawFooter(w, h - footerH, footerH);
            
            // Game Over / Upgrade Screen
            if (game.gameOver) drawGameOver(w, h);
            
            // Help Screen
            if (game.showHelp && !game.gameOver) drawHelp(w, h);
        }

        function drawHeader(w, h) {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, w, h);
            
            const fontSize = Math.max(14, w / 30);
            ctx.font = `bold ${fontSize}px sans-serif`;
            ctx.textAlign = 'left';
            
            // HP Bar
            const barY = h * 0.25;
            const barW = w * 0.85;
            const barH = h * 0.15;
            const barX = w * 0.075;
            
            ctx.fillStyle = '#2a2a3e';
            ctx.fillRect(barX, barY, barW, barH);
            ctx.fillStyle = '#ff4444';
            ctx.fillRect(barX, barY, barW * (game.player.hp / game.player.maxHp), barH);
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.strokeRect(barX, barY, barW, barH);
            
            ctx.fillStyle = '#fff';
            ctx.textAlign = 'center';
            ctx.fillText(`HP: ${game.player.hp}/${game.player.maxHp}`, w / 2, barY + barH * 0.65);
            
            // Stats Row
            const statsY = h * 0.65;
            ctx.font = `${fontSize * 0.8}px sans-serif`;
            ctx.textAlign = 'left';
            ctx.fillStyle = '#ffd700';
            ctx.fillText(`‚öîÔ∏è${game.player.atk + (game.equipment.weapon?.power || 0)}`, barX, statsY);
            ctx.fillText(`üí∞${game.player.gold}`, barX + barW * 0.25, statsY);
            ctx.fillText(`üîë${game.keys}`, barX + barW * 0.5, statsY);
            ctx.fillText(`Lv.${game.player.level}`, barX + barW * 0.7, statsY);
        }

        function drawGrid(w, startY, h) {
            const cellSize = Math.min(w, h) / GRID_SIZE * 0.9;
            const gridW = cellSize * GRID_SIZE;
            const gridX = (w - gridW) / 2;
            const gridY = startY + (h - cellSize * GRID_SIZE) / 2;
            
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const cx = gridX + x * cellSize;
                    const cy = gridY + y * cellSize;
                    
                    const card = game.grid[y][x];
                    const isPlayer = game.player.position.x === x && game.player.position.y === y;
                    const isAdj = isAdjacent(game.player.position.x, game.player.position.y, x, y);
                    const isHovered = game.hoveredCard && game.hoveredCard.x === x && game.hoveredCard.y === y;
                    
                    // Cell background with animation
                    if (isPlayer) {
                        ctx.fillStyle = '#e94560';
                    } else if (isAdj && isHovered) {
                        // Pulsing glow for hovered adjacent cells
                        const pulse = Math.sin(game.animTime * 0.005) * 0.3 + 0.7;
                        ctx.fillStyle = `rgba(78, 205, 196, ${pulse})`;
                    } else if (isAdj) {
                        ctx.fillStyle = '#2a4d6e';
                    } else {
                        ctx.fillStyle = '#1a1a2e';
                    }
                    
                    ctx.fillRect(cx + 4, cy + 4, cellSize - 8, cellSize - 8);
                    ctx.strokeStyle = isAdj ? '#4ecdc4' : '#333';
                    ctx.lineWidth = isHovered ? 3 : 2;
                    ctx.strokeRect(cx + 4, cy + 4, cellSize - 8, cellSize - 8);
                    
                    // Card content
                    if (card) {
                        // Card type indicator background
                        let cardColor = '#333';
                        if (card.type === 'monster' || card.type === 'boss') cardColor = 'rgba(255, 107, 107, 0.2)';
                        else if (card.type === 'weapon' || card.type === 'armor' || card.type === 'accessory') cardColor = 'rgba(78, 205, 196, 0.2)';
                        else if (card.type === 'gold' || card.type === 'chest') cardColor = 'rgba(255, 215, 0, 0.2)';
                        
                        ctx.fillStyle = cardColor;
                        ctx.fillRect(cx + 8, cy + 8, cellSize - 16, cellSize - 16);
                        
                        const emojiSize = cellSize * 0.4;
                        ctx.font = `${emojiSize}px sans-serif`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(card.emoji, cx + cellSize / 2, cy + cellSize / 2);
                        
                        // Card name
                        ctx.font = `${cellSize * 0.11}px sans-serif`;
                        ctx.fillStyle = '#fff';
                        ctx.fillText(card.name, cx + cellSize / 2, cy + cellSize * 0.85);
                        
                        // Monster stats display
                        if ((card.type === 'monster' || card.type === 'boss') && isAdj) {
                            ctx.font = `bold ${cellSize * 0.09}px sans-serif`;
                            ctx.fillStyle = '#ff4444';
                            ctx.fillText(`HP:${card.hp}`, cx + cellSize / 2, cy + cellSize * 0.15);
                            ctx.fillStyle = '#ffd700';
                            ctx.fillText(`${card.gold}G`, cx + cellSize / 2, cy + cellSize * 0.93);
                        }
                    }
                    
                    // Player marker with float animation
                    if (isPlayer) {
                        const floatOffset = Math.sin(game.animTime * 0.003) * 3;
                        ctx.font = `${cellSize * 0.25}px sans-serif`;
                        ctx.fillText('üßô', cx + cellSize / 2, cy + cellSize * 0.25 + floatOffset);
                    }
                }
            }
            
            // Draw tooltip for hovered card
            if (game.hoveredCard && game.hoveredCard.card) {
                drawCardTooltip(w, h, game.hoveredCard.card, game.hoveredCard.screenX, game.hoveredCard.screenY);
            }
        }
        
        function drawCardTooltip(w, h, card, x, y) {
            const tooltipW = w * 0.7;
            const tooltipH = h * 0.15;
            let tooltipX = x - tooltipW / 2;
            let tooltipY = y - tooltipH - 20;
            
            // Keep tooltip in bounds
            if (tooltipX < 10) tooltipX = 10;
            if (tooltipX + tooltipW > w - 10) tooltipX = w - tooltipW - 10;
            if (tooltipY < 10) tooltipY = y + 20;
            
            // Fade in/out
            if (game.tooltipAlpha < 1) game.tooltipAlpha += 0.1;
            ctx.globalAlpha = game.tooltipAlpha;
            
            // Background
            ctx.fillStyle = 'rgba(26, 26, 46, 0.95)';
            ctx.fillRect(tooltipX, tooltipY, tooltipW, tooltipH);
            ctx.strokeStyle = '#4ecdc4';
            ctx.lineWidth = 2;
            ctx.strokeRect(tooltipX, tooltipY, tooltipW, tooltipH);
            
            const fontSize = Math.max(10, w / 45);
            ctx.font = `bold ${fontSize * 1.2}px sans-serif`;
            ctx.fillStyle = '#ffd700';
            ctx.textAlign = 'center';
            ctx.fillText(card.name, tooltipX + tooltipW / 2, tooltipY + tooltipH * 0.25);
            
            // Get card type key
            let cardKey = '';
            for (let key in CARD_TYPES) {
                if (CARD_TYPES[key].name === card.name) {
                    cardKey = key;
                    break;
                }
            }
            
            ctx.font = `${fontSize * 0.8}px sans-serif`;
            ctx.fillStyle = '#ccc';
            const desc = CARD_DESCRIPTIONS[cardKey] || 'Unknown card';
            ctx.fillText(desc, tooltipX + tooltipW / 2, tooltipY + tooltipH * 0.5);
            
            // Stats
            ctx.font = `${fontSize * 0.75}px sans-serif`;
            ctx.fillStyle = '#aaa';
            let statsText = '';
            if (card.hp) statsText += `HP:${card.hp} `;
            if (card.dmg) statsText += `DMG:${card.dmg} `;
            if (card.power) statsText += `PWR:+${card.power} `;
            if (card.defense) statsText += `DEF:+${card.defense} `;
            if (card.gold) statsText += `üí∞${card.gold} `;
            if (card.heal) statsText += `‚ù§Ô∏è+${card.heal} `;
            
            ctx.fillText(statsText, tooltipX + tooltipW / 2, tooltipY + tooltipH * 0.75);
            
            ctx.globalAlpha = 1;
        }

        function drawFooter(w, startY, h) {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, startY, w, h);
            
            const fontSize = Math.max(12, w / 35);
            ctx.font = `${fontSize}px sans-serif`;
            ctx.textAlign = 'center';
            ctx.fillStyle = '#aaa';
            
            let equipText = 'Equipment: ';
            if (game.equipment.weapon) {
                equipText += `${game.equipment.weapon.emoji}${game.equipment.weapon.name}(+${game.equipment.weapon.power}) `;
            }
            if (game.equipment.armor) {
                equipText += `${game.equipment.armor.emoji}${game.equipment.armor.name}(+${game.equipment.armor.defense}) `;
            }
            if (game.equipment.accessory) {
                equipText += `${game.equipment.accessory.emoji}${game.equipment.accessory.name} `;
            }
            if (!game.equipment.weapon && !game.equipment.armor && !game.equipment.accessory) {
                equipText += 'None';
            }
            
            ctx.fillText(equipText, w / 2, startY + h * 0.35);
            
            ctx.fillStyle = '#ffd700';
            const totalPower = game.player.atk + (game.equipment.weapon?.power || 0) + (game.equipment.accessory?.power || 0);
            const totalDefense = (game.equipment.armor?.defense || 0) + (game.equipment.accessory?.defense || 0);
            ctx.fillText(`Floor ${game.floor} | Power: ${totalPower} | Defense: ${totalDefense}`, w / 2, startY + h * 0.6);
            
            ctx.fillStyle = '#4ecdc4';
            ctx.fillText(`High Score: ${game.highScore} | Highest Floor: ${game.stats.highestFloor}`, w / 2, startY + h * 0.85);
        }

        function drawParticles() {
            game.particles.forEach(p => {
                ctx.globalAlpha = p.life;
                
                if (p.text) {
                    ctx.font = 'bold 20px sans-serif';
                    ctx.fillStyle = p.color;
                    ctx.textAlign = 'center';
                    ctx.fillText(p.text, p.x, p.y);
                } else {
                    ctx.fillStyle = p.color;
                    ctx.fillRect(p.x, p.y, 4, 4);
                }
            });
            ctx.globalAlpha = 1;
        }

        function drawGameOver(w, h) {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
            ctx.fillRect(0, 0, w, h);
            
            const boxW = w * 0.9;
            const boxH = h * 0.8;
            const boxX = (w - boxW) / 2;
            const boxY = (h - boxH) / 2;
            
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(boxX, boxY, boxW, boxH);
            ctx.strokeStyle = '#e94560';
            ctx.lineWidth = 3;
            ctx.strokeRect(boxX, boxY, boxW, boxH);
            
            const fontSize = Math.max(16, w / 28);
            ctx.font = `bold ${fontSize * 1.5}px sans-serif`;
            ctx.fillStyle = '#e94560';
            ctx.textAlign = 'center';
            ctx.fillText('üíÄ GAME OVER', w / 2, boxY + boxH * 0.1);
            
            ctx.font = `${fontSize}px sans-serif`;
            ctx.fillStyle = '#fff';
            const score = game.floor * 100 + game.totalGold;
            ctx.fillText(`Score: ${score}`, w / 2, boxY + boxH * 0.18);
            
            ctx.font = `${fontSize * 0.8}px sans-serif`;
            ctx.fillStyle = '#aaa';
            ctx.fillText(`Floor: ${game.floor} | Kills: ${game.stats.totalKills}`, w / 2, boxY + boxH * 0.24);
            ctx.fillText(`Gold Earned: ${game.totalGold} | Level: ${game.player.level}`, w / 2, boxY + boxH * 0.29);
            
            // Stats section
            ctx.font = `bold ${fontSize * 0.85}px sans-serif`;
            ctx.fillStyle = '#ffd700';
            ctx.fillText('üìä CAREER STATS', w / 2, boxY + boxH * 0.36);
            
            ctx.font = `${fontSize * 0.7}px sans-serif`;
            ctx.fillStyle = '#ccc';
            ctx.fillText(`Games Played: ${game.stats.gamesPlayed}`, w / 2, boxY + boxH * 0.41);
            ctx.fillText(`Highest Floor: ${game.stats.highestFloor}`, w / 2, boxY + boxH * 0.45);
            ctx.fillText(`Total Gold: ${game.stats.totalGoldEarned}`, w / 2, boxY + boxH * 0.49);
            ctx.fillText(`Total Kills: ${game.stats.totalKills}`, w / 2, boxY + boxH * 0.53);
            
            // Achievements
            ctx.font = `bold ${fontSize * 0.85}px sans-serif`;
            ctx.fillStyle = '#ffd700';
            ctx.fillText('üèÜ ACHIEVEMENTS', w / 2, boxY + boxH * 0.6);
            
            ctx.font = `${fontSize * 0.65}px sans-serif`;
            const achX = boxX + boxW * 0.1;
            const achLineH = fontSize * 1.1;
            let achY = boxY + boxH * 0.65;
            
            ctx.textAlign = 'left';
            const achievements = [
                { key: 'firstKill', text: 'üó°Ô∏è First Blood' },
                { key: 'floor5', text: 'üèÖ Floor 5' },
                { key: 'floor10', text: 'üèÖ Floor 10' },
                { key: 'floor20', text: 'üèÖ Floor 20' },
                { key: 'collect100Gold', text: 'üí∞ 100 Gold' },
                { key: 'collect500Gold', text: 'üí∞ 500 Gold' },
                { key: 'maxLevel', text: '‚≠ê Max Level' },
                { key: 'allEquipment', text: 'üéí Fully Equipped' },
            ];
            
            achievements.forEach((ach, i) => {
                const col = i % 2;
                const row = Math.floor(i / 2);
                const x = achX + col * (boxW * 0.5);
                const y = achY + row * achLineH;
                
                ctx.fillStyle = game.achievements[ach.key] ? '#4ecdc4' : '#444';
                ctx.fillText(ach.text, x, y);
            });
            
            // Upgrades
            ctx.font = `bold ${fontSize * 0.9}px sans-serif`;
            ctx.fillStyle = '#ffd700';
            ctx.textAlign = 'center';
            ctx.fillText('üíé PERMANENT UPGRADES (Available: ' + game.player.gold + 'G)', w / 2, boxY + boxH * 0.81);
            
            ctx.font = `${fontSize * 0.7}px sans-serif`;
            const upgY = boxY + boxH * 0.86;
            const lineH = fontSize * 1.1;
            
            drawUpgradeButton(w / 2, upgY, '‚ù§Ô∏è +10 Max HP (50G)', 'maxHp', 50);
            drawUpgradeButton(w / 2, upgY + lineH, '‚öîÔ∏è +2 ATK (50G)', 'atk', 50);
            drawUpgradeButton(w / 2, upgY + lineH * 2, 'üí∞ +20 Start Gold (40G)', 'startGold', 40);
            drawUpgradeButton(w / 2, upgY + lineH * 3, 'üîë +1 Start Key (30G)', 'startKeys', 30);
            
            // Restart button
            ctx.font = `bold ${fontSize * 1.1}px sans-serif`;
            ctx.fillStyle = '#4ecdc4';
            ctx.fillText('üîÑ TAP TO RESTART', w / 2, boxY + boxH * 0.97);
        }

        function drawUpgradeButton(x, y, text, type, cost) {
            const owned = game.upgrades[type];
            const canAfford = game.player.gold >= cost;
            
            ctx.fillStyle = canAfford ? '#4ecdc4' : '#666';
            ctx.textAlign = 'center';
            ctx.fillText(`${text} [Lv.${owned}]`, x, y);
        }

        function drawHelp(w, h) {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
            ctx.fillRect(0, 0, w, h);
            
            const boxW = w * 0.9;
            const boxH = h * 0.85;
            const boxX = (w - boxW) / 2;
            const boxY = (h - boxH) / 2;
            
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(boxX, boxY, boxW, boxH);
            ctx.strokeStyle = '#e94560';
            ctx.lineWidth = 3;
            ctx.strokeRect(boxX, boxY, boxW, boxH);
            
            const fontSize = Math.max(12, w / 40);
            ctx.font = `bold ${fontSize * 1.5}px sans-serif`;
            ctx.fillStyle = '#e94560';
            ctx.textAlign = 'center';
            ctx.fillText('üÉè DUNGEON CARDS', w / 2, boxY + boxH * 0.08);
            
            ctx.font = `${fontSize * 0.85}px sans-serif`;
            ctx.fillStyle = '#aaa';
            ctx.textAlign = 'left';
            const leftX = boxX + boxW * 0.08;
            let lineY = boxY + boxH * 0.16;
            const lineH = fontSize * 1.5;
            
            const helpText = [
                'üìñ HOW TO PLAY:',
                '‚Ä¢ Navigate 3x3 grid by clicking adjacent cards',
                '‚Ä¢ Battle monsters, collect items & gold',
                '‚Ä¢ Clear 9 cards to advance to next floor',
                '',
                '‚öîÔ∏è COMBAT:',
                '‚Ä¢ Your Power = ATK + Weapon Power',
                '‚Ä¢ Win if Power ‚â• Monster HP',
                '‚Ä¢ Lose: Take (Monster DMG - Armor DEF)',
                '',
                'üé¥ CARD TYPES:',
                '‚Ä¢ Monsters: üü¢üë∫üíÄüëπüßüüßõüòàüëªüßô‚Äç‚ôÄÔ∏èüóø',
                '‚Ä¢ Bosses: üêâüêÇ (Every 5 floors)',
                '‚Ä¢ Weapons: ‚öîÔ∏èüõ°Ô∏èüèπü™Ñ‚õëÔ∏èüíçüìøüë¢',
                '‚Ä¢ Items: üß™‚öóÔ∏èüí∞üì¶üîëüï≥Ô∏èüìñ',
                '‚Ä¢ Special: üßô‚õ©Ô∏è‚õ≤üî®',
                '',
                'üèÜ TIPS:',
                '‚Ä¢ Save keys for treasure chests (50G)',
                '‚Ä¢ Visit merchants for healing (30G)',
                '‚Ä¢ Level up increases HP & ATK',
                '‚Ä¢ Use permanent upgrades between runs!',
                '',
                'üìä ACHIEVEMENTS & STATS TRACKED!',
            ];
            
            helpText.forEach(line => {
                if (line.startsWith('‚Ä¢')) {
                    ctx.fillStyle = '#ccc';
                } else if (line.includes(':')) {
                    ctx.fillStyle = '#ffd700';
                    ctx.font = `bold ${fontSize * 0.85}px sans-serif`;
                } else {
                    ctx.fillStyle = '#aaa';
                    ctx.font = `${fontSize * 0.85}px sans-serif`;
                }
                ctx.fillText(line, leftX, lineY);
                lineY += lineH;
            });
            
            ctx.font = `bold ${fontSize * 1.1}px sans-serif`;
            ctx.fillStyle = '#4ecdc4';
            ctx.textAlign = 'center';
            ctx.fillText('‚úì TAP ANYWHERE TO START', w / 2, boxY + boxH * 0.95);
        }

        // ========== INPUT ==========
        function getGridCoords(clickX, clickY) {
            const w = canvas.width;
            const h = canvas.height;
            const headerH = h * 0.2;
            const gridH = h * 0.65;
            const cellSize = Math.min(w, gridH) / GRID_SIZE * 0.9;
            const gridW = cellSize * GRID_SIZE;
            const gridX = (w - gridW) / 2;
            const gridY = headerH + (gridH - cellSize * GRID_SIZE) / 2;
            
            const gx = Math.floor((clickX - gridX) / cellSize);
            const gy = Math.floor((clickY - gridY) / cellSize);
            
            if (gx >= 0 && gx < GRID_SIZE && gy >= 0 && gy < GRID_SIZE) {
                return { gx, gy, sx: clickX, sy: clickY };
            }
            return null;
        }

        function handleClick(e) {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX || e.touches?.[0]?.clientX) - rect.left;
            const y = (e.clientY || e.touches?.[0]?.clientY) - rect.top;
            
            if (game.showHelp && !game.gameOver) {
                game.showHelp = false;
                game.helpDismissed = true;
                saveGame();
                playSound('flip');
                return;
            }
            
            if (game.gameOver) {
                // Check upgrade clicks
                const w = canvas.width;
                const h = canvas.height;
                const boxH = h * 0.7;
                const boxY = (h - boxH) / 2;
                const upgY = boxY + boxH * 0.68;
                const fontSize = Math.max(18, w / 25);
                const lineH = fontSize * 1.2;
                
                const upgrades = [
                    { type: 'maxHp', y: upgY, cost: 50 },
                    { type: 'atk', y: upgY + lineH, cost: 50 },
                    { type: 'startGold', y: upgY + lineH * 2, cost: 40 },
                    { type: 'startKeys', y: upgY + lineH * 3, cost: 30 }
                ];
                
                for (const upg of upgrades) {
                    if (Math.abs(y - upg.y) < lineH / 2 && game.player.gold >= upg.cost) {
                        game.player.gold -= upg.cost;
                        game.upgrades[upg.type]++;
                        saveGame();
                        playSound('gold');
                        return;
                    }
                }
                
                // Restart
                resetGame();
                return;
            }
            
            const coords = getGridCoords(x, y);
            if (coords) {
                handleCardClick(coords.gx, coords.gy, coords.sx, coords.sy);
            }
        }

        canvas.addEventListener('click', handleClick);
        canvas.addEventListener('touchstart', handleClick);

        // ========== HOVER DETECTION ==========
        function handleMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX || e.touches?.[0]?.clientX) - rect.left;
            const y = (e.clientY || e.touches?.[0]?.clientY) - rect.top;
            
            const coords = getGridCoords(x, y);
            if (coords && game.grid[coords.gy][coords.gx]) {
                game.hoveredCard = {
                    x: coords.gx, y: coords.gy,
                    card: game.grid[coords.gy][coords.gx],
                    screenX: x, screenY: y
                };
            } else {
                if (game.hoveredCard) {
                    game.tooltipAlpha = 0;
                }
                game.hoveredCard = null;
            }
        }
        
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('touchmove', handleMouseMove);

        // ========== GAME LOOP ==========
        function gameLoop() {
            game.animTime = Date.now();
            updateParticles();
            drawGame();
            requestAnimationFrame(gameLoop);
        }

        function resetGame() {
            game.player = {
                hp: 50, maxHp: 50, atk: 5, gold: game.player.gold,
                xp: 0, level: 1, position: { x: 1, y: 1 }
            };
            game.floor = 1;
            game.cardsCleared = 0;
            game.gameOver = false;
            game.equipment = { weapon: null, armor: null, accessory: null };
            game.particles = [];
            game.totalGold = 0;
            
            applyUpgrades();
            initGrid();
        }

        // ========== INIT ==========
        function init() {
            loadGame();
            applyUpgrades();
            initGrid();
            
            document.getElementById('loading').style.display = 'none';
            gameLoop();
        }

        // Start after brief delay
        setTimeout(init, 500);
    </script>
</body>
</html>