<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ğŸ”¥ Elemental TD - ì›ì†Œ íƒ€ì›Œ ë””íœìŠ¤</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #0f0c29 0%, #302b63 50%, #24243e 100%);
            color: #fff;
            overflow: hidden;
            touch-action: none;
            height: 100vh;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 12px;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            text-align: center;
            padding: 16px;
            background: linear-gradient(135deg, rgba(255, 107, 107, 0.3), rgba(238, 90, 111, 0.3));
            border-radius: 12px;
            margin-bottom: 12px;
            box-shadow: 0 4px 16px rgba(255, 107, 107, 0.3);
        }

        .header h1 {
            font-size: 24px;
            margin-bottom: 4px;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
        }

        .stats-bar {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            margin-bottom: 12px;
        }

        .stat {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0.05));
            padding: 8px;
            border-radius: 8px;
            text-align: center;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .stat-label {
            font-size: 10px;
            opacity: 0.8;
            margin-bottom: 2px;
        }

        .stat-value {
            font-size: 16px;
            font-weight: bold;
            color: #ffd700;
        }

        .game-area {
            flex: 1;
            display: grid;
            grid-template-columns: 1fr 140px;
            gap: 12px;
            min-height: 0;
        }

        .grid-container {
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.5));
            border-radius: 12px;
            padding: 8px;
            position: relative;
            overflow: hidden;
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            gap: 2px;
            height: 100%;
            aspect-ratio: 1;
            margin: 0 auto;
        }

        .cell {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            position: relative;
            cursor: pointer;
            transition: all 0.2s;
        }

        .cell:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .cell.path {
            background: rgba(139, 69, 19, 0.3);
            border-color: rgba(139, 69, 19, 0.5);
        }

        .cell.tower {
            background: radial-gradient(circle, rgba(138, 43, 226, 0.5), rgba(75, 0, 130, 0.3));
            border-color: #9370db;
        }

        .tower-icon {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 20px;
            pointer-events: none;
        }

        .tower-level {
            position: absolute;
            bottom: 2px;
            right: 2px;
            font-size: 8px;
            background: rgba(0, 0, 0, 0.7);
            padding: 1px 3px;
            border-radius: 2px;
            color: #ffd700;
        }

        .enemy {
            position: absolute;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: all 0.1s linear;
            pointer-events: none;
        }

        .projectile {
            position: absolute;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            pointer-events: none;
            transition: all 0.1s linear;
        }

        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .tower-btn {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0.05));
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 12px 8px;
            color: #fff;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            min-height: 70px;
        }

        .tower-btn:active {
            transform: scale(0.95);
        }

        .tower-btn.selected {
            background: linear-gradient(135deg, #8a2be2, #4b0082);
            border-color: #9370db;
            box-shadow: 0 0 16px rgba(138, 43, 226, 0.6);
        }

        .tower-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .tower-btn-icon {
            font-size: 28px;
        }

        .tower-btn-cost {
            font-size: 11px;
            color: #ffd700;
        }

        .control-btn {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, #46d167, #00b894);
            border: none;
            border-radius: 8px;
            color: #fff;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            min-height: 48px;
        }

        .control-btn:active {
            transform: scale(0.98);
        }

        .control-btn.danger {
            background: linear-gradient(135deg, #ff6b6b, #ee5a6f);
        }

        .wave-info {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0.05));
            padding: 12px;
            border-radius: 8px;
            text-align: center;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .wave-number {
            font-size: 20px;
            font-weight: bold;
            color: #ffd700;
            margin-bottom: 4px;
        }

        .wave-timer {
            font-size: 12px;
            opacity: 0.8;
        }

        .upgrade-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            padding: 16px;
        }

        .modal-content {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            padding: 24px;
            border-radius: 16px;
            border: 3px solid #8a2be2;
            box-shadow: 0 8px 32px rgba(138, 43, 226, 0.6);
            max-width: 400px;
            width: 100%;
        }

        .modal-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .modal-icon {
            font-size: 48px;
            margin-bottom: 8px;
        }

        .modal-title {
            font-size: 20px;
            font-weight: bold;
        }

        .upgrade-options {
            display: grid;
            gap: 12px;
            margin-bottom: 16px;
        }

        .upgrade-option {
            background: rgba(255, 255, 255, 0.05);
            padding: 12px;
            border-radius: 8px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .upgrade-option:hover {
            background: rgba(138, 43, 226, 0.3);
            border-color: #9370db;
        }

        .upgrade-name {
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 4px;
        }

        .upgrade-desc {
            font-size: 12px;
            opacity: 0.8;
            margin-bottom: 8px;
        }

        .upgrade-cost {
            font-size: 12px;
            color: #ffd700;
        }

        .particle {
            position: absolute;
            pointer-events: none;
            animation: particle-float 1s ease-out forwards;
            z-index: 9999;
        }

        @keyframes particle-float {
            0% { transform: scale(1) translateY(0); opacity: 1; }
            100% { transform: scale(0) translateY(-50px); opacity: 0; }
        }

        .achievement-toast {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #8a2be2, #4b0082);
            padding: 16px 24px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(138, 43, 226, 0.6);
            z-index: 10001;
            animation: slideDown 0.5s ease-out;
            max-width: 90%;
            text-align: center;
        }

        @keyframes slideDown {
            from { transform: translate(-50%, -100%); opacity: 0; }
            to { transform: translate(-50%, 0); opacity: 1; }
        }

        .health-bar {
            position: absolute;
            top: -6px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            height: 3px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 2px;
            overflow: hidden;
        }

        .health-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #46d167, #00b894);
            transition: width 0.2s;
        }

        .skills-panel {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0.05));
            padding: 12px;
            border-radius: 8px;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .skill-title {
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 8px;
            text-align: center;
        }

        .skill-grid {
            display: grid;
            gap: 8px;
        }

        .skill-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 8px;
            border-radius: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .skill-info {
            flex: 1;
        }

        .skill-name {
            font-size: 11px;
            font-weight: bold;
            margin-bottom: 2px;
        }

        .skill-level {
            font-size: 10px;
            opacity: 0.8;
        }

        .skill-upgrade-btn {
            padding: 4px 8px;
            background: linear-gradient(135deg, #8a2be2, #4b0082);
            border: none;
            border-radius: 4px;
            color: #fff;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .skill-upgrade-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ”¥ Elemental TD</h1>
            <div style="font-size: 12px; opacity: 0.9;">ì›ì†Œì˜ í˜ìœ¼ë¡œ ì ì„ ë¬¼ë¦¬ì¹˜ì„¸ìš”!</div>
        </div>

        <div class="stats-bar">
            <div class="stat">
                <div class="stat-label">â¤ï¸ ìƒëª…ë ¥</div>
                <div class="stat-value" id="health">100</div>
            </div>
            <div class="stat">
                <div class="stat-label">ğŸ’° ê³¨ë“œ</div>
                <div class="stat-value" id="gold">200</div>
            </div>
            <div class="stat">
                <div class="stat-label">ğŸŒŠ ì›¨ì´ë¸Œ</div>
                <div class="stat-value" id="wave">1</div>
            </div>
            <div class="stat">
                <div class="stat-label">â­ ìŠ¤í‚¬P</div>
                <div class="stat-value" id="skillPoints">0</div>
            </div>
        </div>

        <div class="game-area">
            <div class="grid-container">
                <div class="grid" id="grid"></div>
            </div>

            <div class="sidebar">
                <div class="wave-info">
                    <div class="wave-number">Wave <span id="waveNumber">1</span></div>
                    <div class="wave-timer" id="waveTimer">ì¤€ë¹„ ì™„ë£Œ</div>
                </div>

                <button class="tower-btn" data-type="fire" onclick="selectTower('fire')">
                    <div class="tower-btn-icon">ğŸ”¥</div>
                    <div>ë¶ˆ íƒ€ì›Œ</div>
                    <div class="tower-btn-cost">ğŸ’° 50</div>
                </button>

                <button class="tower-btn" data-type="water" onclick="selectTower('water')">
                    <div class="tower-btn-icon">ğŸ’§</div>
                    <div>ë¬¼ íƒ€ì›Œ</div>
                    <div class="tower-btn-cost">ğŸ’° 60</div>
                </button>

                <button class="tower-btn" data-type="earth" onclick="selectTower('earth')">
                    <div class="tower-btn-icon">ğŸŒ¿</div>
                    <div>í’€ íƒ€ì›Œ</div>
                    <div class="tower-btn-cost">ğŸ’° 70</div>
                </button>

                <button class="tower-btn" data-type="lightning" onclick="selectTower('lightning')">
                    <div class="tower-btn-icon">âš¡</div>
                    <div>ë²ˆê°œ íƒ€ì›Œ</div>
                    <div class="tower-btn-cost">ğŸ’° 80</div>
                </button>

                <button class="control-btn" id="startWaveBtn" onclick="startWave()">
                    ğŸš€ ì›¨ì´ë¸Œ ì‹œì‘
                </button>

                <div class="skills-panel">
                    <div class="skill-title">ğŸŒŸ ì˜êµ¬ ì—…ê·¸ë ˆì´ë“œ</div>
                    <div class="skill-grid" id="skillsGrid"></div>
                </div>
                
                <div style="background: rgba(255, 255, 255, 0.05); padding: 8px; border-radius: 8px; margin-top: 8px; font-size: 10px;">
                    <div style="font-weight: bold; margin-bottom: 4px;">ğŸ’¡ ì „ëµ íŒ</div>
                    <div style="opacity: 0.8; line-height: 1.4;">
                        ğŸ”¥ ë¶ˆ: ë²”ìœ„ ê³µê²©<br>
                        ğŸ’§ ë¬¼: ì  ë‘”í™”<br>
                        ğŸŒ¿ í’€: ì§€ì† ë… ë°ë¯¸ì§€<br>
                        âš¡ ë²ˆê°œ: ê°•ë ¥í•œ ë‹¨ì¼ íƒ€ê²Ÿ<br><br>
                        â€¢ ê¸¸ëª©ì— íƒ€ì›Œë¥¼ ì§‘ì¤‘ ë°°ì¹˜í•˜ì„¸ìš”<br>
                        â€¢ íƒ€ì›Œë¥¼ í´ë¦­í•˜ë©´ ì—…ê·¸ë ˆì´ë“œë‚˜ íŒë§¤í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤<br>
                        â€¢ ì›¨ì´ë¸Œ í´ë¦¬ì–´ ì‹œ ìŠ¤í‚¬ í¬ì¸íŠ¸ë¥¼ íšë“í•©ë‹ˆë‹¤<br>
                        â€¢ ì˜êµ¬ ì—…ê·¸ë ˆì´ë“œë¡œ ì ì  ê°•í•´ì§€ì„¸ìš”<br>
                        â€¢ ë³´ìŠ¤ëŠ” 5ì›¨ì´ë¸Œë§ˆë‹¤ ë“±ì¥í•©ë‹ˆë‹¤
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Game Configuration
        const GRID_SIZE = 8;
        const CELL_SIZE = 100 / GRID_SIZE;
        
        // Tower Types
        const TOWER_TYPES = {
            fire: {
                name: 'ë¶ˆ íƒ€ì›Œ',
                icon: 'ğŸ”¥',
                cost: 50,
                damage: 15,
                range: 1.5,
                attackSpeed: 1.0,
                projectileColor: '#ff4500',
                effect: 'splash', // Area damage
                upgradeCosts: [30, 60, 100]
            },
            water: {
                name: 'ë¬¼ íƒ€ì›Œ',
                icon: 'ğŸ’§',
                cost: 60,
                damage: 8,
                range: 2.0,
                attackSpeed: 1.5,
                projectileColor: '#1e90ff',
                effect: 'slow', // Slow enemies
                upgradeCosts: [35, 70, 120]
            },
            earth: {
                name: 'í’€ íƒ€ì›Œ',
                icon: 'ğŸŒ¿',
                cost: 70,
                damage: 5,
                range: 1.8,
                attackSpeed: 2.0,
                projectileColor: '#32cd32',
                effect: 'poison', // Damage over time
                upgradeCosts: [40, 80, 140]
            },
            lightning: {
                name: 'ë²ˆê°œ íƒ€ì›Œ',
                icon: 'âš¡',
                cost: 80,
                damage: 25,
                range: 2.5,
                attackSpeed: 0.6,
                projectileColor: '#ffff00',
                effect: 'single', // High single target
                upgradeCosts: [50, 100, 180]
            }
        };

        // Game State
        const gameState = {
            health: 100,
            gold: 200,
            wave: 1,
            skillPoints: 0,
            isWaveActive: false,
            selectedTowerType: null,
            towers: [],
            enemies: [],
            projectiles: [],
            grid: [],
            path: [],
            skills: {
                damage: 0,
                range: 0,
                startGold: 0,
                critChance: 0,
                goldBonus: 0
            },
            achievements: {
                firstTower: false,
                wave10: false,
                wave20: false,
                wave30: false,
                allElements: false,
                maxUpgrade: false,
                perfectDefense: false
            },
            totalKills: 0,
            totalDamage: 0,
            highestWave: 0
        };

        // Skills Database - Comprehensive permanent upgrades
        const SKILLS = [
            { id: 'damage', name: 'íƒ€ì›Œ ê³µê²©ë ¥', maxLevel: 10, costPerLevel: 1, effect: level => `+${level * 5}% ë°ë¯¸ì§€`, desc: 'ëª¨ë“  íƒ€ì›Œì˜ ê³µê²©ë ¥ì´ ì¦ê°€í•©ë‹ˆë‹¤' },
            { id: 'range', name: 'íƒ€ì›Œ ì‚¬ê±°ë¦¬', maxLevel: 5, costPerLevel: 2, effect: level => `+${level * 10}% ì‚¬ê±°ë¦¬`, desc: 'íƒ€ì›Œì˜ ê³µê²© ë²”ìœ„ê°€ ë„“ì–´ì§‘ë‹ˆë‹¤' },
            { id: 'startGold', name: 'ì‹œì‘ ê³¨ë“œ', maxLevel: 5, costPerLevel: 3, effect: level => `+${level * 50} ê³¨ë“œ`, desc: 'ê²Œì„ ì‹œì‘ ì‹œ ë” ë§ì€ ê³¨ë“œë¥¼ ê°€ì§€ê³  ì‹œì‘í•©ë‹ˆë‹¤' },
            { id: 'critChance', name: 'ì¹˜ëª…íƒ€ í™•ë¥ ', maxLevel: 5, costPerLevel: 2, effect: level => `+${level * 5}% í™•ë¥ `, desc: '2ë°° ë°ë¯¸ì§€ë¥¼ ì¤„ í™•ë¥ ì´ ì¦ê°€í•©ë‹ˆë‹¤' },
            { id: 'goldBonus', name: 'ê³¨ë“œ íšë“ëŸ‰', maxLevel: 10, costPerLevel: 1, effect: level => `+${level * 10}% ê³¨ë“œ`, desc: 'ì  ì²˜ì¹˜ ì‹œ ë” ë§ì€ ê³¨ë“œë¥¼ íšë“í•©ë‹ˆë‹¤' },
            { id: 'maxHealth', name: 'ìµœëŒ€ ìƒëª…ë ¥', maxLevel: 5, costPerLevel: 3, effect: level => `+${level * 20} HP`, desc: 'ê¸°ì§€ì˜ ìƒëª…ë ¥ì´ ì¦ê°€í•©ë‹ˆë‹¤' },
            { id: 'attackSpeed', name: 'ê³µê²© ì†ë„', maxLevel: 5, costPerLevel: 2, effect: level => `+${level * 10}% ì†ë„`, desc: 'íƒ€ì›Œì˜ ê³µê²© ì†ë„ê°€ ë¹¨ë¼ì§‘ë‹ˆë‹¤' },
            { id: 'specialChance', name: 'íŠ¹ìˆ˜ íš¨ê³¼', maxLevel: 5, costPerLevel: 2, effect: level => `+${level * 10}% íš¨ê³¼`, desc: 'íƒ€ì›Œì˜ íŠ¹ìˆ˜ íš¨ê³¼ ë°œë™ë¥ ì´ ì¦ê°€í•©ë‹ˆë‹¤' }
        ];
        
        // Enemy Types - Different enemy configurations for variety
        const ENEMY_TYPES = {
            normal: { 
                icon: 'ğŸ‘¾', 
                color: 'linear-gradient(135deg, #4a4a4a, #2a2a2a)', 
                healthMult: 1, 
                speedMult: 1, 
                valueMult: 1,
                size: 20,
                description: 'ì¼ë°˜ ëª¬ìŠ¤í„°'
            },
            fast: { 
                icon: 'ğŸƒ', 
                color: 'linear-gradient(135deg, #00d2ff, #3a7bd5)', 
                healthMult: 0.7, 
                speedMult: 1.5, 
                valueMult: 1.2,
                size: 18,
                description: 'ë¹ ë¥¸ ëª¬ìŠ¤í„°'
            },
            tank: { 
                icon: 'ğŸ›¡ï¸', 
                color: 'linear-gradient(135deg, #667eea, #764ba2)', 
                healthMult: 2, 
                speedMult: 0.7, 
                valueMult: 1.5,
                size: 24,
                description: 'íŠ¼íŠ¼í•œ ëª¬ìŠ¤í„°'
            },
            swarm: { 
                icon: 'ğŸ›', 
                color: 'linear-gradient(135deg, #f093fb, #f5576c)', 
                healthMult: 0.5, 
                speedMult: 1.3, 
                valueMult: 0.8,
                size: 16,
                description: 'êµ°ì§‘ ëª¬ìŠ¤í„°'
            },
            elite: { 
                icon: 'ğŸ‘¹', 
                color: 'linear-gradient(135deg, #ff6b6b, #ee5a6f)', 
                healthMult: 3, 
                speedMult: 1.1, 
                valueMult: 3,
                size: 28,
                description: 'ì—˜ë¦¬íŠ¸ ëª¬ìŠ¤í„°'
            },
            flying: { 
                icon: 'ğŸ¦‡', 
                color: 'linear-gradient(135deg, #a8edea, #fed6e3)', 
                healthMult: 0.8, 
                speedMult: 1.4, 
                valueMult: 1.3,
                size: 20,
                description: 'ë¹„í–‰ ëª¬ìŠ¤í„°'
            },
            regenerating: { 
                icon: 'ğŸ§Ÿ', 
                color: 'linear-gradient(135deg, #96fbc4, #f9f586)', 
                healthMult: 1.5, 
                speedMult: 0.9, 
                valueMult: 2,
                size: 22,
                description: 'ì¬ìƒ ëª¬ìŠ¤í„°',
                regen: true
            },
            boss: { 
                icon: 'ğŸ‘‘', 
                color: 'linear-gradient(135deg, #ff0000, #8b0000)', 
                healthMult: 10, 
                speedMult: 0.5, 
                valueMult: 10,
                size: 36,
                description: 'ë³´ìŠ¤ ëª¬ìŠ¤í„°'
            }
        };

        // Audio Context
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        function playSound(freq, duration, type = 'sine') {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.frequency.value = freq;
            osc.type = type;
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            osc.start(audioCtx.currentTime);
            osc.stop(audioCtx.currentTime + duration);
        }

        function playTowerPlaceSound() {
            playSound(440, 0.1);
            setTimeout(() => playSound(554, 0.1), 50);
        }

        function playShootSound() {
            playSound(800, 0.05, 'square');
        }

        function playHitSound() {
            playSound(200, 0.1, 'sawtooth');
        }

        function playWaveCompleteSound() {
            playSound(523, 0.1);
            setTimeout(() => playSound(659, 0.1), 100);
            setTimeout(() => playSound(784, 0.15), 200);
        }

        // Initialize Grid
        function initGrid() {
            const gridElement = document.getElementById('grid');
            gridElement.innerHTML = '';
            
            // Create path (snake pattern)
            gameState.path = [
                {x: 0, y: 3}, {x: 1, y: 3}, {x: 2, y: 3}, {x: 3, y: 3},
                {x: 3, y: 4}, {x: 3, y: 5},
                {x: 4, y: 5}, {x: 5, y: 5}, {x: 6, y: 5}, {x: 7, y: 5},
                {x: 7, y: 4}, {x: 7, y: 3},
                {x: 6, y: 3}, {x: 5, y: 3}, {x: 4, y: 3}
            ];
            
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.x = x;
                    cell.dataset.y = y;
                    
                    const isPath = gameState.path.some(p => p.x === x && p.y === y);
                    if (isPath) {
                        cell.classList.add('path');
                    } else {
                        cell.onclick = () => placeTower(x, y);
                    }
                    
                    gridElement.appendChild(cell);
                }
            }
        }

        function selectTower(type) {
            if (gameState.gold < TOWER_TYPES[type].cost) return;
            
            gameState.selectedTowerType = type;
            
            document.querySelectorAll('.tower-btn').forEach(btn => {
                btn.classList.remove('selected');
            });
            document.querySelector(`[data-type="${type}"]`).classList.add('selected');
        }

        function placeTower(x, y) {
            if (!gameState.selectedTowerType) return;
            
            const towerType = TOWER_TYPES[gameState.selectedTowerType];
            if (gameState.gold < towerType.cost) return;
            
            // Check if cell already has tower
            if (gameState.towers.some(t => t.x === x && t.y === y)) return;
            
            // Check if it's on path
            if (gameState.path.some(p => p.x === x && p.y === y)) return;
            
            gameState.gold -= towerType.cost;
            
            const damageBonus = 1 + (gameState.skills.damage * 0.05);
            const rangeBonus = 1 + (gameState.skills.range * 0.1);
            
            gameState.towers.push({
                x, y,
                type: gameState.selectedTowerType,
                level: 1,
                damage: towerType.damage * damageBonus,
                range: towerType.range * rangeBonus,
                attackSpeed: towerType.attackSpeed,
                lastAttack: 0,
                kills: 0
            });
            
            playTowerPlaceSound();
            gameState.selectedTowerType = null;
            document.querySelectorAll('.tower-btn').forEach(btn => btn.classList.remove('selected'));
            
            checkAchievements();
            updateUI();
        }

        function upgradeTower(tower) {
            const towerType = TOWER_TYPES[tower.type];
            const upgradeIndex = tower.level - 1;
            
            if (upgradeIndex >= towerType.upgradeCosts.length) return;
            
            const cost = towerType.upgradeCosts[upgradeIndex];
            if (gameState.gold < cost) return;
            
            gameState.gold -= cost;
            tower.level++;
            
            const damageBonus = 1 + (gameState.skills.damage * 0.05);
            const rangeBonus = 1 + (gameState.skills.range * 0.1);
            
            tower.damage = towerType.damage * tower.level * damageBonus;
            tower.range = (towerType.range + tower.level * 0.2) * rangeBonus;
            tower.attackSpeed = towerType.attackSpeed * (1 + tower.level * 0.1);
            
            playTowerPlaceSound();
            checkAchievements();
            updateUI();
        }

        function showTowerUpgradeModal(tower) {
            const towerType = TOWER_TYPES[tower.type];
            const upgradeIndex = tower.level - 1;
            
            if (upgradeIndex >= towerType.upgradeCosts.length) {
                showToast('âš ï¸ ìµœëŒ€ ë ˆë²¨ì…ë‹ˆë‹¤!');
                return;
            }
            
            const modal = document.createElement('div');
            modal.className = 'upgrade-modal';
            modal.innerHTML = `
                <div class="modal-content">
                    <div class="modal-header">
                        <div class="modal-icon">${towerType.icon}</div>
                        <div class="modal-title">${towerType.name} (Lv.${tower.level})</div>
                    </div>
                    <div class="upgrade-options">
                        <div class="upgrade-option" onclick="upgradeTower(gameState.towers.find(t => t.x === ${tower.x} && t.y === ${tower.y})); this.closest('.upgrade-modal').remove();">
                            <div class="upgrade-name">â¬†ï¸ ì—…ê·¸ë ˆì´ë“œ</div>
                            <div class="upgrade-desc">
                                ê³µê²©ë ¥: ${tower.damage.toFixed(1)} â†’ ${(tower.damage * 1.5).toFixed(1)}<br>
                                ì‚¬ê±°ë¦¬: ${tower.range.toFixed(1)} â†’ ${(tower.range + 0.2).toFixed(1)}
                            </div>
                            <div class="upgrade-cost">ğŸ’° ${towerType.upgradeCosts[upgradeIndex]} ê³¨ë“œ</div>
                        </div>
                        <div class="upgrade-option" onclick="sellTower(${tower.x}, ${tower.y}); this.closest('.upgrade-modal').remove();">
                            <div class="upgrade-name">ğŸ’µ íŒë§¤</div>
                            <div class="upgrade-desc">íƒ€ì›Œë¥¼ íŒë§¤í•˜ê³  ê³¨ë“œë¥¼ ëŒë ¤ë°›ìŠµë‹ˆë‹¤</div>
                            <div class="upgrade-cost">ğŸ’° +${Math.floor(towerType.cost * 0.7)} ê³¨ë“œ</div>
                        </div>
                    </div>
                    <button class="control-btn danger" onclick="this.closest('.upgrade-modal').remove();">ë‹«ê¸°</button>
                </div>
            `;
            document.body.appendChild(modal);
        }

        function sellTower(x, y) {
            const towerIndex = gameState.towers.findIndex(t => t.x === x && t.y === y);
            if (towerIndex === -1) return;
            
            const tower = gameState.towers[towerIndex];
            const towerType = TOWER_TYPES[tower.type];
            const refund = Math.floor(towerType.cost * 0.7);
            
            gameState.gold += refund;
            gameState.towers.splice(towerIndex, 1);
            
            playSound(300, 0.1);
            updateUI();
        }

        function startWave() {
            if (gameState.isWaveActive) return;
            
            gameState.isWaveActive = true;
            document.getElementById('startWaveBtn').disabled = true;
            
            const enemyCount = 10 + gameState.wave * 3;
            const enemyHealth = 20 + gameState.wave * 10;
            const isBossWave = gameState.wave % 5 === 0;
            
            let spawnedCount = 0;
            const spawnInterval = setInterval(() => {
                if (spawnedCount >= enemyCount) {
                    clearInterval(spawnInterval);
                    return;
                }
                
                const isElite = Math.random() < 0.15;
                const enemy = {
                    x: gameState.path[0].x,
                    y: gameState.path[0].y,
                    pathIndex: 0,
                    health: isElite ? enemyHealth * 2 : enemyHealth,
                    maxHealth: isElite ? enemyHealth * 2 : enemyHealth,
                    speed: isElite ? 0.015 : 0.02,
                    value: isElite ? 15 : 10,
                    isElite: isElite,
                    isBoss: false,
                    effects: {},
                    progress: 0
                };
                
                gameState.enemies.push(enemy);
                spawnedCount++;
            }, isBossWave ? 2000 : 1000);
            
            // Spawn boss
            if (isBossWave) {
                setTimeout(() => {
                    const boss = {
                        x: gameState.path[0].x,
                        y: gameState.path[0].y,
                        pathIndex: 0,
                        health: enemyHealth * 10,
                        maxHealth: enemyHealth * 10,
                        speed: 0.01,
                        value: 100,
                        isElite: false,
                        isBoss: true,
                        effects: {},
                        progress: 0
                    };
                    gameState.enemies.push(boss);
                }, 3000);
            }
        }

        function updateGame(deltaTime) {
            if (!gameState.isWaveActive) return;
            
            // Update enemies
            gameState.enemies.forEach((enemy, index) => {
                const slowFactor = enemy.effects.slow ? 0.5 : 1;
                enemy.progress += enemy.speed * slowFactor * deltaTime;
                
                // Handle poison damage
                if (enemy.effects.poison) {
                    enemy.health -= enemy.effects.poison.damage * deltaTime / 1000;
                    if (Date.now() > enemy.effects.poison.endTime) {
                        delete enemy.effects.poison;
                    }
                }
                
                // Remove slow effect
                if (enemy.effects.slow && Date.now() > enemy.effects.slow.endTime) {
                    delete enemy.effects.slow;
                }
                
                // Move along path
                while (enemy.progress >= 1 && enemy.pathIndex < gameState.path.length - 1) {
                    enemy.progress -= 1;
                    enemy.pathIndex++;
                }
                
                // Interpolate position
                if (enemy.pathIndex < gameState.path.length - 1) {
                    const current = gameState.path[enemy.pathIndex];
                    const next = gameState.path[enemy.pathIndex + 1];
                    enemy.x = current.x + (next.x - current.x) * enemy.progress;
                    enemy.y = current.y + (next.y - current.y) * enemy.progress;
                } else if (enemy.progress >= 1) {
                    // Enemy reached end
                    gameState.health--;
                    gameState.enemies.splice(index, 1);
                    playHitSound();
                    if (gameState.health <= 0) {
                        gameOver();
                    }
                }
                
                // Check if dead
                if (enemy.health <= 0) {
                    const goldBonus = 1 + (gameState.skills.goldBonus * 0.1);
                    gameState.gold += Math.floor(enemy.value * goldBonus);
                    gameState.totalKills++;
                    gameState.enemies.splice(index, 1);
                    createParticle(enemy.x, enemy.y, 'ğŸ’¥');
                    playHitSound();
                }
            });
            
            // Update towers
            const now = Date.now();
            gameState.towers.forEach(tower => {
                const towerType = TOWER_TYPES[tower.type];
                const cooldown = 1000 / tower.attackSpeed;
                
                if (now - tower.lastAttack < cooldown) return;
                
                // Find target
                let target = null;
                let minDist = Infinity;
                
                gameState.enemies.forEach(enemy => {
                    const dist = Math.sqrt(
                        Math.pow(enemy.x - tower.x, 2) + 
                        Math.pow(enemy.y - tower.y, 2)
                    );
                    if (dist <= tower.range && dist < minDist) {
                        minDist = dist;
                        target = enemy;
                    }
                });
                
                if (target) {
                    tower.lastAttack = now;
                    
                    // Create projectile
                    gameState.projectiles.push({
                        x: tower.x,
                        y: tower.y,
                        targetX: target.x,
                        targetY: target.y,
                        target: target,
                        damage: tower.damage,
                        type: tower.type,
                        speed: 0.1,
                        progress: 0
                    });
                    
                    playShootSound();
                }
            });
            
            // Update projectiles
            gameState.projectiles.forEach((proj, index) => {
                proj.progress += proj.speed;
                
                proj.x += (proj.targetX - proj.x) * proj.speed;
                proj.y += (proj.targetY - proj.y) * proj.speed;
                
                const dist = Math.sqrt(
                    Math.pow(proj.x - proj.targetX, 2) + 
                    Math.pow(proj.y - proj.targetY, 2)
                );
                
                if (dist < 0.3 || proj.progress >= 1) {
                    // Hit target
                    if (proj.target && gameState.enemies.includes(proj.target)) {
                        const critRoll = Math.random();
                        const isCrit = critRoll < (gameState.skills.critChance * 0.05);
                        const damage = proj.damage * (isCrit ? 2 : 1);
                        
                        proj.target.health -= damage;
                        gameState.totalDamage += damage;
                        
                        // Apply effects
                        const towerType = TOWER_TYPES[proj.type];
                        if (towerType.effect === 'splash') {
                            gameState.enemies.forEach(enemy => {
                                if (enemy === proj.target) return;
                                const dist = Math.sqrt(
                                    Math.pow(enemy.x - proj.target.x, 2) + 
                                    Math.pow(enemy.y - proj.target.y, 2)
                                );
                                if (dist < 1.0) {
                                    enemy.health -= damage * 0.5;
                                }
                            });
                        } else if (towerType.effect === 'slow') {
                            proj.target.effects.slow = { endTime: now + 2000 };
                        } else if (towerType.effect === 'poison') {
                            proj.target.effects.poison = { 
                                damage: proj.damage * 0.5, 
                                endTime: now + 3000 
                            };
                        }
                        
                        if (isCrit) {
                            createParticle(proj.x, proj.y, 'âš¡');
                        }
                    }
                    
                    gameState.projectiles.splice(index, 1);
                }
            });
            
            // Check wave completion
            if (gameState.enemies.length === 0 && gameState.isWaveActive) {
                gameState.isWaveActive = false;
                gameState.wave++;
                gameState.skillPoints++;
                
                if (gameState.wave > gameState.highestWave) {
                    gameState.highestWave = gameState.wave;
                }
                
                playWaveCompleteSound();
                showToast(`ğŸ‰ ì›¨ì´ë¸Œ ${gameState.wave - 1} í´ë¦¬ì–´! +1 ìŠ¤í‚¬ í¬ì¸íŠ¸`);
                
                document.getElementById('startWaveBtn').disabled = false;
                
                checkAchievements();
                saveGame();
            }
        }

        function createParticle(x, y, icon) {
            const gridElement = document.getElementById('grid');
            const rect = gridElement.getBoundingClientRect();
            const cellSize = rect.width / GRID_SIZE;
            
            const particle = document.createElement('div');
            particle.className = 'particle';
            particle.textContent = icon;
            particle.style.position = 'fixed';
            particle.style.left = (rect.left + x * cellSize) + 'px';
            particle.style.top = (rect.top + y * cellSize) + 'px';
            particle.style.fontSize = '20px';
            document.body.appendChild(particle);
            
            setTimeout(() => particle.remove(), 1000);
        }

        function upgradeSkill(skillId) {
            const skill = SKILLS.find(s => s.id === skillId);
            const currentLevel = gameState.skills[skillId];
            
            if (currentLevel >= skill.maxLevel) return;
            if (gameState.skillPoints < skill.costPerLevel) return;
            
            gameState.skillPoints -= skill.costPerLevel;
            gameState.skills[skillId]++;
            
            playSound(659, 0.15);
            updateUI();
            saveGame();
        }

        function showToast(message) {
            const toast = document.createElement('div');
            toast.className = 'achievement-toast';
            toast.textContent = message;
            document.body.appendChild(toast);
            
            setTimeout(() => {
                toast.style.animation = 'slideDown 0.5s ease-out reverse';
                setTimeout(() => toast.remove(), 500);
            }, 3000);
        }

        function checkAchievements() {
            const achievements = [
                { id: 'firstTower', check: () => gameState.towers.length > 0, message: 'ğŸ† ì²« íƒ€ì›Œ ê±´ì„¤!' },
                { id: 'wave10', check: () => gameState.wave >= 10, message: 'ğŸ† ì›¨ì´ë¸Œ 10 ë‹¬ì„±!' },
                { id: 'wave20', check: () => gameState.wave >= 20, message: 'ğŸ† ì›¨ì´ë¸Œ 20 ë‹¬ì„±!' },
                { id: 'wave30', check: () => gameState.wave >= 30, message: 'ğŸ† ì›¨ì´ë¸Œ 30 ë‹¬ì„±!' },
                { id: 'allElements', check: () => {
                    const types = new Set(gameState.towers.map(t => t.type));
                    return types.size === 4;
                }, message: 'ğŸ† ëª¨ë“  ì›ì†Œ ì‚¬ìš©!' },
                { id: 'maxUpgrade', check: () => gameState.towers.some(t => t.level >= 4), message: 'ğŸ† ìµœëŒ€ ì—…ê·¸ë ˆì´ë“œ!' }
            ];
            
            achievements.forEach(ach => {
                if (!gameState.achievements[ach.id] && ach.check()) {
                    gameState.achievements[ach.id] = true;
                    showToast(ach.message);
                }
            });
        }

        function gameOver() {
            showToast('ğŸ’€ ê²Œì„ ì˜¤ë²„! ë‹¤ì‹œ ì‹œì‘í•˜ì„¸ìš”.');
            setTimeout(() => {
                if (confirm('ê²Œì„ ì˜¤ë²„! ë‹¤ì‹œ ì‹œì‘í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                    resetGame();
                }
            }, 1000);
        }

        function resetGame() {
            gameState.health = 100;
            gameState.gold = 200 + (gameState.skills.startGold * 50);
            gameState.wave = 1;
            gameState.isWaveActive = false;
            gameState.towers = [];
            gameState.enemies = [];
            gameState.projectiles = [];
            gameState.totalKills = 0;
            gameState.totalDamage = 0;
            
            updateUI();
            saveGame();
        }

        function updateUI() {
            // Update stats
            document.getElementById('health').textContent = Math.max(0, gameState.health);
            document.getElementById('gold').textContent = Math.floor(gameState.gold);
            document.getElementById('wave').textContent = gameState.wave;
            document.getElementById('skillPoints').textContent = gameState.skillPoints;
            document.getElementById('waveNumber').textContent = gameState.wave;
            
            // Update tower buttons
            Object.keys(TOWER_TYPES).forEach(type => {
                const btn = document.querySelector(`[data-type="${type}"]`);
                const canAfford = gameState.gold >= TOWER_TYPES[type].cost;
                btn.disabled = !canAfford;
            });
            
            // Update skills
            const skillsGrid = document.getElementById('skillsGrid');
            skillsGrid.innerHTML = SKILLS.map(skill => {
                const currentLevel = gameState.skills[skill.id];
                const canUpgrade = currentLevel < skill.maxLevel && gameState.skillPoints >= skill.costPerLevel;
                
                return `
                    <div class="skill-item">
                        <div class="skill-info">
                            <div class="skill-name">${skill.name}</div>
                            <div class="skill-level">Lv.${currentLevel}/${skill.maxLevel} - ${skill.effect(currentLevel)}</div>
                        </div>
                        <button class="skill-upgrade-btn" 
                                onclick="upgradeSkill('${skill.id}')"
                                ${!canUpgrade ? 'disabled' : ''}>
                            â­ ${skill.costPerLevel}
                        </button>
                    </div>
                `;
            }).join('');
            
            // Render grid
            renderGrid();
        }

        function renderGrid() {
            const gridElement = document.getElementById('grid');
            const rect = gridElement.getBoundingClientRect();
            const cellSize = rect.width / GRID_SIZE;
            
            // Clear existing towers and enemies
            gridElement.querySelectorAll('.tower-icon, .enemy, .projectile, .tower-level').forEach(el => el.remove());
            
            // Render towers
            gameState.towers.forEach(tower => {
                const cell = gridElement.querySelector(`[data-x="${tower.x}"][data-y="${tower.y}"]`);
                if (!cell) return;
                
                cell.classList.add('tower');
                
                const icon = document.createElement('div');
                icon.className = 'tower-icon';
                icon.textContent = TOWER_TYPES[tower.type].icon;
                cell.appendChild(icon);
                
                if (tower.level > 1) {
                    const level = document.createElement('div');
                    level.className = 'tower-level';
                    level.textContent = tower.level;
                    cell.appendChild(level);
                }
                
                cell.onclick = () => showTowerUpgradeModal(tower);
            });
            
            // Render enemies
            gameState.enemies.forEach(enemy => {
                const enemyEl = document.createElement('div');
                enemyEl.className = 'enemy';
                
                const size = enemy.isBoss ? 32 : (enemy.isElite ? 24 : 20);
                enemyEl.style.width = size + 'px';
                enemyEl.style.height = size + 'px';
                enemyEl.style.left = (enemy.x * cellSize + cellSize / 2 - size / 2) + 'px';
                enemyEl.style.top = (enemy.y * cellSize + cellSize / 2 - size / 2) + 'px';
                
                if (enemy.isBoss) {
                    enemyEl.style.background = 'linear-gradient(135deg, #ff0000, #8b0000)';
                    enemyEl.textContent = 'ğŸ‘‘';
                } else if (enemy.isElite) {
                    enemyEl.style.background = 'linear-gradient(135deg, #ff6b6b, #ee5a6f)';
                    enemyEl.textContent = 'ğŸ‘¹';
                } else {
                    enemyEl.style.background = 'linear-gradient(135deg, #4a4a4a, #2a2a2a)';
                    enemyEl.textContent = 'ğŸ‘¾';
                }
                
                // Health bar
                const healthBar = document.createElement('div');
                healthBar.className = 'health-bar';
                const healthFill = document.createElement('div');
                healthFill.className = 'health-bar-fill';
                healthFill.style.width = (enemy.health / enemy.maxHealth * 100) + '%';
                healthBar.appendChild(healthFill);
                enemyEl.appendChild(healthBar);
                
                gridElement.appendChild(enemyEl);
            });
            
            // Render projectiles
            gameState.projectiles.forEach(proj => {
                const projEl = document.createElement('div');
                projEl.className = 'projectile';
                projEl.style.left = (proj.x * cellSize + cellSize / 2) + 'px';
                projEl.style.top = (proj.y * cellSize + cellSize / 2) + 'px';
                projEl.style.background = TOWER_TYPES[proj.type].projectileColor;
                projEl.style.boxShadow = `0 0 10px ${TOWER_TYPES[proj.type].projectileColor}`;
                gridElement.appendChild(projEl);
            });
        }

        function saveGame() {
            localStorage.setItem('elementalTD', JSON.stringify({
                skills: gameState.skills,
                achievements: gameState.achievements,
                highestWave: gameState.highestWave,
                totalKills: gameState.totalKills,
                totalDamage: gameState.totalDamage
            }));
        }

        function loadGame() {
            const saved = localStorage.getItem('elementalTD');
            if (saved) {
                const data = JSON.parse(saved);
                gameState.skills = data.skills || gameState.skills;
                gameState.achievements = data.achievements || gameState.achievements;
                gameState.highestWave = data.highestWave || 0;
                gameState.totalKills = data.totalKills || 0;
                gameState.totalDamage = data.totalDamage || 0;
            }
            
            gameState.gold = 200 + (gameState.skills.startGold * 50);
        }

        // Game loop
        let lastTime = Date.now();
        function gameLoop() {
            const now = Date.now();
            const deltaTime = now - lastTime;
            lastTime = now;
            
            updateGame(deltaTime);
            updateUI();
            
            requestAnimationFrame(gameLoop);
        }

        // Initialize
        initGrid();
        loadGame();
        updateUI();
        gameLoop();
        
        // Save on unload
        window.addEventListener('beforeunload', saveGame);
    </script>
</body>
</html>