<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
<title>üè≠ Golem Workshop - Í≥®Î†ò Í≥µÎ∞© ÌÉÄÏù¥Ïø§</title>
<style>
*{margin:0;padding:0;box-sizing:border-box;-webkit-user-select:none;user-select:none;-webkit-touch-callout:none}
html,body{width:100%;height:100%;overflow:hidden;background:#1a1020;font-family:'Segoe UI',sans-serif;touch-action:none}
canvas{display:block;width:100%;height:100%}
#ui-overlay{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:10}
.panel{pointer-events:auto;position:absolute;background:rgba(20,12,30,0.95);border:2px solid #8b5cf6;border-radius:16px;padding:20px;color:#e8e0f0;display:none;z-index:20;box-shadow:0 0 30px rgba(139,92,246,0.3)}
.panel.active{display:block}
.panel h2{text-align:center;font-size:1.3rem;margin-bottom:15px;color:#c4b5fd}
.panel-close{position:absolute;top:10px;right:14px;background:none;border:none;color:#f87171;font-size:1.5rem;cursor:pointer;pointer-events:auto}
.btn{background:linear-gradient(135deg,#7c3aed,#6d28d9);color:#fff;border:none;border-radius:10px;padding:10px 18px;font-size:0.9rem;cursor:pointer;transition:all 0.15s;pointer-events:auto;font-weight:600}
.btn:hover{transform:scale(1.05);box-shadow:0 0 15px rgba(139,92,246,0.5)}
.btn:active{transform:scale(0.95)}
.btn:disabled{opacity:0.4;transform:none;cursor:not-allowed}
.btn-sm{padding:6px 12px;font-size:0.8rem;border-radius:8px}
.upgrade-row{display:flex;justify-content:space-between;align-items:center;padding:10px 0;border-bottom:1px solid rgba(139,92,246,0.2)}
.upgrade-row:last-child{border-bottom:none}
.upgrade-info{flex:1;margin-right:10px}
.upgrade-info .name{font-weight:600;color:#c4b5fd;font-size:0.95rem}
.upgrade-info .desc{font-size:0.75rem;color:#9ca3af;margin-top:2px}
.stage-obj{padding:8px 0;border-bottom:1px solid rgba(139,92,246,0.15);font-size:0.85rem}
.stage-obj .done{color:#34d399}
.stage-obj .pending{color:#fbbf24}
.toast{position:fixed;top:20%;left:50%;transform:translateX(-50%);background:rgba(139,92,246,0.9);color:#fff;padding:12px 24px;border-radius:12px;font-size:1rem;font-weight:700;z-index:100;pointer-events:none;animation:toastAnim 2s forwards}
@keyframes toastAnim{0%{opacity:0;transform:translateX(-50%) translateY(20px)}10%{opacity:1;transform:translateX(-50%) translateY(0)}80%{opacity:1}100%{opacity:0;transform:translateX(-50%) translateY(-30px)}}
#loading{position:fixed;top:0;left:0;width:100%;height:100%;background:#1a1020;display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:999;color:#c4b5fd;font-size:1.5rem;gap:15px;transition:opacity 0.5s}
#loading .spinner{width:50px;height:50px;border:4px solid rgba(139,92,246,0.3);border-top:4px solid #8b5cf6;border-radius:50%;animation:spin 0.8s linear infinite}
@keyframes spin{to{transform:rotate(360deg)}}
</style>
</head>
<body>
<div id="loading"><div class="spinner"></div><div>Í≥®Î†ò Í≥µÎ∞© Î°úÎî©Ï§ë...</div></div>
<canvas id="game"></canvas>
<div id="ui-overlay">
  <div id="upgrade-panel" class="panel">
    <button class="panel-close" onclick="togglePanel('upgrade-panel')">&times;</button>
    <h2>‚öíÔ∏è Í≥µÎ∞© ÏóÖÍ∑∏Î†àÏù¥Îìú</h2>
    <div id="upgrade-list"></div>
  </div>
  <div id="stage-panel" class="panel">
    <button class="panel-close" onclick="togglePanel('stage-panel')">&times;</button>
    <h2>üìú Ïä§ÌÖåÏù¥ÏßÄ Î™©Ìëú</h2>
    <div id="stage-info"></div>
  </div>
  <div id="deploy-panel" class="panel">
    <button class="panel-close" onclick="togglePanel('deploy-panel')">&times;</button>
    <h2>üèóÔ∏è Í≥®Î†ò Î∞∞Ïπò</h2>
    <div id="deploy-info"></div>
  </div>
  <div id="offline-panel" class="panel">
    <button class="panel-close" onclick="togglePanel('offline-panel')">&times;</button>
    <h2>üí§ Ïò§ÌîÑÎùºÏù∏ ÏàòÏùµ</h2>
    <div id="offline-info" style="text-align:center;font-size:1.1rem;line-height:2"></div>
  </div>
</div>
<script>
'use strict';
// ============================================================
// GOLEM WORKSHOP - Tycoon + Merge Hybrid Game
// ============================================================

const C = document.getElementById('game');
const ctx = C.getContext('2d');
let W, H, SCALE;
let GRID_X, GRID_Y, CELL;
const COLS = 5, ROWS = 4;

// --- COLORS ---
const COLORS = {
  bg: '#1a1020', bgGrad1: '#1a1020', bgGrad2: '#2d1b4e',
  grid: '#2a1f3d', gridLine: '#3d2d5c', gridHighlight: '#5b3f8f',
  gold: '#fbbf24', goldDark: '#d97706',
  hud: 'rgba(15,10,25,0.85)', hudBorder: '#4c1d95',
  matDirt: '#8B6914', matDirtL: '#a87d20', matStone: '#7f8c8d', matStoneL: '#95a5a6',
  matIron: '#5c6670', matIronL: '#7f8fa6', matCrystal: '#9b59b6', matCrystalL: '#be7ddb',
  common: '#9ca3af', rare: '#3b82f6', epic: '#a855f7', legendary: '#f59e0b',
  btnSpawn: '#4c1d95', btnSpawnH: '#6d28d9',
  mine: '#d97706', battle: '#dc2626', shop: '#059669',
  text: '#e8e0f0', textDim: '#8b80a0', textBright: '#fff',
  particle: ['#fbbf24','#f59e0b','#8b5cf6','#c084fc','#34d399','#f87171','#60a5fa']
};

// --- MATERIAL & GOLEM DEFINITIONS ---
const MAT_TYPES = ['dirt','stone','iron','crystal'];
const MAT_NAMES = {dirt:'Ìùô',stone:'Îèå',iron:'Ï≤†',crystal:'ÌÅ¨Î¶¨Ïä§ÌÉà'};
const MAT_COLORS = {dirt:COLORS.matDirt,stone:COLORS.matStone,iron:COLORS.matIron,crystal:COLORS.matCrystal};
const MAT_COLORS_L = {dirt:COLORS.matDirtL,stone:COLORS.matStoneL,iron:COLORS.matIronL,crystal:COLORS.matCrystalL};
const MAT_EMOJIS = {dirt:'üü§',stone:'‚ö™',iron:'‚¨õ',crystal:'üíé'};
const MAT_TIERS = ['Ï°∞Í∞Å','Îç©Ïñ¥Î¶¨','ÏàúÏàò'];
const GRADE_NAMES = ['Common','Rare','Epic','Legendary'];
const GRADE_COLORS = [COLORS.common, COLORS.rare, COLORS.epic, COLORS.legendary];
const GOLEM_NAMES = {dirt:'ÎåÄÏßÄ Í≥®Î†ò',stone:'Î∞îÏúÑ Í≥®Î†ò',iron:'Í∞ïÏ≤† Í≥®Î†ò',crystal:'ÏàòÏ†ï Í≥®Î†ò'};
const GOLEM_EMOJIS = {dirt:'üóø',stone:'‚õ∞Ô∏è',iron:'ü§ñ',crystal:'üí†'};

// --- SOUNDS ---
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let audioCtx = null;
function initAudio(){if(!audioCtx) audioCtx = new AudioCtx();}
function playSound(type){
  if(!audioCtx) return;
  try{
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain); gain.connect(audioCtx.destination);
    const t = audioCtx.currentTime;
    switch(type){
      case 'spawn':
        osc.type='sine'; osc.frequency.setValueAtTime(400,t); osc.frequency.exponentialRampToValueAtTime(600,t+0.1);
        gain.gain.setValueAtTime(0.15,t); gain.gain.exponentialRampToValueAtTime(0.001,t+0.15);
        osc.start(t); osc.stop(t+0.15); break;
      case 'merge':
        osc.type='triangle'; osc.frequency.setValueAtTime(300,t); osc.frequency.exponentialRampToValueAtTime(800,t+0.2);
        gain.gain.setValueAtTime(0.2,t); gain.gain.exponentialRampToValueAtTime(0.001,t+0.25);
        osc.start(t); osc.stop(t+0.25); break;
      case 'golem':
        osc.type='sawtooth'; osc.frequency.setValueAtTime(200,t);
        osc.frequency.exponentialRampToValueAtTime(500,t+0.15);
        osc.frequency.exponentialRampToValueAtTime(800,t+0.3);
        gain.gain.setValueAtTime(0.15,t); gain.gain.exponentialRampToValueAtTime(0.001,t+0.4);
        osc.start(t); osc.stop(t+0.4); break;
      case 'legendary':
        for(let i=0;i<3;i++){
          const o2=audioCtx.createOscillator(), g2=audioCtx.createGain();
          o2.connect(g2);g2.connect(audioCtx.destination);
          o2.type='square'; o2.frequency.setValueAtTime(300+i*200,t+i*0.12);
          o2.frequency.exponentialRampToValueAtTime(600+i*200,t+i*0.12+0.15);
          g2.gain.setValueAtTime(0.1,t+i*0.12); g2.gain.exponentialRampToValueAtTime(0.001,t+i*0.12+0.2);
          o2.start(t+i*0.12); o2.stop(t+i*0.12+0.2);
        } return;
      case 'deploy':
        osc.type='sine'; osc.frequency.setValueAtTime(500,t); osc.frequency.exponentialRampToValueAtTime(700,t+0.1);
        osc.frequency.exponentialRampToValueAtTime(500,t+0.2);
        gain.gain.setValueAtTime(0.12,t); gain.gain.exponentialRampToValueAtTime(0.001,t+0.25);
        osc.start(t); osc.stop(t+0.25); break;
      case 'upgrade':
        osc.type='triangle'; osc.frequency.setValueAtTime(600,t); osc.frequency.exponentialRampToValueAtTime(900,t+0.1);
        osc.frequency.exponentialRampToValueAtTime(1200,t+0.2);
        gain.gain.setValueAtTime(0.15,t); gain.gain.exponentialRampToValueAtTime(0.001,t+0.3);
        osc.start(t); osc.stop(t+0.3); break;
      case 'stageComplete':
        for(let i=0;i<5;i++){
          const o2=audioCtx.createOscillator(), g2=audioCtx.createGain();
          o2.connect(g2);g2.connect(audioCtx.destination);
          o2.type='sine'; o2.frequency.setValueAtTime(400+i*100,t+i*0.1);
          g2.gain.setValueAtTime(0.12,t+i*0.1); g2.gain.exponentialRampToValueAtTime(0.001,t+i*0.1+0.15);
          o2.start(t+i*0.1); o2.stop(t+i*0.1+0.15);
        } return;
      case 'click':
        osc.type='sine'; osc.frequency.setValueAtTime(800,t);
        gain.gain.setValueAtTime(0.08,t); gain.gain.exponentialRampToValueAtTime(0.001,t+0.05);
        osc.start(t); osc.stop(t+0.05); break;
      case 'error':
        osc.type='square'; osc.frequency.setValueAtTime(200,t); osc.frequency.exponentialRampToValueAtTime(100,t+0.15);
        gain.gain.setValueAtTime(0.12,t); gain.gain.exponentialRampToValueAtTime(0.001,t+0.2);
        osc.start(t); osc.stop(t+0.2); break;
      case 'collect':
        osc.type='sine'; osc.frequency.setValueAtTime(600,t); osc.frequency.exponentialRampToValueAtTime(1000,t+0.08);
        gain.gain.setValueAtTime(0.1,t); gain.gain.exponentialRampToValueAtTime(0.001,t+0.12);
        osc.start(t); osc.stop(t+0.12); break;
      default:
        osc.type='sine'; osc.frequency.setValueAtTime(440,t);
        gain.gain.setValueAtTime(0.1,t); gain.gain.exponentialRampToValueAtTime(0.001,t+0.1);
        osc.start(t); osc.stop(t+0.1);
    }
  }catch(e){}
}

// --- PARTICLES ---
let particles = [];
function spawnParticles(x, y, count, color, spread, life){
  for(let i=0;i<count;i++){
    const angle = Math.random()*Math.PI*2;
    const speed = Math.random()*spread+spread*0.3;
    particles.push({
      x, y, vx:Math.cos(angle)*speed, vy:Math.sin(angle)*speed-1,
      life: life||60, maxLife: life||60,
      size: Math.random()*4+2,
      color: color || COLORS.particle[Math.floor(Math.random()*COLORS.particle.length)],
      gravity: 0.05
    });
  }
}
function spawnMergeParticles(x, y, grade){
  const count = 15 + grade*10;
  const colors = [COLORS.particle[4], GRADE_COLORS[grade], '#fff'];
  for(let i=0;i<count;i++){
    const angle = Math.random()*Math.PI*2;
    const speed = Math.random()*4+2;
    particles.push({
      x, y, vx:Math.cos(angle)*speed, vy:Math.sin(angle)*speed,
      life:40+Math.random()*30, maxLife:70,
      size: Math.random()*5+2,
      color: colors[Math.floor(Math.random()*colors.length)],
      gravity: -0.02
    });
  }
}
function updateParticles(){
  for(let i=particles.length-1;i>=0;i--){
    const p=particles[i];
    p.x+=p.vx; p.y+=p.vy; p.vy+=p.gravity;
    p.vx*=0.98; p.life--;
    if(p.life<=0) particles.splice(i,1);
  }
}
function drawParticles(){
  for(const p of particles){
    const alpha = p.life/p.maxLife;
    ctx.globalAlpha=alpha;
    ctx.fillStyle=p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size*alpha, 0, Math.PI*2);
    ctx.fill();
  }
  ctx.globalAlpha=1;
}

// --- SCREEN SHAKE ---
let shakeAmount = 0;
let shakeDecay = 0.9;
function triggerShake(amount){shakeAmount=Math.max(shakeAmount,amount);}

// --- FLOATING TEXT ---
let floatingTexts = [];
function addFloatingText(x, y, text, color, size){
  floatingTexts.push({x, y, text, color: color||'#fbbf24', size: size||16, life:60, maxLife:60});
}
function updateFloatingTexts(){
  for(let i=floatingTexts.length-1;i>=0;i--){
    const ft=floatingTexts[i];
    ft.y-=1; ft.life--;
    if(ft.life<=0) floatingTexts.splice(i,1);
  }
}
function drawFloatingTexts(){
  for(const ft of floatingTexts){
    const alpha=ft.life/ft.maxLife;
    ctx.globalAlpha=alpha;
    ctx.fillStyle=ft.color;
    ctx.font=`bold ${ft.size}px sans-serif`;
    ctx.textAlign='center';
    ctx.fillText(ft.text, ft.x, ft.y);
  }
  ctx.globalAlpha=1;
}

// --- TOAST ---
function showToast(msg){
  const el=document.createElement('div');
  el.className='toast'; el.textContent=msg;
  document.body.appendChild(el);
  setTimeout(()=>el.remove(), 2100);
}

// --- GAME STATE ---
const DEFAULT_STATE = {
  gold: 50,
  materials: {dirt:5, stone:3, iron:0, crystal:0},
  grid: new Array(COLS*ROWS).fill(null), // each: {type:'material'|'golem', matType, tier, grade}
  deployed: {mine:[], battle:[], shop:[]}, // each: {matType, grade}
  upgrades: {gridSize:0, craftSpeed:0, autoSpawn:0, deploySlots:0, offlineBonus:0, materialBoost:0},
  stage: 1,
  totalGolemsCreated: 0,
  totalMerges: 0,
  totalGoldEarned: 0,
  lastSave: Date.now(),
  tutorialDone: false,
  unlockedMats: ['dirt','stone']
};
let state;

function getDeployCapacity(type){
  return 2 + state.upgrades.deploySlots;
}
function getGridSize(){ return COLS * ROWS; }
function getCraftSpeedMult(){ return 1 + state.upgrades.craftSpeed * 0.3; }
function getAutoSpawnInterval(){ return state.upgrades.autoSpawn > 0 ? Math.max(3000, 8000 - state.upgrades.autoSpawn*1500) : 0; }
function getOfflineMult(){ return 0.3 + state.upgrades.offlineBonus * 0.15; }
function getMaterialBoostMult(){ return 1 + state.upgrades.materialBoost * 0.25; }

// --- STAGES ---
const STAGES = [
  {id:1, name:'Í≤¨Ïäµ Í≥µÎ∞©ÏÇ¨', objectives:[{type:'golem',count:1,desc:'Í≥®Î†ò 1Ï≤¥ Ï†úÏûë'}], reward:{gold:100}},
  {id:2, name:'Ï¥àÎ≥¥ Í≥®Î†òÏû•Ïù∏', objectives:[{type:'golem',count:3,desc:'Í≥®Î†ò 3Ï≤¥ Ï†úÏûë'},{type:'gold',count:200,desc:'Í≥®Îìú 200 Îã¨ÏÑ±'}], reward:{gold:200,unlock:'iron'}},
  {id:3, name:'Í¥ëÏÇ∞ Í∞úÏ≤ôÏûê', objectives:[{type:'deploy',zone:'mine',count:2,desc:'Í¥ëÏÇ∞Ïóê Í≥®Î†ò 2Ï≤¥ Î∞∞Ïπò'},{type:'golem',count:5,desc:'Í≥®Î†ò 5Ï≤¥ Ï†úÏûë'}], reward:{gold:300}},
  {id:4, name:'Ï†ÑÌà¨ ÏÇ¨Î†πÍ¥Ä', objectives:[{type:'deploy',zone:'battle',count:2,desc:'Ï†ÑÌà¨Ïóê Í≥®Î†ò 2Ï≤¥ Î∞∞Ïπò'},{type:'merge',count:10,desc:'Î®∏ÏßÄ 10Ìöå'}], reward:{gold:500,unlock:'crystal'}},
  {id:5, name:'ÏÉÅÏù∏ Í≥®Î†ò', objectives:[{type:'deploy',zone:'shop',count:2,desc:'Í∞ÄÍ≤åÏóê Í≥®Î†ò 2Ï≤¥ Î∞∞Ïπò'},{type:'gold',count:1000,desc:'Í≥®Îìú 1000 Îã¨ÏÑ±'}], reward:{gold:800}},
  {id:6, name:'Ìù¨Í∑Ä Í≥®Î†ò Ïó∞Íµ¨', objectives:[{type:'gradeGolem',grade:1,count:1,desc:'Rare Í≥®Î†ò 1Ï≤¥ Ìï©ÏÑ±'},{type:'golem',count:10,desc:'Í≥®Î†ò 10Ï≤¥ Ï†úÏûë'}], reward:{gold:1000}},
  {id:7, name:'Í¥ëÏÇ∞Ïôï', objectives:[{type:'deploy',zone:'mine',count:3,desc:'Í¥ëÏÇ∞Ïóê Í≥®Î†ò 3Ï≤¥ Î∞∞Ïπò'},{type:'gold',count:3000,desc:'Í≥®Îìú 3000 Îã¨ÏÑ±'}], reward:{gold:1500}},
  {id:8, name:'ÏóêÌîΩ Ïó∞Í∏àÏà†', objectives:[{type:'gradeGolem',grade:2,count:1,desc:'Epic Í≥®Î†ò 1Ï≤¥ Ìï©ÏÑ±'},{type:'merge',count:30,desc:'Î®∏ÏßÄ 30Ìöå'}], reward:{gold:2000}},
  {id:9, name:'Í≥®Î†ò Íµ∞Îã®', objectives:[{type:'golem',count:25,desc:'Í≥®Î†ò 25Ï≤¥ Ï†úÏûë'},{type:'deploy',zone:'battle',count:3,desc:'Ï†ÑÌà¨Ïóê Í≥®Î†ò 3Ï≤¥ Î∞∞Ïπò'}], reward:{gold:3000}},
  {id:10, name:'Ï†ÑÏÑ§Ïùò Í≥µÎ∞©Ïû•', objectives:[{type:'gradeGolem',grade:3,count:1,desc:'Legendary Í≥®Î†ò Ìï©ÏÑ±!'},{type:'gold',count:10000,desc:'Í≥®Îìú 10000 Îã¨ÏÑ±'}], reward:{gold:5000}},
  {id:11, name:'Í≥®Î†ò ÎßàÏä§ÌÑ∞', objectives:[{type:'golem',count:50,desc:'Í≥®Î†ò 50Ï≤¥ Ï†úÏûë'},{type:'merge',count:100,desc:'Î®∏ÏßÄ 100Ìöå'}], reward:{gold:8000}},
  {id:12, name:'Î¨¥Ìïú Í≥µÎ∞©', objectives:[{type:'gold',count:50000,desc:'Í≥®Îìú 50000 Îã¨ÏÑ±'}], reward:{gold:15000}},
];

function getStage(){ return STAGES[Math.min(state.stage-1, STAGES.length-1)]; }
function checkStageComplete(){
  const s = getStage();
  if(!s) return false;
  for(const obj of s.objectives){
    if(!isObjectiveMet(obj)) return false;
  }
  return true;
}
function isObjectiveMet(obj){
  switch(obj.type){
    case 'golem': return state.totalGolemsCreated >= obj.count;
    case 'gold': return state.gold >= obj.count;
    case 'merge': return state.totalMerges >= obj.count;
    case 'deploy':
      return state.deployed[obj.zone].length >= obj.count;
    case 'gradeGolem':
      const allGolems = [...state.grid.filter(c=>c&&c.type==='golem'), ...state.deployed.mine, ...state.deployed.battle, ...state.deployed.shop];
      return allGolems.some(g=>g.grade>=obj.grade);
    default: return false;
  }
}
function advanceStage(){
  const s = getStage();
  if(!s) return;
  state.gold += s.reward.gold;
  state.totalGoldEarned += s.reward.gold;
  if(s.reward.unlock && !state.unlockedMats.includes(s.reward.unlock)){
    state.unlockedMats.push(s.reward.unlock);
    showToast(`üîì ÏÉà Ïû¨Î£å Ìï¥Í∏à: ${MAT_NAMES[s.reward.unlock]}!`);
  }
  state.stage++;
  playSound('stageComplete');
  triggerShake(8);
  showToast(`üéâ Ïä§ÌÖåÏù¥ÏßÄ ${s.id} ÌÅ¥Î¶¨Ïñ¥! +${s.reward.gold}G`);
  spawnParticles(W/2, H/2, 50, '#fbbf24', 5, 80);
  saveGame();
}

// --- UPGRADES ---
const UPGRADES = [
  {key:'craftSpeed', name:'‚ö° Ï†úÏûë ÏÜçÎèÑ', desc:'Ïû¨Î£å ÏûêÎèô ÏÉùÏÑ± ÏÜçÎèÑ Ï¶ùÍ∞Ä', baseCost:100, costMult:1.8, max:10},
  {key:'autoSpawn', name:'üîÑ ÏûêÎèô ÏÉùÏÑ±', desc:'Ïû¨Î£åÍ∞Ä ÏûêÎèôÏúºÎ°ú ÏÉùÏÑ±Îê©ÎãàÎã§', baseCost:200, costMult:2, max:5},
  {key:'deploySlots', name:'üì¶ Î∞∞Ïπò Ïä¨Î°Ø', desc:'Í∞Å Íµ¨Ïó≠Ïóê Î∞∞Ïπò Í∞ÄÎä•Ìïú Ïä¨Î°Ø +1', baseCost:300, costMult:2.5, max:4},
  {key:'offlineBonus', name:'üí§ Ïò§ÌîÑÎùºÏù∏ Î≥¥ÎÑàÏä§', desc:'Ïò§ÌîÑÎùºÏù∏ ÏàòÏùµ Î∞∞Ïú® Ï¶ùÍ∞Ä', baseCost:250, costMult:2, max:5},
  {key:'materialBoost', name:'üìà Ïû¨Î£å Î∂ÄÏä§Ìä∏', desc:'Ïû¨Î£å ÏÉùÏÇ∞Îüâ Ï¶ùÍ∞Ä', baseCost:150, costMult:1.7, max:8},
];
function getUpgradeCost(upg){
  return Math.floor(upg.baseCost * Math.pow(upg.costMult, state.upgrades[upg.key]));
}

// --- INCOME CALCULATION ---
function calcIncome(){
  let goldPerSec = 0;
  let matsPerSec = {dirt:0,stone:0,iron:0,crystal:0};
  const boost = getMaterialBoostMult();
  // Mine: produces materials
  for(const g of state.deployed.mine){
    const base = (g.grade+1) * 0.5 * boost;
    matsPerSec[g.matType] += base;
  }
  // Battle: produces gold
  for(const g of state.deployed.battle){
    goldPerSec += (g.grade+1) * 2 * boost;
  }
  // Shop: produces gold (more)
  for(const g of state.deployed.shop){
    goldPerSec += (g.grade+1) * 3 * boost;
  }
  return {goldPerSec, matsPerSec};
}

// --- INCOME TIMER ---
let incomeTimer = 0;
const INCOME_INTERVAL = 1; // every second
function processIncome(dt){
  incomeTimer += dt;
  if(incomeTimer >= INCOME_INTERVAL){
    incomeTimer -= INCOME_INTERVAL;
    const income = calcIncome();
    if(income.goldPerSec > 0){
      state.gold += income.goldPerSec;
      state.totalGoldEarned += income.goldPerSec;
    }
    for(const mat of MAT_TYPES){
      if(income.matsPerSec[mat] > 0){
        state.materials[mat] += income.matsPerSec[mat];
      }
    }
  }
}

// --- AUTO SPAWN ---
let autoSpawnTimer = 0;
function processAutoSpawn(dt){
  const interval = getAutoSpawnInterval();
  if(interval <= 0) return;
  autoSpawnTimer += dt*1000;
  if(autoSpawnTimer >= interval){
    autoSpawnTimer -= interval;
    const available = state.unlockedMats.filter(m=>true);
    if(available.length > 0){
      const mat = available[Math.floor(Math.random()*available.length)];
      const emptyIdx = state.grid.findIndex(c=>c===null);
      if(emptyIdx >= 0){
        state.grid[emptyIdx] = {type:'material', matType:mat, tier:0};
        const pos = gridIdxToPos(emptyIdx);
        spawnParticles(pos.x, pos.y, 8, MAT_COLORS[mat], 2, 30);
      }
    }
  }
}

// --- OFFLINE EARNINGS ---
function calcOfflineEarnings(){
  const now = Date.now();
  const elapsed = (now - state.lastSave) / 1000; // seconds
  if(elapsed < 60) return null; // less than 1 min
  const maxHours = 8;
  const cappedSec = Math.min(elapsed, maxHours*3600);
  const income = calcIncome();
  const mult = getOfflineMult();
  const goldEarned = Math.floor(income.goldPerSec * cappedSec * mult);
  const matsEarned = {};
  for(const m of MAT_TYPES){
    matsEarned[m] = Math.floor(income.matsPerSec[m] * cappedSec * mult);
  }
  return {elapsed: cappedSec, goldEarned, matsEarned};
}

// --- SAVE / LOAD ---
const SAVE_KEY = 'golemWorkshop_v1';
function saveGame(){
  state.lastSave = Date.now();
  try{localStorage.setItem(SAVE_KEY, JSON.stringify(state));}catch(e){}
}
function loadGame(){
  try{
    const raw = localStorage.getItem(SAVE_KEY);
    if(raw){
      const loaded = JSON.parse(raw);
      state = {...DEFAULT_STATE, ...loaded};
      // Ensure arrays/objects are proper
      if(!Array.isArray(state.grid)) state.grid = new Array(COLS*ROWS).fill(null);
      while(state.grid.length < COLS*ROWS) state.grid.push(null);
      if(!state.deployed) state.deployed = {mine:[],battle:[],shop:[]};
      if(!state.deployed.mine) state.deployed.mine=[];
      if(!state.deployed.battle) state.deployed.battle=[];
      if(!state.deployed.shop) state.deployed.shop=[];
      if(!state.upgrades) state.upgrades = {...DEFAULT_STATE.upgrades};
      if(!state.unlockedMats) state.unlockedMats = ['dirt','stone'];
      if(!state.materials) state.materials = {dirt:5,stone:3,iron:0,crystal:0};
      return true;
    }
  }catch(e){}
  return false;
}
function resetGame(){
  if(confirm('Ï†ïÎßêÎ°ú Ï¥àÍ∏∞ÌôîÌïòÏãúÍ≤†ÏäµÎãàÍπå? Î™®Îì† Îç∞Ïù¥ÌÑ∞Í∞Ä ÏÇ≠Ï†úÎê©ÎãàÎã§.')){
    localStorage.removeItem(SAVE_KEY);
    state = JSON.parse(JSON.stringify(DEFAULT_STATE));
    showToast('üîÑ Í≤åÏûÑÏù¥ Ï¥àÍ∏∞ÌôîÎêòÏóàÏäµÎãàÎã§');
  }
}
let autoSaveTimer = 0;

// --- GRID HELPERS ---
function gridIdxToPos(idx){
  const col = idx % COLS;
  const row = Math.floor(idx / COLS);
  return {
    x: GRID_X + col*CELL + CELL/2,
    y: GRID_Y + row*CELL + CELL/2
  };
}
function posToGridIdx(px, py){
  const col = Math.floor((px - GRID_X) / CELL);
  const row = Math.floor((py - GRID_Y) / CELL);
  if(col<0||col>=COLS||row<0||row>=ROWS) return -1;
  return row*COLS+col;
}

// --- SPAWN MATERIAL ---
function spawnMaterial(matType){
  const cost = getMatCost(matType);
  if(state.gold < cost){playSound('error');showToast('Í≥®ÎìúÍ∞Ä Î∂ÄÏ°±Ìï©ÎãàÎã§!');return;}
  const emptyIdx = state.grid.findIndex(c=>c===null);
  if(emptyIdx < 0){playSound('error');showToast('Í≥µÎ∞©Ïù¥ ÍΩâ Ï∞ºÏäµÎãàÎã§!');return;}
  state.gold -= cost;
  state.grid[emptyIdx] = {type:'material', matType, tier:0};
  state.totalGoldEarned; // no change
  playSound('spawn');
  const pos = gridIdxToPos(emptyIdx);
  spawnParticles(pos.x, pos.y, 10, MAT_COLORS[matType], 3, 30);
  addFloatingText(pos.x, pos.y, `-${cost}G`, '#f87171', 14);
}
function getMatCost(matType){
  const base = {dirt:5, stone:10, iron:25, crystal:50};
  return base[matType] || 10;
}

// --- MERGE LOGIC ---
function tryMerge(fromIdx, toIdx){
  if(fromIdx===toIdx) return false;
  const a = state.grid[fromIdx];
  const b = state.grid[toIdx];
  if(!a || !b) return false;

  // Material + Material (same type, same tier)
  if(a.type==='material' && b.type==='material' && a.matType===b.matType && a.tier===b.tier){
    if(a.tier < 2){
      // Merge to higher tier material
      state.grid[toIdx] = {type:'material', matType:a.matType, tier:a.tier+1};
      state.grid[fromIdx] = null;
      state.totalMerges++;
      playSound('merge');
      const pos = gridIdxToPos(toIdx);
      spawnParticles(pos.x, pos.y, 12, MAT_COLORS[a.matType], 3, 40);
      addFloatingText(pos.x, pos.y, `${MAT_TIERS[a.tier+1]}!`, MAT_COLORS_L[a.matType], 16);
      return true;
    } else {
      // Tier 2 + Tier 2 = Create Golem (Common)
      state.grid[toIdx] = {type:'golem', matType:a.matType, grade:0};
      state.grid[fromIdx] = null;
      state.totalMerges++;
      state.totalGolemsCreated++;
      playSound('golem');
      const pos = gridIdxToPos(toIdx);
      spawnMergeParticles(pos.x, pos.y, 0);
      addFloatingText(pos.x, pos.y, `${GOLEM_NAMES[a.matType]} ÌÉÑÏÉù!`, GRADE_COLORS[0], 18);
      triggerShake(3);
      return true;
    }
  }

  // Golem + Golem (same type, same grade)
  if(a.type==='golem' && b.type==='golem' && a.matType===b.matType && a.grade===b.grade){
    if(a.grade < 3){
      const newGrade = a.grade+1;
      state.grid[toIdx] = {type:'golem', matType:a.matType, grade:newGrade};
      state.grid[fromIdx] = null;
      state.totalMerges++;
      if(newGrade === 3){
        playSound('legendary');
        triggerShake(15);
      } else {
        playSound('golem');
        triggerShake(5);
      }
      const pos = gridIdxToPos(toIdx);
      spawnMergeParticles(pos.x, pos.y, newGrade);
      addFloatingText(pos.x, pos.y, `${GRADE_NAMES[newGrade]}!`, GRADE_COLORS[newGrade], 20);
      return true;
    }
  }

  return false;
}

// --- DEPLOY LOGIC ---
function deployGolem(gridIdx, zone){
  const item = state.grid[gridIdx];
  if(!item || item.type !== 'golem') return false;
  const cap = getDeployCapacity(zone);
  if(state.deployed[zone].length >= cap){playSound('error');showToast(`${zone} Ïä¨Î°ØÏù¥ ÍΩâ Ï∞ºÏäµÎãàÎã§!`);return false;}
  state.deployed[zone].push({matType:item.matType, grade:item.grade});
  state.grid[gridIdx] = null;
  playSound('deploy');
  showToast(`${GOLEM_NAMES[item.matType]} ‚Üí ${zone==='mine'?'‚õèÍ¥ëÏÇ∞':zone==='battle'?'‚öîÏ†ÑÌà¨':'üè™Í∞ÄÍ≤å'} Î∞∞Ïπò!`);
  return true;
}
function recallGolem(zone, idx){
  const emptyGridIdx = state.grid.findIndex(c=>c===null);
  if(emptyGridIdx < 0){playSound('error');showToast('Í≥µÎ∞©Ïù¥ ÍΩâ Ï∞ºÏäµÎãàÎã§!');return false;}
  const g = state.deployed[zone][idx];
  state.grid[emptyGridIdx] = {type:'golem', matType:g.matType, grade:g.grade};
  state.deployed[zone].splice(idx,1);
  playSound('click');
  showToast(`${GOLEM_NAMES[g.matType]} ÌöåÏàò!`);
  return true;
}

// --- INPUT ---
let dragging = null; // {gridIdx, startX, startY, curX, curY}
let mouseX=0, mouseY=0;
let hoveredCell = -1;
let hoveredButton = '';
let selectedGolemIdx = -1;

// Button definitions (recalculated on resize)
let buttons = [];
let deployZones = [];

function getCanvasPos(e){
  const rect = C.getBoundingClientRect();
  const touch = e.touches ? e.touches[0] : e;
  if(!touch && e.changedTouches) return getCanvasPos({touches: e.changedTouches});
  const cx = (touch.clientX - rect.left) * (C.width/rect.width);
  const cy = (touch.clientY - rect.top) * (C.height/rect.height);
  return {x: cx, y: cy};
}

function handlePointerDown(e){
  e.preventDefault();
  initAudio();
  const pos = getCanvasPos(e);
  mouseX = pos.x; mouseY = pos.y;

  // Check buttons
  for(const btn of buttons){
    if(pos.x>=btn.x && pos.x<=btn.x+btn.w && pos.y>=btn.y && pos.y<=btn.y+btn.h){
      btn.action();
      playSound('click');
      return;
    }
  }

  // Check grid
  const idx = posToGridIdx(pos.x, pos.y);
  if(idx >= 0 && state.grid[idx]){
    dragging = {gridIdx:idx, startX:pos.x, startY:pos.y, curX:pos.x, curY:pos.y};
    selectedGolemIdx = idx;
    return;
  }

  // Check deploy zones (for recall)
  for(const dz of deployZones){
    if(pos.x>=dz.x && pos.x<=dz.x+dz.w && pos.y>=dz.y && pos.y<=dz.y+dz.h){
      if(dz.slotIdx !== undefined && dz.slotIdx < state.deployed[dz.zone].length){
        recallGolem(dz.zone, dz.slotIdx);
      }
      return;
    }
  }

  selectedGolemIdx = -1;
}

function handlePointerMove(e){
  e.preventDefault();
  const pos = getCanvasPos(e);
  mouseX = pos.x; mouseY = pos.y;
  if(dragging){
    dragging.curX = pos.x;
    dragging.curY = pos.y;
  }
  hoveredCell = posToGridIdx(pos.x, pos.y);

  hoveredButton = '';
  for(const btn of buttons){
    if(pos.x>=btn.x && pos.x<=btn.x+btn.w && pos.y>=btn.y && pos.y<=btn.y+btn.h){
      hoveredButton = btn.id;
      break;
    }
  }
}

function handlePointerUp(e){
  e.preventDefault();
  if(!dragging){return;}
  const pos = e.changedTouches ? getCanvasPos({touches:e.changedTouches}) : getCanvasPos(e);
  const dropIdx = posToGridIdx(pos.x, pos.y);

  // Try merge
  if(dropIdx >= 0 && dropIdx !== dragging.gridIdx){
    if(state.grid[dropIdx]){
      if(!tryMerge(dragging.gridIdx, dropIdx)){
        // Swap
        const temp = state.grid[dragging.gridIdx];
        state.grid[dragging.gridIdx] = state.grid[dropIdx];
        state.grid[dropIdx] = temp;
      }
    } else {
      // Move to empty cell
      state.grid[dropIdx] = state.grid[dragging.gridIdx];
      state.grid[dragging.gridIdx] = null;
    }
  } else if(dropIdx < 0){
    // Check if dropped on deploy zone
    for(const dz of deployZones){
      if(pos.x>=dz.x && pos.x<=dz.x+dz.w && pos.y>=dz.y && pos.y<=dz.y+dz.h && dz.slotIdx === undefined){
        const item = state.grid[dragging.gridIdx];
        if(item && item.type === 'golem'){
          deployGolem(dragging.gridIdx, dz.zone);
        }
        break;
      }
    }
  }

  dragging = null;
}

C.addEventListener('mousedown', handlePointerDown);
C.addEventListener('mousemove', handlePointerMove);
C.addEventListener('mouseup', handlePointerUp);
C.addEventListener('touchstart', handlePointerDown, {passive:false});
C.addEventListener('touchmove', handlePointerMove, {passive:false});
C.addEventListener('touchend', handlePointerUp, {passive:false});

// --- PANEL MANAGEMENT ---
function togglePanel(id){
  const panel = document.getElementById(id);
  if(panel.classList.contains('active')){
    panel.classList.remove('active');
  } else {
    document.querySelectorAll('.panel').forEach(p=>p.classList.remove('active'));
    panel.classList.add('active');
    if(id==='upgrade-panel') renderUpgradePanel();
    if(id==='stage-panel') renderStagePanel();
    if(id==='deploy-panel') renderDeployPanel();
  }
}
window.togglePanel = togglePanel;

function renderUpgradePanel(){
  const list = document.getElementById('upgrade-list');
  list.innerHTML = '';
  for(const upg of UPGRADES){
    const cost = getUpgradeCost(upg);
    const level = state.upgrades[upg.key];
    const maxed = level >= upg.max;
    const row = document.createElement('div');
    row.className = 'upgrade-row';
    row.innerHTML = `
      <div class="upgrade-info">
        <div class="name">${upg.name} (Lv.${level}/${upg.max})</div>
        <div class="desc">${upg.desc}</div>
      </div>
      <button class="btn btn-sm" ${maxed||state.gold<cost?'disabled':''}>${maxed?'MAX':`${cost}G`}</button>
    `;
    if(!maxed){
      row.querySelector('button').onclick = ()=>{
        if(state.gold >= cost){
          state.gold -= cost;
          state.upgrades[upg.key]++;
          playSound('upgrade');
          renderUpgradePanel();
          saveGame();
        }
      };
    }
    list.appendChild(row);
  }
  // Reset button
  const resetRow = document.createElement('div');
  resetRow.style.cssText = 'text-align:center;margin-top:15px;';
  resetRow.innerHTML = '<button class="btn btn-sm" style="background:#dc2626">üîÑ Ï¥àÍ∏∞Ìôî</button>';
  resetRow.querySelector('button').onclick = resetGame;
  list.appendChild(resetRow);
}

function renderStagePanel(){
  const info = document.getElementById('stage-info');
  const s = getStage();
  if(!s){info.innerHTML='<p style="text-align:center">üèÜ Î™®Îì† Ïä§ÌÖåÏù¥ÏßÄ ÌÅ¥Î¶¨Ïñ¥!</p>';return;}
  let html = `<p style="text-align:center;margin-bottom:10px;font-size:1.1rem;color:#fbbf24">Ïä§ÌÖåÏù¥ÏßÄ ${s.id}: ${s.name}</p>`;
  for(const obj of s.objectives){
    const met = isObjectiveMet(obj);
    html += `<div class="stage-obj"><span class="${met?'done':'pending'}">${met?'‚úÖ':'‚¨ú'}</span> ${obj.desc}</div>`;
  }
  html += `<p style="margin-top:10px;font-size:0.85rem;color:#9ca3af">Î≥¥ÏÉÅ: ${s.reward.gold}G${s.reward.unlock?' + '+MAT_NAMES[s.reward.unlock]+' Ìï¥Í∏à':''}</p>`;
  if(checkStageComplete()){
    html += `<div style="text-align:center;margin-top:12px"><button class="btn" onclick="advanceStage();renderStagePanel()">üéâ ÌÅ¥Î¶¨Ïñ¥ Î≥¥ÏÉÅ Î∞õÍ∏∞!</button></div>`;
  }
  info.innerHTML = html;
}
window.advanceStage = advanceStage;
window.renderStagePanel = renderStagePanel;

function renderDeployPanel(){
  const info = document.getElementById('deploy-info');
  let html = '';
  const zones = [{key:'mine',name:'‚õè Í¥ëÏÇ∞',desc:'Ïû¨Î£å ÏÉùÏÇ∞',color:COLORS.mine},
                 {key:'battle',name:'‚öî Ï†ÑÌà¨',desc:'Í≥®Îìú ÌöçÎìù',color:COLORS.battle},
                 {key:'shop',name:'üè™ Í∞ÄÍ≤å',desc:'Í≥®Îìú ÌöçÎìù (ÎßéÏùå)',color:COLORS.shop}];
  for(const z of zones){
    const cap = getDeployCapacity(z.key);
    html += `<div style="margin-bottom:12px;padding:10px;background:rgba(0,0,0,0.3);border-radius:10px;border-left:3px solid ${z.color}">`;
    html += `<div style="font-weight:700;color:${z.color}">${z.name} <span style="color:#9ca3af;font-weight:400">(${state.deployed[z.key].length}/${cap}) - ${z.desc}</span></div>`;
    if(state.deployed[z.key].length === 0){
      html += `<div style="color:#6b7280;font-size:0.8rem;margin-top:5px">Í≥®Î†òÏùÑ Í∑∏Î¶¨ÎìúÏóêÏÑú Ïó¨Í∏∞Î°ú ÎìúÎûòÍ∑∏ÌïòÏÑ∏Ïöî</div>`;
    } else {
      html += '<div style="display:flex;gap:8px;margin-top:8px;flex-wrap:wrap">';
      state.deployed[z.key].forEach((g,i)=>{
        html += `<div style="background:rgba(0,0,0,0.4);padding:6px 10px;border-radius:8px;border:1px solid ${GRADE_COLORS[g.grade]};font-size:0.8rem;cursor:pointer" onclick="recallGolem('${z.key}',${i});renderDeployPanel()">${GOLEM_EMOJIS[g.matType]} ${GRADE_NAMES[g.grade]} <span style="color:#f87171;font-size:0.7rem">ÌöåÏàò</span></div>`;
      });
      html += '</div>';
    }
    html += '</div>';
  }
  const income = calcIncome();
  html += `<div style="margin-top:10px;padding:10px;background:rgba(139,92,246,0.15);border-radius:10px;font-size:0.85rem">`;
  html += `<div style="color:#c4b5fd;font-weight:700">üí∞ ÏàòÏûÖ (Ï¥àÎãπ)</div>`;
  html += `<div>Í≥®Îìú: <span style="color:#fbbf24">${income.goldPerSec.toFixed(1)}/s</span></div>`;
  for(const m of MAT_TYPES){
    if(income.matsPerSec[m]>0) html+=`<div>${MAT_EMOJIS[m]}: <span style="color:${MAT_COLORS_L[m]}">${income.matsPerSec[m].toFixed(1)}/s</span></div>`;
  }
  html += '</div>';
  info.innerHTML = html;
}
window.recallGolem = recallGolem;
window.renderDeployPanel = renderDeployPanel;

// --- RESIZE ---
function resize(){
  const dpr = window.devicePixelRatio || 1;
  W = window.innerWidth;
  H = window.innerHeight;
  C.width = W * dpr;
  C.height = H * dpr;
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  SCALE = Math.min(W/400, H/750);

  // Calculate grid dimensions
  const gridW = Math.min(W*0.92, 380);
  CELL = Math.floor(gridW / COLS);
  const totalGridW = CELL * COLS;
  const totalGridH = CELL * ROWS;
  GRID_X = (W - totalGridW) / 2;
  GRID_Y = 140 * SCALE;

  // Position panels
  const panels = document.querySelectorAll('.panel');
  panels.forEach(p=>{
    p.style.left = '5%';
    p.style.right = '5%';
    p.style.top = '10%';
    p.style.maxHeight = '75%';
    p.style.overflowY = 'auto';
  });

  recalcButtons();
}

function recalcButtons(){
  buttons = [];
  deployZones = [];

  const spawnY = GRID_Y - 50*SCALE;
  const spawnBtnW = 60*SCALE;
  const spawnBtnH = 35*SCALE;
  const spawnGap = 8*SCALE;
  const totalSpawnW = state.unlockedMats.length*(spawnBtnW+spawnGap)-spawnGap;
  let sx = (W-totalSpawnW)/2;

  for(const mat of state.unlockedMats){
    buttons.push({
      id:'spawn_'+mat, x:sx, y:spawnY, w:spawnBtnW, h:spawnBtnH,
      label:`${MAT_EMOJIS[mat]}${getMatCost(mat)}G`,
      color:MAT_COLORS[mat],
      action:()=>spawnMaterial(mat)
    });
    sx += spawnBtnW + spawnGap;
  }

  // Deploy zones below grid
  const deployY = GRID_Y + CELL*ROWS + 20*SCALE;
  const dzW = (W*0.92)/3 - 8;
  const dzH = 80*SCALE;
  const dzStartX = W*0.04;
  const zoneKeys = ['mine','battle','shop'];
  const zoneNames = ['‚õèÍ¥ëÏÇ∞','‚öîÏ†ÑÌà¨','üè™Í∞ÄÍ≤å'];
  const zoneColors = [COLORS.mine, COLORS.battle, COLORS.shop];
  for(let i=0;i<3;i++){
    const zx = dzStartX + i*(dzW+8);
    deployZones.push({
      zone:zoneKeys[i], x:zx, y:deployY, w:dzW, h:dzH,
      name:zoneNames[i], color:zoneColors[i]
    });
    // Individual slot zones for recall
    const cap = getDeployCapacity(zoneKeys[i]);
    const slotSize = Math.min(30*SCALE, dzW/cap - 4);
    for(let s=0;s<state.deployed[zoneKeys[i]].length;s++){
      deployZones.push({
        zone:zoneKeys[i], slotIdx:s,
        x: zx + 5 + s*(slotSize+4), y: deployY+dzH-slotSize-8,
        w: slotSize, h: slotSize,
        name:'', color:zoneColors[i]
      });
    }
  }

  // Bottom buttons
  const botY = deployY + dzH + 15*SCALE;
  const botBtnW = W*0.28;
  const botBtnH = 38*SCALE;
  buttons.push({
    id:'upgrades', x:W*0.04, y:botY, w:botBtnW, h:botBtnH,
    label:'‚öíÔ∏è ÏóÖÍ∑∏Î†àÏù¥Îìú', color:'#6d28d9',
    action:()=>togglePanel('upgrade-panel')
  });
  buttons.push({
    id:'stages', x:W*0.36, y:botY, w:botBtnW, h:botBtnH,
    label:'üìú Ïä§ÌÖåÏù¥ÏßÄ', color:'#4c1d95',
    action:()=>togglePanel('stage-panel')
  });
  buttons.push({
    id:'deploy', x:W*0.68, y:botY, w:botBtnW, h:botBtnH,
    label:'üèóÔ∏è Î∞∞Ïπò', color:'#1e3a5f',
    action:()=>togglePanel('deploy-panel')
  });
}

// --- DRAWING ---
function drawBG(){
  const grad = ctx.createLinearGradient(0,0,0,H);
  grad.addColorStop(0, COLORS.bgGrad1);
  grad.addColorStop(1, COLORS.bgGrad2);
  ctx.fillStyle = grad;
  ctx.fillRect(0,0,W,H);

  // Ambient particles (background stars)
  const t = Date.now()/1000;
  ctx.fillStyle='rgba(139,92,246,0.15)';
  for(let i=0;i<20;i++){
    const x = (Math.sin(t*0.3+i*1.7)*0.5+0.5)*W;
    const y = (Math.cos(t*0.2+i*2.3)*0.5+0.5)*H;
    ctx.beginPath();
    ctx.arc(x, y, 1+Math.sin(t+i)*0.5, 0, Math.PI*2);
    ctx.fill();
  }
}

function drawHUD(){
  // Top bar
  ctx.fillStyle = COLORS.hud;
  const hudH = 45*SCALE;
  ctx.fillRect(0, 0, W, hudH);
  ctx.strokeStyle = COLORS.hudBorder;
  ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(0,hudH); ctx.lineTo(W,hudH); ctx.stroke();

  // Gold
  ctx.fillStyle = COLORS.gold;
  ctx.font = `bold ${16*SCALE}px sans-serif`;
  ctx.textAlign = 'left';
  ctx.fillText(`üí∞ ${formatNum(Math.floor(state.gold))}`, 12, hudH*0.6);

  // Stage
  ctx.fillStyle = '#c4b5fd';
  ctx.font = `${13*SCALE}px sans-serif`;
  ctx.textAlign = 'right';
  ctx.fillText(`Stage ${state.stage}`, W-12, hudH*0.45);
  const income = calcIncome();
  if(income.goldPerSec > 0){
    ctx.fillStyle = '#34d399';
    ctx.font = `${11*SCALE}px sans-serif`;
    ctx.fillText(`+${income.goldPerSec.toFixed(1)}/s`, W-12, hudH*0.8);
  }

  // Materials bar
  const matY = hudH + 8*SCALE;
  const matH = 28*SCALE;
  ctx.fillStyle = 'rgba(15,10,25,0.6)';
  ctx.fillRect(0, hudH, W, matH+16*SCALE);

  let mx = 12;
  ctx.font = `${12*SCALE}px sans-serif`;
  ctx.textAlign = 'left';
  for(const mat of state.unlockedMats){
    ctx.fillStyle = MAT_COLORS_L[mat];
    ctx.fillText(`${MAT_EMOJIS[mat]}${Math.floor(state.materials[mat])}`, mx, matY+matH*0.5);
    mx += 75*SCALE;
  }

  // Stage progress indicator
  if(checkStageComplete()){
    ctx.fillStyle = '#34d399';
    ctx.font = `bold ${11*SCALE}px sans-serif`;
    ctx.textAlign = 'center';
    const pulse = Math.sin(Date.now()/300)*0.3+0.7;
    ctx.globalAlpha = pulse;
    ctx.fillText('‚ú® Ïä§ÌÖåÏù¥ÏßÄ ÌÅ¥Î¶¨Ïñ¥! ÌÉ≠ÌïòÏó¨ Î≥¥ÏÉÅ Î∞õÍ∏∞', W/2, matY+matH+10*SCALE);
    ctx.globalAlpha = 1;
  }
}

function drawGrid(){
  // Grid background
  ctx.fillStyle = COLORS.grid;
  const pad = 4;
  roundRect(ctx, GRID_X-pad, GRID_Y-pad, CELL*COLS+pad*2, CELL*ROWS+pad*2, 12);
  ctx.fill();

  // Grid cells
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const idx = r*COLS+c;
      const cx = GRID_X + c*CELL;
      const cy = GRID_Y + r*CELL;
      const inner = 3;

      // Cell background
      let cellColor = 'rgba(30,20,50,0.6)';
      if(hoveredCell === idx && !dragging) cellColor = 'rgba(60,40,90,0.7)';
      if(dragging && idx === dragging.gridIdx) cellColor = 'rgba(80,50,120,0.5)';

      // Highlight valid merge target
      if(dragging && idx !== dragging.gridIdx){
        const dragItem = state.grid[dragging.gridIdx];
        const cellItem = state.grid[idx];
        if(dragItem && cellItem){
          if(dragItem.type===cellItem.type && dragItem.matType===cellItem.matType){
            if((dragItem.type==='material' && dragItem.tier===cellItem.tier) ||
               (dragItem.type==='golem' && dragItem.grade===cellItem.grade && dragItem.grade<3)){
              cellColor = 'rgba(52,211,153,0.3)';
            }
          }
        }
      }

      ctx.fillStyle = cellColor;
      roundRect(ctx, cx+inner, cy+inner, CELL-inner*2, CELL-inner*2, 8);
      ctx.fill();

      // Border
      ctx.strokeStyle = COLORS.gridLine;
      ctx.lineWidth = 1;
      roundRect(ctx, cx+inner, cy+inner, CELL-inner*2, CELL-inner*2, 8);
      ctx.stroke();

      // Draw item
      const item = state.grid[idx];
      if(item && !(dragging && dragging.gridIdx === idx)){
        drawItem(item, cx+CELL/2, cy+CELL/2, CELL*0.7);
      }
    }
  }

  // Draw dragged item
  if(dragging){
    const item = state.grid[dragging.gridIdx];
    if(item){
      ctx.globalAlpha = 0.8;
      drawItem(item, dragging.curX, dragging.curY, CELL*0.75);
      ctx.globalAlpha = 1;
    }
  }
}

function drawItem(item, x, y, size){
  if(item.type === 'material'){
    drawMaterial(item, x, y, size);
  } else if(item.type === 'golem'){
    drawGolem(item, x, y, size);
  }
}

function drawMaterial(item, x, y, size){
  const r = size*0.4;
  const tierScale = 0.7 + item.tier*0.15;
  const actualR = r * tierScale;

  // Shadow
  ctx.fillStyle = 'rgba(0,0,0,0.3)';
  ctx.beginPath();
  ctx.ellipse(x+2, y+3, actualR, actualR*0.6, 0, 0, Math.PI*2);
  ctx.fill();

  // Main shape (crystal shape for materials)
  const color = MAT_COLORS[item.matType];
  const colorL = MAT_COLORS_L[item.matType];

  ctx.fillStyle = color;
  if(item.matType === 'crystal'){
    // Diamond shape
    ctx.beginPath();
    ctx.moveTo(x, y-actualR);
    ctx.lineTo(x+actualR*0.7, y);
    ctx.lineTo(x, y+actualR*0.6);
    ctx.lineTo(x-actualR*0.7, y);
    ctx.closePath();
    ctx.fill();
    ctx.fillStyle = colorL;
    ctx.beginPath();
    ctx.moveTo(x, y-actualR);
    ctx.lineTo(x+actualR*0.7, y);
    ctx.lineTo(x, y-actualR*0.2);
    ctx.closePath();
    ctx.fill();
  } else if(item.matType === 'iron'){
    // Metallic rectangle
    roundRect(ctx, x-actualR*0.6, y-actualR*0.6, actualR*1.2, actualR*1.2, 4);
    ctx.fill();
    ctx.fillStyle = colorL;
    ctx.fillRect(x-actualR*0.4, y-actualR*0.5, actualR*0.3, actualR);
  } else {
    // Rounded chunk
    ctx.beginPath();
    ctx.arc(x, y, actualR, 0, Math.PI*2);
    ctx.fill();
    // Highlight
    ctx.fillStyle = colorL;
    ctx.beginPath();
    ctx.arc(x-actualR*0.2, y-actualR*0.2, actualR*0.5, 0, Math.PI*2);
    ctx.fill();
  }

  // Tier indicator (small dots)
  for(let i=0;i<=item.tier;i++){
    ctx.fillStyle = '#fff';
    ctx.globalAlpha = 0.8;
    ctx.beginPath();
    ctx.arc(x - (item.tier*3) + i*6, y+actualR+6, 2, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;
  }

  // Tier label
  ctx.fillStyle = '#e8e0f0';
  ctx.font = `${9*SCALE}px sans-serif`;
  ctx.textAlign = 'center';
  ctx.fillText(MAT_TIERS[item.tier], x, y-actualR-4);
}

function drawGolem(item, x, y, size){
  const grade = item.grade;
  const gradeColor = GRADE_COLORS[grade];
  const r = size*0.42;
  const t = Date.now()/1000;

  // Glow effect
  if(grade >= 2){
    const glowR = r*1.3 + Math.sin(t*3)*3;
    const glow = ctx.createRadialGradient(x,y,r*0.5,x,y,glowR);
    glow.addColorStop(0, gradeColor+'44');
    glow.addColorStop(1, gradeColor+'00');
    ctx.fillStyle = glow;
    ctx.beginPath();
    ctx.arc(x, y, glowR, 0, Math.PI*2);
    ctx.fill();
  }

  // Body
  const bodyColor = MAT_COLORS[item.matType];
  const bodyColorL = MAT_COLORS_L[item.matType];

  // Shadow
  ctx.fillStyle = 'rgba(0,0,0,0.3)';
  ctx.beginPath();
  ctx.ellipse(x+2, y+r*0.8, r*0.7, r*0.3, 0, 0, Math.PI*2);
  ctx.fill();

  // Legs
  ctx.fillStyle = bodyColor;
  roundRect(ctx, x-r*0.6, y+r*0.1, r*0.4, r*0.6, 3);
  ctx.fill();
  roundRect(ctx, x+r*0.2, y+r*0.1, r*0.4, r*0.6, 3);
  ctx.fill();

  // Body
  ctx.fillStyle = bodyColor;
  roundRect(ctx, x-r*0.7, y-r*0.5, r*1.4, r*0.8, 6);
  ctx.fill();

  // Body highlight
  ctx.fillStyle = bodyColorL;
  roundRect(ctx, x-r*0.5, y-r*0.4, r*0.6, r*0.5, 4);
  ctx.fill();

  // Head
  ctx.fillStyle = bodyColor;
  ctx.beginPath();
  ctx.arc(x, y-r*0.55, r*0.45, 0, Math.PI*2);
  ctx.fill();

  // Eyes
  const eyeGlow = grade === 3 ? '#fbbf24' : grade === 2 ? '#a855f7' : grade === 1 ? '#3b82f6' : '#fff';
  ctx.fillStyle = eyeGlow;
  const blink = Math.sin(t*2) > 0.95 ? 0.5 : 1;
  ctx.beginPath();
  ctx.ellipse(x-r*0.15, y-r*0.55, 3*SCALE, 3*SCALE*blink, 0, 0, Math.PI*2);
  ctx.fill();
  ctx.beginPath();
  ctx.ellipse(x+r*0.15, y-r*0.55, 3*SCALE, 3*SCALE*blink, 0, 0, Math.PI*2);
  ctx.fill();

  // Arms
  ctx.fillStyle = bodyColor;
  roundRect(ctx, x-r*0.95, y-r*0.3, r*0.3, r*0.5, 3);
  ctx.fill();
  roundRect(ctx, x+r*0.65, y-r*0.3, r*0.3, r*0.5, 3);
  ctx.fill();

  // Grade border
  ctx.strokeStyle = gradeColor;
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(x, y-r*0.1, r*0.9, 0, Math.PI*2);
  ctx.stroke();

  // Grade label
  ctx.fillStyle = gradeColor;
  ctx.font = `bold ${10*SCALE}px sans-serif`;
  ctx.textAlign = 'center';
  ctx.fillText(GRADE_NAMES[grade], x, y+r+12);

  // Legendary sparkle
  if(grade === 3){
    for(let i=0;i<4;i++){
      const angle = t*2 + i*Math.PI/2;
      const sx = x + Math.cos(angle)*r*1.1;
      const sy = y-r*0.1 + Math.sin(angle)*r*1.1;
      ctx.fillStyle = '#fbbf24';
      ctx.globalAlpha = 0.5+Math.sin(t*4+i)*0.5;
      drawStar(sx, sy, 3, 1.5, 4);
      ctx.globalAlpha = 1;
    }
  }
}

function drawStar(cx, cy, outerR, innerR, points){
  ctx.beginPath();
  for(let i=0;i<points*2;i++){
    const r = i%2===0 ? outerR : innerR;
    const angle = (i*Math.PI/points) - Math.PI/2;
    if(i===0) ctx.moveTo(cx+r*Math.cos(angle), cy+r*Math.sin(angle));
    else ctx.lineTo(cx+r*Math.cos(angle), cy+r*Math.sin(angle));
  }
  ctx.closePath();
  ctx.fill();
}

function drawSpawnButtons(){
  for(const btn of buttons){
    if(!btn.id.startsWith('spawn_')) continue;
    const hovered = hoveredButton === btn.id;
    ctx.fillStyle = hovered ? btn.color+'dd' : btn.color+'99';
    roundRect(ctx, btn.x, btn.y, btn.w, btn.h, 8);
    ctx.fill();
    ctx.strokeStyle = btn.color;
    ctx.lineWidth = 1.5;
    roundRect(ctx, btn.x, btn.y, btn.w, btn.h, 8);
    ctx.stroke();

    ctx.fillStyle = '#fff';
    ctx.font = `bold ${11*SCALE}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.fillText(btn.label, btn.x+btn.w/2, btn.y+btn.h*0.65);
  }
}

function drawDeployZones(){
  for(const dz of deployZones){
    if(dz.slotIdx !== undefined) continue; // Skip slot markers
    const zone = dz.zone;
    const cap = getDeployCapacity(zone);
    const deployed = state.deployed[zone];

    // Zone background
    ctx.fillStyle = dz.color + '15';
    roundRect(ctx, dz.x, dz.y, dz.w, dz.h, 10);
    ctx.fill();
    ctx.strokeStyle = dz.color + '66';
    ctx.lineWidth = 1.5;
    roundRect(ctx, dz.x, dz.y, dz.w, dz.h, 10);
    ctx.stroke();

    // Drop highlight when dragging golem
    if(dragging){
      const dragItem = state.grid[dragging.gridIdx];
      if(dragItem && dragItem.type==='golem' && deployed.length < cap){
        const dx = dragging.curX, dy = dragging.curY;
        if(dx>=dz.x && dx<=dz.x+dz.w && dy>=dz.y && dy<=dz.y+dz.h){
          ctx.fillStyle = dz.color + '33';
          roundRect(ctx, dz.x, dz.y, dz.w, dz.h, 10);
          ctx.fill();
        }
      }
    }

    // Zone label
    ctx.fillStyle = dz.color;
    ctx.font = `bold ${11*SCALE}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.fillText(`${dz.name} (${deployed.length}/${cap})`, dz.x+dz.w/2, dz.y+16*SCALE);

    // Deployed golem slots
    const slotSize = Math.min(28*SCALE, dz.w/cap - 4);
    const slotsStartX = dz.x + (dz.w - cap*(slotSize+4)+4)/2;
    for(let i=0;i<cap;i++){
      const sx = slotsStartX + i*(slotSize+4);
      const sy = dz.y + dz.h - slotSize - 6;

      if(i < deployed.length){
        const g = deployed[i];
        ctx.fillStyle = GRADE_COLORS[g.grade] + '33';
        roundRect(ctx, sx, sy, slotSize, slotSize, 6);
        ctx.fill();
        ctx.strokeStyle = GRADE_COLORS[g.grade];
        ctx.lineWidth = 1;
        roundRect(ctx, sx, sy, slotSize, slotSize, 6);
        ctx.stroke();

        // Mini golem
        drawGolem({matType:g.matType, grade:g.grade}, sx+slotSize/2, sy+slotSize/2, slotSize*0.75);
      } else {
        ctx.fillStyle = 'rgba(255,255,255,0.05)';
        roundRect(ctx, sx, sy, slotSize, slotSize, 6);
        ctx.fill();
        ctx.strokeStyle = 'rgba(255,255,255,0.1)';
        ctx.lineWidth = 1;
        roundRect(ctx, sx, sy, slotSize, slotSize, 6);
        ctx.stroke();
        ctx.fillStyle = 'rgba(255,255,255,0.15)';
        ctx.font = `${14*SCALE}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.fillText('+', sx+slotSize/2, sy+slotSize*0.65);
      }
    }
  }
}

function drawBottomButtons(){
  for(const btn of buttons){
    if(btn.id.startsWith('spawn_')) continue;
    const hovered = hoveredButton === btn.id;
    ctx.fillStyle = hovered ? btn.color+'ee' : btn.color+'aa';
    roundRect(ctx, btn.x, btn.y, btn.w, btn.h, 10);
    ctx.fill();
    ctx.strokeStyle = btn.color;
    ctx.lineWidth = 1;
    roundRect(ctx, btn.x, btn.y, btn.w, btn.h, 10);
    ctx.stroke();

    ctx.fillStyle = '#fff';
    ctx.font = `bold ${11*SCALE}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.fillText(btn.label, btn.x+btn.w/2, btn.y+btn.h*0.65);
  }
}

function drawTooltip(){
  if(hoveredCell >= 0 && !dragging){
    const item = state.grid[hoveredCell];
    if(item){
      const pos = gridIdxToPos(hoveredCell);
      let text = '';
      if(item.type==='material'){
        text = `${MAT_NAMES[item.matType]} (${MAT_TIERS[item.tier]})`;
      } else {
        text = `${GOLEM_NAMES[item.matType]} [${GRADE_NAMES[item.grade]}]`;
      }
      const tw = ctx.measureText(text).width + 16;
      let tx = pos.x - tw/2;
      let ty = pos.y - CELL/2 - 30;
      if(tx < 4) tx = 4;
      if(tx+tw > W-4) tx = W-4-tw;

      ctx.fillStyle = 'rgba(0,0,0,0.85)';
      roundRect(ctx, tx, ty, tw, 24, 6);
      ctx.fill();
      ctx.fillStyle = '#e8e0f0';
      ctx.font = `${11*SCALE}px sans-serif`;
      ctx.textAlign = 'center';
      ctx.fillText(text, tx+tw/2, ty+16);
    }
  }
}

function roundRect(ctx, x, y, w, h, r){
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.lineTo(x+w-r, y);
  ctx.quadraticCurveTo(x+w, y, x+w, y+r);
  ctx.lineTo(x+w, y+h-r);
  ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
  ctx.lineTo(x+r, y+h);
  ctx.quadraticCurveTo(x, y+h, x, y+h-r);
  ctx.lineTo(x, y+r);
  ctx.quadraticCurveTo(x, y, x+r, y);
  ctx.closePath();
}

function formatNum(n){
  if(n >= 1000000) return (n/1000000).toFixed(1)+'M';
  if(n >= 1000) return (n/1000).toFixed(1)+'K';
  return n.toString();
}

// --- TUTORIAL ---
let tutorialStep = 0;
let tutorialAlpha = 0;
function drawTutorial(){
  if(state.tutorialDone) return;
  const messages = [
    'üëÜ Ïû¨Î£å Î≤ÑÌäºÏùÑ ÎàåÎü¨ Í≥µÎ∞©Ïóê Ïû¨Î£åÎ•º ÏÉùÏÑ±ÌïòÏÑ∏Ïöî!',
    '‚úã Í∞ôÏùÄ Ïû¨Î£åÎ•º ÎìúÎûòÍ∑∏Ìï¥ÏÑú Ìï©ÏπòÏÑ∏Ïöî (Î®∏ÏßÄ)!',
    'üóø ÏµúÍ≥† Îì±Í∏â Ïû¨Î£åÎ•º Î®∏ÏßÄÌïòÎ©¥ Í≥®Î†òÏù¥ ÌÉÑÏÉùÌï©ÎãàÎã§!',
    'üì¶ Í≥®Î†òÏùÑ ÏïÑÎûò Íµ¨Ïó≠ÏúºÎ°ú ÎìúÎûòÍ∑∏Ìï¥ÏÑú Î∞∞ÏπòÌïòÏÑ∏Ïöî!',
  ];

  // Check tutorial progression
  const emptySlots = state.grid.filter(c=>c===null).length;
  if(tutorialStep===0 && emptySlots < COLS*ROWS) tutorialStep = 1;
  if(tutorialStep===1 && state.totalMerges > 0) tutorialStep = 2;
  if(tutorialStep===2 && state.totalGolemsCreated > 0) tutorialStep = 3;
  if(tutorialStep===3 && (state.deployed.mine.length+state.deployed.battle.length+state.deployed.shop.length)>0){
    state.tutorialDone = true;
    return;
  }

  if(tutorialStep >= messages.length) return;

  tutorialAlpha = Math.sin(Date.now()/500)*0.15+0.85;
  const msg = messages[tutorialStep];
  ctx.globalAlpha = tutorialAlpha;
  ctx.fillStyle = 'rgba(139,92,246,0.9)';
  const tw = Math.min(W*0.9, 350);
  const tx = (W-tw)/2;
  const ty = H - 80*SCALE;
  roundRect(ctx, tx, ty, tw, 40, 10);
  ctx.fill();
  ctx.fillStyle = '#fff';
  ctx.font = `${12*SCALE}px sans-serif`;
  ctx.textAlign = 'center';
  ctx.fillText(msg, W/2, ty+25);
  ctx.globalAlpha = 1;
}

// --- MAIN LOOP ---
let lastTime = 0;
let fps = 0, fpsCounter = 0, fpsTime = 0;

function gameLoop(now){
  requestAnimationFrame(gameLoop);
  const dt = Math.min((now - lastTime)/1000, 0.1);
  lastTime = now;

  // FPS counter
  fpsCounter++;
  fpsTime += dt;
  if(fpsTime >= 1){fps = fpsCounter; fpsCounter = 0; fpsTime = 0;}

  // Update
  processIncome(dt);
  processAutoSpawn(dt);
  updateParticles();
  updateFloatingTexts();

  // Screen shake
  if(shakeAmount > 0.5){
    shakeAmount *= shakeDecay;
    ctx.save();
    ctx.translate(
      (Math.random()-0.5)*shakeAmount*2,
      (Math.random()-0.5)*shakeAmount*2
    );
  }

  // Check stage
  if(checkStageComplete()){
    // Pulse effect for stage complete
  }

  // Auto save
  autoSaveTimer += dt;
  if(autoSaveTimer >= 15){
    autoSaveTimer = 0;
    saveGame();
  }

  // Recalc buttons (for dynamic elements)
  recalcButtons();

  // Draw
  drawBG();
  drawHUD();
  drawSpawnButtons();
  drawGrid();
  drawDeployZones();
  drawBottomButtons();
  drawParticles();
  drawFloatingTexts();
  drawTooltip();
  drawTutorial();

  // FPS display
  ctx.fillStyle = 'rgba(255,255,255,0.3)';
  ctx.font = '10px monospace';
  ctx.textAlign = 'right';
  ctx.fillText(`${fps}fps`, W-5, H-5);

  if(shakeAmount > 0.5) ctx.restore();
}

// --- INIT ---
function init(){
  const hasData = loadGame();
  if(!hasData){
    state = JSON.parse(JSON.stringify(DEFAULT_STATE));
  }

  resize();
  window.addEventListener('resize', resize);

  // Check offline earnings
  if(hasData){
    const offline = calcOfflineEarnings();
    if(offline && (offline.goldEarned > 0 || Object.values(offline.matsEarned).some(v=>v>0))){
      state.gold += offline.goldEarned;
      state.totalGoldEarned += offline.goldEarned;
      for(const m of MAT_TYPES){
        state.materials[m] += offline.matsEarned[m];
      }
      // Show offline panel
      const hours = Math.floor(offline.elapsed/3600);
      const mins = Math.floor((offline.elapsed%3600)/60);
      let timeStr = '';
      if(hours > 0) timeStr += `${hours}ÏãúÍ∞Ñ `;
      timeStr += `${mins}Î∂Ñ`;

      const info = document.getElementById('offline-info');
      let html = `<p>‚è∞ ${timeStr} ÎèôÏïà Í≥®Î†òÎì§Ïù¥ ÏùºÌñàÏäµÎãàÎã§!</p>`;
      if(offline.goldEarned > 0) html += `<p style="color:#fbbf24;font-size:1.3rem">üí∞ +${formatNum(offline.goldEarned)} Gold</p>`;
      for(const m of MAT_TYPES){
        if(offline.matsEarned[m] > 0) html += `<p style="color:${MAT_COLORS_L[m]}">${MAT_EMOJIS[m]} +${offline.matsEarned[m]}</p>`;
      }
      html += `<button class="btn" style="margin-top:15px" onclick="togglePanel('offline-panel')">ÌôïÏù∏</button>`;
      info.innerHTML = html;
      setTimeout(()=>{
        document.getElementById('offline-panel').classList.add('active');
      }, 500);
    }
  }

  // Hide loading screen
  setTimeout(()=>{
    const loading = document.getElementById('loading');
    loading.style.opacity = '0';
    setTimeout(()=>loading.remove(), 500);
  }, 300);

  saveGame();
  requestAnimationFrame(gameLoop);
}

init();
</script>
</body>
</html>
