<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>üê≤ Monster Forge - Î™¨Ïä§ÌÑ∞ ÎåÄÏû•Í∞Ñ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1a0033 0%, #330033 100%);
            color: #fff;
            overflow: hidden;
            touch-action: none;
        }
        #gameCanvas {
            display: block;
            margin: 0 auto;
            background: linear-gradient(180deg, #0f001a 0%, #1a0033 100%);
            cursor: pointer;
            box-shadow: 0 0 40px rgba(138, 43, 226, 0.6);
        }
        .hud {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
            z-index: 10;
        }
        .stat-box {
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 15px;
            border-radius: 8px;
            border: 2px solid #8a2be2;
            box-shadow: 0 0 15px rgba(138, 43, 226, 0.5);
            pointer-events: auto;
        }
        .gold {
            font-size: 20px;
            font-weight: bold;
            color: #ffd700;
            text-shadow: 0 0 10px #ffd700;
        }
        .combat-power {
            font-size: 16px;
            color: #ff4444;
            margin-top: 5px;
        }
        .level-info {
            font-size: 14px;
            color: #4af;
        }
        #buyBtn, #offlineBtn {
            position: absolute;
            bottom: 20px;
            padding: 12px 25px;
            font-size: 18px;
            font-weight: bold;
            background: linear-gradient(135deg, #8a2be2 0%, #4b0082 100%);
            color: #fff;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(138, 43, 226, 0.5);
            z-index: 10;
        }
        #buyBtn {
            left: 20px;
        }
        #offlineBtn {
            right: 20px;
            font-size: 14px;
            padding: 8px 15px;
            display: none;
        }
        #buyBtn:active, #offlineBtn:active {
            transform: scale(0.95);
        }
        .particle {
            position: absolute;
            pointer-events: none;
            border-radius: 50%;
        }
        #tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            padding: 10px;
            border-radius: 5px;
            border: 2px solid #8a2be2;
            display: none;
            z-index: 100;
            pointer-events: none;
            min-width: 150px;
        }
        .tooltip-title {
            font-size: 16px;
            font-weight: bold;
            color: #ffd700;
            margin-bottom: 5px;
        }
        .tooltip-stat {
            font-size: 12px;
            color: #ccc;
            margin: 2px 0;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div class="hud">
        <div class="stat-box">
            <div class="gold">üí∞ <span id="goldDisplay">0</span></div>
            <div class="combat-power">‚öîÔ∏è Power: <span id="powerDisplay">0</span></div>
            <div class="level-info">üíÄ Stage: <span id="stageDisplay">1</span></div>
        </div>
        <div class="stat-box">
            <div class="level-info">üê≤ Monsters: <span id="monsterCount">0</span>/9</div>
            <div class="level-info">‚≠ê Best: <span id="bestStar">1</span></div>
        </div>
    </div>
    <button id="buyBtn">üõí ÏÜåÌôò (100üí∞)</button>
    <button id="offlineBtn">üí§ Ïò§ÌîÑÎùºÏù∏ ÏàòÏùµ</button>
    <div id="tooltip">
        <div class="tooltip-title"></div>
        <div class="tooltip-stat"></div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Responsive canvas
        function resizeCanvas() {
            const dpr = window.devicePixelRatio || 1;
            canvas.width = Math.min(600, window.innerWidth) * dpr;
            canvas.height = Math.min(800, window.innerHeight) * dpr;
            canvas.style.width = Math.min(600, window.innerWidth) + 'px';
            canvas.style.height = Math.min(800, window.innerHeight) + 'px';
            ctx.scale(dpr, dpr);
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Audio Context
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        function playSound(type) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            
            if (type === 'click') {
                osc.frequency.value = 400;
                gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.1);
            } else if (type === 'merge') {
                osc.frequency.value = 600;
                gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.3);
            } else if (type === 'buy') {
                osc.frequency.value = 800;
                gain.gain.setValueAtTime(0.12, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.2);
            } else if (type === 'combat') {
                osc.frequency.value = 200;
                osc.type = 'sawtooth';
                gain.gain.setValueAtTime(0.08, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.15);
            } else if (type === 'levelup') {
                osc.frequency.value = 1200;
                gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(1600, audioCtx.currentTime + 0.3);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.4);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.4);
            }
        }

        // Monster types with unique colors and stats
        const monsterTypes = [
            { star: 1, name: 'Imp', color: '#888', power: 1, emoji: 'üëπ' },
            { star: 2, name: 'Goblin', color: '#6b8e23', power: 3, emoji: 'üë∫' },
            { star: 3, name: 'Orc', color: '#8b4513', power: 8, emoji: 'üßå' },
            { star: 4, name: 'Troll', color: '#556b2f', power: 20, emoji: 'üóø' },
            { star: 5, name: 'Demon', color: '#8b0000', power: 50, emoji: 'üòà' },
            { star: 6, name: 'Drake', color: '#4169e1', power: 120, emoji: 'üêâ' },
            { star: 7, name: 'Wyrm', color: '#9370db', power: 300, emoji: 'üê≤' },
            { star: 8, name: 'Hydra', color: '#ff1493', power: 700, emoji: 'ü¶é' },
            { star: 9, name: 'Titan', color: '#ffd700', power: 1500, emoji: '‚ö°' },
            { star: 10, name: 'Ancient', color: '#ff00ff', power: 3500, emoji: 'üëë' }
        ];

        // Game state
        let gameState = {
            gold: 0,
            stage: 1,
            monsters: [],
            lastSaveTime: Date.now(),
            totalPower: 0,
            bestStar: 1,
            combatTimer: 0,
            shakeAmount: 0,
            particles: [],
            draggedMonster: null,
            upgradeCosts: { power: 100, speed: 100 },
            upgradeLevel: { power: 0, speed: 0 }
        };

        // Grid setup (3x3)
        const GRID_SIZE = 3;
        const CELL_SIZE = 80;
        const GRID_PADDING = 20;
        const GRID_START_Y = 150;

        function getCellPosition(index) {
            const row = Math.floor(index / GRID_SIZE);
            const col = index % GRID_SIZE;
            const gridWidth = GRID_SIZE * CELL_SIZE + (GRID_SIZE - 1) * GRID_PADDING;
            const startX = (canvas.width / (window.devicePixelRatio || 1) - gridWidth) / 2;
            return {
                x: startX + col * (CELL_SIZE + GRID_PADDING),
                y: GRID_START_Y + row * (CELL_SIZE + GRID_PADDING)
            };
        }

        function getGridIndex(x, y) {
            for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
                const pos = getCellPosition(i);
                if (x >= pos.x && x <= pos.x + CELL_SIZE &&
                    y >= pos.y && y <= pos.y + CELL_SIZE) {
                    return i;
                }
            }
            return -1;
        }

        // Save/Load
        function saveGame() {
            gameState.lastSaveTime = Date.now();
            localStorage.setItem('monsterForge', JSON.stringify(gameState));
        }

        function loadGame() {
            const saved = localStorage.getItem('monsterForge');
            if (saved) {
                const loaded = JSON.parse(saved);
                gameState = { ...gameState, ...loaded };
                
                // Calculate offline earnings
                const timeDiff = Date.now() - gameState.lastSaveTime;
                const secondsOffline = Math.floor(timeDiff / 1000);
                if (secondsOffline > 0 && gameState.totalPower > 0) {
                    const offlineGold = Math.floor(secondsOffline * gameState.totalPower * 0.1);
                    if (offlineGold > 0) {
                        gameState.gold += offlineGold;
                        showOfflineReward(offlineGold, secondsOffline);
                    }
                }
            }
            updateUI();
        }

        function showOfflineReward(gold, seconds) {
            const btn = document.getElementById('offlineBtn');
            btn.textContent = `üí§ +${gold}üí∞ (${Math.floor(seconds/60)}Î∂Ñ)`;
            btn.style.display = 'block';
            setTimeout(() => {
                btn.style.display = 'none';
            }, 5000);
        }

        // Buy monster
        document.getElementById('buyBtn').addEventListener('click', () => {
            const cost = 100;
            if (gameState.gold >= cost && gameState.monsters.length < 9) {
                gameState.gold -= cost;
                const newMonster = {
                    id: Date.now() + Math.random(),
                    star: 1,
                    gridIndex: gameState.monsters.length
                };
                gameState.monsters.push(newMonster);
                playSound('buy');
                createParticles(getCellPosition(newMonster.gridIndex).x + CELL_SIZE/2, 
                               getCellPosition(newMonster.gridIndex).y + CELL_SIZE/2, 
                               '#8a2be2', 10);
                recalculatePower();
                updateUI();
                saveGame();
            } else if (gameState.monsters.length >= 9) {
                shakeScreen(10);
            }
        });

        // Touch/Mouse handling
        let touchStart = { x: 0, y: 0 };
        let isDragging = false;

        canvas.addEventListener('mousedown', handleStart);
        canvas.addEventListener('touchstart', handleStart);
        canvas.addEventListener('mousemove', handleMove);
        canvas.addEventListener('touchmove', handleMove);
        canvas.addEventListener('mouseup', handleEnd);
        canvas.addEventListener('touchend', handleEnd);

        function handleStart(e) {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
            const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
            
            const gridIdx = getGridIndex(x, y);
            if (gridIdx !== -1) {
                const monster = gameState.monsters.find(m => m.gridIndex === gridIdx);
                if (monster) {
                    gameState.draggedMonster = monster;
                    isDragging = true;
                    touchStart = { x, y };
                    playSound('click');
                }
            }
        }

        function handleMove(e) {
            if (!isDragging || !gameState.draggedMonster) return;
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
            const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
            
            // Show tooltip
            showTooltip(x, y, gameState.draggedMonster);
        }

        function handleEnd(e) {
            if (!isDragging || !gameState.draggedMonster) return;
            e.preventDefault();
            
            const rect = canvas.getBoundingClientRect();
            const x = (e.changedTouches ? e.changedTouches[0].clientX : e.clientX) - rect.left;
            const y = (e.changedTouches ? e.changedTouches[0].clientY : e.clientY) - rect.top;
            
            const targetIdx = getGridIndex(x, y);
            if (targetIdx !== -1 && targetIdx !== gameState.draggedMonster.gridIndex) {
                const targetMonster = gameState.monsters.find(m => m.gridIndex === targetIdx);
                
                // Merge if same star level
                if (targetMonster && targetMonster.star === gameState.draggedMonster.star && 
                    targetMonster.star < 10) {
                    // Merge!
                    targetMonster.star++;
                    gameState.monsters = gameState.monsters.filter(m => m.id !== gameState.draggedMonster.id);
                    
                    // Update best star
                    if (targetMonster.star > gameState.bestStar) {
                        gameState.bestStar = targetMonster.star;
                        playSound('levelup');
                    } else {
                        playSound('merge');
                    }
                    
                    const pos = getCellPosition(targetIdx);
                    createParticles(pos.x + CELL_SIZE/2, pos.y + CELL_SIZE/2, 
                                   monsterTypes[targetMonster.star - 1].color, 20);
                    shakeScreen(5);
                    
                    recalculatePower();
                    saveGame();
                } else if (!targetMonster) {
                    // Just move
                    gameState.draggedMonster.gridIndex = targetIdx;
                    playSound('click');
                }
            }
            
            isDragging = false;
            gameState.draggedMonster = null;
            hideTooltip();
            updateUI();
        }

        function showTooltip(x, y, monster) {
            const tooltip = document.getElementById('tooltip');
            const monsterType = monsterTypes[monster.star - 1];
            tooltip.querySelector('.tooltip-title').textContent = `${monsterType.emoji} ${monsterType.name} ‚≠ê${monster.star}`;
            tooltip.querySelector('.tooltip-stat').textContent = `‚öîÔ∏è Power: ${monsterType.power}`;
            tooltip.style.left = (x + 10) + 'px';
            tooltip.style.top = (y + 10) + 'px';
            tooltip.style.display = 'block';
        }

        function hideTooltip() {
            document.getElementById('tooltip').style.display = 'none';
        }

        function recalculatePower() {
            gameState.totalPower = gameState.monsters.reduce((sum, m) => {
                return sum + monsterTypes[m.star - 1].power;
            }, 0);
        }

        // Combat system (idle)
        function updateCombat(deltaTime) {
            gameState.combatTimer += deltaTime;
            
            if (gameState.combatTimer >= 1000) { // Every 1 second
                gameState.combatTimer = 0;
                
                if (gameState.totalPower > 0) {
                    const goldEarned = Math.floor(gameState.totalPower * 0.5);
                    gameState.gold += goldEarned;
                    
                    // Random combat particle
                    const randomMonster = gameState.monsters[Math.floor(Math.random() * gameState.monsters.length)];
                    if (randomMonster) {
                        const pos = getCellPosition(randomMonster.gridIndex);
                        createParticles(pos.x + CELL_SIZE/2, pos.y + CELL_SIZE/2, '#ff4444', 5);
                    }
                    
                    playSound('combat');
                    updateUI();
                }
                
                // Stage progression
                if (gameState.gold >= gameState.stage * 1000) {
                    gameState.stage++;
                    playSound('levelup');
                    shakeScreen(8);
                }
                
                saveGame();
            }
        }

        // Particles
        function createParticles(x, y, color, count) {
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 2 + Math.random() * 4;
                gameState.particles.push({
                    x, y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 1,
                    color,
                    size: 3 + Math.random() * 5
                });
            }
        }

        function updateParticles(deltaTime) {
            gameState.particles = gameState.particles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.2; // gravity
                p.life -= deltaTime / 1000;
                return p.life > 0;
            });
        }

        // Screen shake
        function shakeScreen(amount) {
            gameState.shakeAmount = amount;
        }

        // Render
        function render() {
            const w = canvas.width / (window.devicePixelRatio || 1);
            const h = canvas.height / (window.devicePixelRatio || 1);
            
            // Clear with shake offset
            let shakeX = 0, shakeY = 0;
            if (gameState.shakeAmount > 0) {
                shakeX = (Math.random() - 0.5) * gameState.shakeAmount;
                shakeY = (Math.random() - 0.5) * gameState.shakeAmount;
                gameState.shakeAmount *= 0.9;
                if (gameState.shakeAmount < 0.5) gameState.shakeAmount = 0;
            }
            
            ctx.save();
            ctx.translate(shakeX, shakeY);
            
            ctx.fillStyle = 'rgba(15, 0, 26, 0.3)';
            ctx.fillRect(0, 0, w, h);
            
            // Draw grid
            for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
                const pos = getCellPosition(i);
                ctx.strokeStyle = '#8a2be2';
                ctx.lineWidth = 2;
                ctx.strokeRect(pos.x, pos.y, CELL_SIZE, CELL_SIZE);
                
                ctx.fillStyle = 'rgba(138, 43, 226, 0.1)';
                ctx.fillRect(pos.x, pos.y, CELL_SIZE, CELL_SIZE);
            }
            
            // Draw monsters
            gameState.monsters.forEach(monster => {
                const pos = getCellPosition(monster.gridIndex);
                const monsterType = monsterTypes[monster.star - 1];
                
                // Glow effect
                ctx.shadowBlur = 15;
                ctx.shadowColor = monsterType.color;
                
                // Monster body
                ctx.fillStyle = monsterType.color;
                ctx.beginPath();
                ctx.arc(pos.x + CELL_SIZE/2, pos.y + CELL_SIZE/2, 25, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
                
                // Emoji
                ctx.font = '30px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(monsterType.emoji, pos.x + CELL_SIZE/2, pos.y + CELL_SIZE/2);
                
                // Star rating
                ctx.font = '12px Arial';
                ctx.fillStyle = '#ffd700';
                ctx.fillText('‚≠ê'.repeat(monster.star), pos.x + CELL_SIZE/2, pos.y + CELL_SIZE - 10);
            });
            
            // Draw particles
            gameState.particles.forEach(p => {
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
            
            ctx.restore();
        }

        function updateUI() {
            document.getElementById('goldDisplay').textContent = Math.floor(gameState.gold);
            document.getElementById('powerDisplay').textContent = gameState.totalPower;
            document.getElementById('stageDisplay').textContent = gameState.stage;
            document.getElementById('monsterCount').textContent = gameState.monsters.length;
            document.getElementById('bestStar').textContent = gameState.bestStar;
        }

        // Game loop
        let lastTime = Date.now();
        function gameLoop() {
            const now = Date.now();
            const deltaTime = now - lastTime;
            lastTime = now;
            
            updateCombat(deltaTime);
            updateParticles(deltaTime);
            render();
            
            requestAnimationFrame(gameLoop);
        }

        // Initialize
        loadGame();
        gameLoop();
        
        // Periodic save
        setInterval(saveGame, 5000);
    </script>
</body>
</html>
