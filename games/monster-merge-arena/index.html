<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Monster Merge Arena - Î™¨Ïä§ÌÑ∞ Ìï©ÏÑ± Î∞∞ÌãÄ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #fff;
            overflow: hidden;
            height: 100vh;
            touch-action: none;
        }

        #game-container {
            max-width: 480px;
            margin: 0 auto;
            height: 100vh;
            display: flex;
            flex-direction: column;
            padding: 8px;
            position: relative;
        }

        /* Header */
        #header {
            background: rgba(0, 0, 0, 0.5);
            padding: 12px;
            border-radius: 12px;
            margin-bottom: 8px;
            backdrop-filter: blur(10px);
        }

        #resources {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .resource {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 18px;
            font-weight: bold;
            color: #ffd700;
        }

        #wave-info {
            text-align: center;
            font-size: 16px;
            color: #00ff88;
            font-weight: bold;
        }

        #progress-bar {
            width: 100%;
            height: 20px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            overflow: hidden;
            margin-top: 8px;
            position: relative;
        }

        #progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b, #ff3838);
            width: 0%;
            transition: width 0.3s;
            position: relative;
            overflow: hidden;
        }

        #progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        /* Battle Arena */
        #battle-arena {
            flex: 1;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            margin-bottom: 8px;
            position: relative;
            overflow: hidden;
        }

        #battle-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        #enemies-container {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            pointer-events: none;
        }

        .enemy {
            background: rgba(255, 0, 0, 0.2);
            border: 2px solid #ff0000;
            border-radius: 8px;
            padding: 6px 10px;
            font-size: 20px;
            position: relative;
            animation: enemyFloat 3s ease-in-out infinite;
        }

        @keyframes enemyFloat {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }

        .enemy-hp {
            position: absolute;
            bottom: -8px;
            left: 0;
            right: 0;
            height: 4px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 2px;
            overflow: hidden;
        }

        .enemy-hp-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ff6b6b);
            transition: width 0.2s;
        }

        /* Merge Grid */
        #merge-section {
            background: rgba(0, 0, 0, 0.5);
            padding: 12px;
            border-radius: 12px;
            margin-bottom: 8px;
        }

        #merge-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-bottom: 12px;
        }

        .grid-slot {
            aspect-ratio: 1;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            overflow: hidden;
        }

        .grid-slot.has-monster {
            background: rgba(100, 150, 255, 0.2);
            border-color: rgba(100, 150, 255, 0.5);
        }

        .grid-slot.drag-over {
            background: rgba(0, 255, 100, 0.3);
            border-color: #00ff88;
            transform: scale(1.05);
        }

        .grid-slot.dragging {
            opacity: 0.5;
            transform: scale(0.95);
        }

        .monster-level {
            position: absolute;
            top: 4px;
            right: 4px;
            background: rgba(0, 0, 0, 0.7);
            color: #ffd700;
            padding: 2px 6px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: bold;
        }

        .monster-element {
            position: absolute;
            bottom: 4px;
            left: 4px;
            font-size: 14px;
        }

        /* Controls */
        #controls {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
        }

        button {
            flex: 1;
            padding: 14px;
            font-size: 16px;
            font-weight: bold;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: scale(0.95);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #summon-btn {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            box-shadow: 0 4px 15px rgba(245, 87, 108, 0.4);
        }

        #upgrade-btn {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            box-shadow: 0 4px 15px rgba(79, 172, 254, 0.4);
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            padding: 24px;
            border-radius: 16px;
            max-width: 400px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.1);
        }

        .modal-header {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 20px;
            text-align: center;
            color: #00ff88;
        }

        .upgrade-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 12px;
            border: 2px solid rgba(255, 255, 255, 0.1);
        }

        .upgrade-name {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 4px;
            color: #ffd700;
        }

        .upgrade-desc {
            font-size: 12px;
            color: #aaa;
            margin-bottom: 8px;
        }

        .upgrade-level {
            font-size: 14px;
            color: #00ff88;
            margin-bottom: 8px;
        }

        .upgrade-button {
            width: 100%;
            padding: 10px;
            font-size: 14px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            font-weight: bold;
        }

        .upgrade-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .codex-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
        }

        .codex-item {
            aspect-ratio: 1;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            position: relative;
        }

        .codex-item.unlocked {
            background: rgba(100, 150, 255, 0.2);
            border-color: rgba(100, 150, 255, 0.5);
        }

        .codex-item.locked {
            filter: grayscale(100%) brightness(0.3);
        }

        .close-modal {
            margin-top: 16px;
            width: 100%;
            padding: 12px;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 16px;
            cursor: pointer;
        }

        /* Animations */
        @keyframes shake {
            0%, 100% { transform: translate(0, 0); }
            10%, 30%, 50%, 70%, 90% { transform: translate(-5px, 0); }
            20%, 40%, 60%, 80% { transform: translate(5px, 0); }
        }

        .shake {
            animation: shake 0.5s;
        }

        @keyframes glow {
            0%, 100% { box-shadow: 0 0 20px rgba(0, 255, 136, 0.5); }
            50% { box-shadow: 0 0 40px rgba(0, 255, 136, 1); }
        }

        .glow {
            animation: glow 1s;
        }

        /* Particle effects */
        .particle {
            position: absolute;
            pointer-events: none;
            border-radius: 50%;
            animation: particleFloat 1s forwards;
        }

        @keyframes particleFloat {
            0% {
                opacity: 1;
                transform: translate(0, 0) scale(1);
            }
            100% {
                opacity: 0;
                transform: translate(var(--tx), var(--ty)) scale(0);
            }
        }

        /* Bottom tabs */
        #bottom-tabs {
            display: flex;
            gap: 8px;
        }

        .tab-btn {
            flex: 1;
            padding: 12px;
            font-size: 14px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        /* Offline earnings */
        #offline-modal .modal-content {
            text-align: center;
        }

        #offline-earnings {
            font-size: 48px;
            color: #ffd700;
            margin: 20px 0;
            font-weight: bold;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        #offline-time {
            font-size: 18px;
            color: #aaa;
            margin-bottom: 20px;
        }

        /* Boss alert */
        #boss-alert {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            font-weight: bold;
            color: #ff0000;
            text-shadow: 0 0 20px rgba(255, 0, 0, 0.8);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 100;
        }

        #boss-alert.active {
            animation: bossAlert 2s forwards;
        }

        @keyframes bossAlert {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            50% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1); }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="header">
            <div id="resources">
                <div class="resource">üí∞ <span id="gold">0</span></div>
                <div class="resource">üíé <span id="gems">0</span></div>
            </div>
            <div id="wave-info">Wave <span id="wave">1</span> / Stage <span id="stage">1</span></div>
            <div id="progress-bar">
                <div id="progress-fill"></div>
            </div>
        </div>

        <div id="battle-arena">
            <canvas id="battle-canvas"></canvas>
            <div id="enemies-container"></div>
            <div id="boss-alert">‚ö†Ô∏è BOSS APPROACHING ‚ö†Ô∏è</div>
        </div>

        <div id="merge-section">
            <div id="merge-grid"></div>
            <div id="controls">
                <button id="summon-btn">ÏÜåÌôò (üí∞ <span id="summon-cost">100</span>)</button>
                <button id="upgrade-btn">ÏóÖÍ∑∏Î†àÏù¥Îìú</button>
            </div>
        </div>

        <div id="bottom-tabs">
            <button class="tab-btn" id="codex-btn">üìñ ÎèÑÍ∞ê</button>
            <button class="tab-btn" id="save-btn">üíæ Ï†ÄÏû•</button>
        </div>
    </div>

    <!-- Upgrade Modal -->
    <div id="upgrade-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">üîß ÏóÖÍ∑∏Î†àÏù¥Îìú</div>
            <div id="upgrade-list"></div>
            <button class="close-modal" onclick="closeModal('upgrade-modal')">Îã´Í∏∞</button>
        </div>
    </div>

    <!-- Codex Modal -->
    <div id="codex-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">üìñ Î™¨Ïä§ÌÑ∞ ÎèÑÍ∞ê</div>
            <div class="codex-grid" id="codex-grid"></div>
            <button class="close-modal" onclick="closeModal('codex-modal')">Îã´Í∏∞</button>
        </div>
    </div>

    <!-- Offline Earnings Modal -->
    <div id="offline-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">üí§ Ïò§ÌîÑÎùºÏù∏ ÏàòÏùµ</div>
            <div id="offline-time"></div>
            <div id="offline-earnings"></div>
            <button class="close-modal" onclick="closeOfflineModal()">Î∞õÍ∏∞</button>
        </div>
    </div>

    <script>
        // ==================== CONSTANTS ====================
        const GRID_SIZE = 12; // 3x4
        const ELEMENTS = ['üî•', 'üßä', '‚ö°', '‚ò†Ô∏è']; // Fire, Ice, Lightning, Poison
        const ELEMENT_NAMES = ['Fire', 'Ice', 'Lightning', 'Poison'];
        
        const MONSTERS = {
            1: ['üê≠', 'üêü', 'üêõ', 'üê∏'],
            2: ['üê∫', 'üêß', 'ü¶Ö', 'üêç'],
            3: ['ü¶Å', 'üêª', 'ü¶à', 'ü¶Ç'],
            4: ['üêâ', 'ü¶à', 'ü¶Ö', 'üêô'],
            5: ['üëπ', 'üßä', '‚ö°', '‚ò†Ô∏è'],
            6: ['üëø', '‚ùÑÔ∏è', '‚ö°', 'üíÄ'],
            7: ['üî•', 'üßä', '‚ö°', '‚ò†Ô∏è']
        };

        const ENEMY_TYPES = ['üëæ', 'üëΩ', 'ü§ñ', 'üí©'];
        const BOSS_TYPES = ['üê≤', 'üë∫', 'ü¶ñ', 'ü¶ë'];

        // ==================== GAME STATE ====================
        let gameState = {
            gold: 100,
            gems: 0,
            wave: 1,
            stage: 1,
            grid: Array(GRID_SIZE).fill(null),
            upgrades: {
                attack: 0,
                attackSpeed: 0,
                summonCost: 0,
                critical: 0,
                goldBonus: 0
            },
            codex: new Set(),
            lastSave: Date.now(),
            enemies: [],
            monsters: []
        };

        // ==================== AUDIO ====================
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        function playSound(type) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);

            switch(type) {
                case 'merge':
                    osc.frequency.value = 440;
                    gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
                    osc.start(audioCtx.currentTime);
                    osc.stop(audioCtx.currentTime + 0.3);
                    break;
                case 'attack':
                    osc.frequency.value = 200;
                    gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                    osc.start(audioCtx.currentTime);
                    osc.stop(audioCtx.currentTime + 0.1);
                    break;
                case 'boss':
                    osc.frequency.value = 100;
                    gain.gain.setValueAtTime(0.5, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
                    osc.start(audioCtx.currentTime);
                    osc.stop(audioCtx.currentTime + 0.5);
                    break;
                case 'levelup':
                    osc.frequency.value = 880;
                    gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.4);
                    osc.start(audioCtx.currentTime);
                    osc.stop(audioCtx.currentTime + 0.4);
                    break;
            }
        }

        // ==================== UI UPDATES ====================
        function updateUI() {
            document.getElementById('gold').textContent = Math.floor(gameState.gold);
            document.getElementById('gems').textContent = gameState.gems;
            document.getElementById('wave').textContent = gameState.wave;
            document.getElementById('stage').textContent = gameState.stage;
            
            const summonCost = getSummonCost();
            document.getElementById('summon-cost').textContent = summonCost;
            document.getElementById('summon-btn').disabled = gameState.gold < summonCost;

            // Update progress bar
            const enemiesAlive = gameState.enemies.filter(e => e.hp > 0).length;
            const totalEnemies = gameState.wave % 10 === 0 ? 1 : Math.min(5, Math.floor(gameState.wave / 3) + 3);
            const progress = ((totalEnemies - enemiesAlive) / totalEnemies) * 100;
            document.getElementById('progress-fill').style.width = progress + '%';
        }

        function getSummonCost() {
            const base = 100;
            const reduction = gameState.upgrades.summonCost * 0.05;
            return Math.floor(base * Math.pow(1.1, gameState.stage) * (1 - reduction));
        }

        // ==================== GRID MANAGEMENT ====================
        function initGrid() {
            const gridContainer = document.getElementById('merge-grid');
            gridContainer.innerHTML = '';
            
            for (let i = 0; i < GRID_SIZE; i++) {
                const slot = document.createElement('div');
                slot.className = 'grid-slot';
                slot.dataset.index = i;
                slot.draggable = false;
                
                slot.addEventListener('touchstart', handleTouchStart, { passive: false });
                slot.addEventListener('touchmove', handleTouchMove, { passive: false });
                slot.addEventListener('touchend', handleTouchEnd, { passive: false });
                
                slot.addEventListener('mousedown', handleMouseDown);
                
                gridContainer.appendChild(slot);
            }
            
            renderGrid();
        }

        let draggedSlot = null;
        let touchStartPos = { x: 0, y: 0 };
        let isDragging = false;

        function handleTouchStart(e) {
            e.preventDefault();
            const slot = e.currentTarget;
            const index = parseInt(slot.dataset.index);
            
            if (gameState.grid[index]) {
                draggedSlot = index;
                touchStartPos = {
                    x: e.touches[0].clientX,
                    y: e.touches[0].clientY
                };
                slot.classList.add('dragging');
            }
        }

        function handleTouchMove(e) {
            e.preventDefault();
            if (draggedSlot === null) return;
            
            const touch = e.touches[0];
            const deltaX = Math.abs(touch.clientX - touchStartPos.x);
            const deltaY = Math.abs(touch.clientY - touchStartPos.y);
            
            if (deltaX > 10 || deltaY > 10) {
                isDragging = true;
            }
            
            if (isDragging) {
                const element = document.elementFromPoint(touch.clientX, touch.clientY);
                document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
                
                if (element && element.classList.contains('grid-slot')) {
                    element.classList.add('drag-over');
                }
            }
        }

        function handleTouchEnd(e) {
            e.preventDefault();
            if (draggedSlot === null) return;
            
            const touch = e.changedTouches[0];
            const element = document.elementFromPoint(touch.clientX, touch.clientY);
            
            if (element && element.classList.contains('grid-slot')) {
                const targetIndex = parseInt(element.dataset.index);
                attemptMerge(draggedSlot, targetIndex);
            }
            
            document.querySelectorAll('.dragging').forEach(el => el.classList.remove('dragging'));
            document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
            
            draggedSlot = null;
            isDragging = false;
        }

        function handleMouseDown(e) {
            const slot = e.currentTarget;
            const index = parseInt(slot.dataset.index);
            
            if (gameState.grid[index]) {
                draggedSlot = index;
                slot.classList.add('dragging');
                
                const onMouseMove = (e) => {
                    const element = document.elementFromPoint(e.clientX, e.clientY);
                    document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
                    if (element && element.classList.contains('grid-slot')) {
                        element.classList.add('drag-over');
                    }
                };
                
                const onMouseUp = (e) => {
                    const element = document.elementFromPoint(e.clientX, e.clientY);
                    if (element && element.classList.contains('grid-slot')) {
                        const targetIndex = parseInt(element.dataset.index);
                        attemptMerge(draggedSlot, targetIndex);
                    }
                    
                    document.querySelectorAll('.dragging').forEach(el => el.classList.remove('dragging'));
                    document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
                    draggedSlot = null;
                    
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                };
                
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            }
        }

        function attemptMerge(fromIndex, toIndex) {
            if (fromIndex === toIndex) return;
            
            const from = gameState.grid[fromIndex];
            const to = gameState.grid[toIndex];
            
            if (!from) return;
            
            // Empty slot - move
            if (!to) {
                gameState.grid[toIndex] = from;
                gameState.grid[fromIndex] = null;
                renderGrid();
                return;
            }
            
            // Merge
            if (from.level === to.level && from.element === to.element && from.level < 7) {
                const newLevel = from.level + 1;
                gameState.grid[toIndex] = {
                    level: newLevel,
                    element: from.element
                };
                gameState.grid[fromIndex] = null;
                
                const monsterKey = `${newLevel}-${from.element}`;
                gameState.codex.add(monsterKey);
                
                playSound('merge');
                createMergeEffect(toIndex);
                document.getElementById('game-container').classList.add('shake');
                setTimeout(() => {
                    document.getElementById('game-container').classList.remove('shake');
                }, 500);
                
                renderGrid();
            }
        }

        function createMergeEffect(slotIndex) {
            const slot = document.querySelectorAll('.grid-slot')[slotIndex];
            slot.classList.add('glow');
            setTimeout(() => slot.classList.remove('glow'), 1000);
            
            // Particles
            const rect = slot.getBoundingClientRect();
            for (let i = 0; i < 20; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = rect.left + rect.width / 2 + 'px';
                particle.style.top = rect.top + rect.height / 2 + 'px';
                particle.style.width = '8px';
                particle.style.height = '8px';
                particle.style.background = `hsl(${Math.random() * 360}, 100%, 50%)`;
                particle.style.setProperty('--tx', (Math.random() - 0.5) * 200 + 'px');
                particle.style.setProperty('--ty', (Math.random() - 0.5) * 200 + 'px');
                document.body.appendChild(particle);
                
                setTimeout(() => particle.remove(), 1000);
            }
        }

        function renderGrid() {
            const slots = document.querySelectorAll('.grid-slot');
            
            slots.forEach((slot, index) => {
                const monster = gameState.grid[index];
                
                if (monster) {
                    const emoji = MONSTERS[monster.level][monster.element];
                    const element = ELEMENTS[monster.element];
                    
                    slot.innerHTML = `
                        ${emoji}
                        <span class="monster-level">Lv${monster.level}</span>
                        <span class="monster-element">${element}</span>
                    `;
                    slot.classList.add('has-monster');
                } else {
                    slot.innerHTML = '';
                    slot.classList.remove('has-monster');
                }
            });
        }

        // ==================== SUMMONING ====================
        function summonMonster() {
            const cost = getSummonCost();
            if (gameState.gold < cost) return;
            
            const emptySlot = gameState.grid.findIndex(slot => slot === null);
            if (emptySlot === -1) {
                alert('Í∑∏Î¶¨ÎìúÍ∞Ä Í∞ÄÎìù Ï∞ºÏäµÎãàÎã§!');
                return;
            }
            
            gameState.gold -= cost;
            
            const level = Math.random() < 0.7 ? 1 : Math.random() < 0.8 ? 2 : 3;
            const element = Math.floor(Math.random() * 4);
            
            gameState.grid[emptySlot] = { level, element };
            
            const monsterKey = `${level}-${element}`;
            gameState.codex.add(monsterKey);
            
            playSound('levelup');
            renderGrid();
            updateUI();
        }

        // ==================== BATTLE SYSTEM ====================
        const canvas = document.getElementById('battle-canvas');
        const ctx = canvas.getContext('2d');

        function resizeCanvas() {
            const container = document.getElementById('battle-arena');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        function spawnWave() {
            const isBoss = gameState.wave % 10 === 0;
            gameState.enemies = [];
            
            if (isBoss) {
                showBossAlert();
                gameState.enemies.push({
                    hp: 1000 * gameState.stage * gameState.wave,
                    maxHp: 1000 * gameState.stage * gameState.wave,
                    type: BOSS_TYPES[Math.floor(Math.random() * BOSS_TYPES.length)],
                    isBoss: true
                });
            } else {
                const count = Math.min(5, Math.floor(gameState.wave / 3) + 3);
                for (let i = 0; i < count; i++) {
                    gameState.enemies.push({
                        hp: 50 * gameState.stage * gameState.wave,
                        maxHp: 50 * gameState.stage * gameState.wave,
                        type: ENEMY_TYPES[Math.floor(Math.random() * ENEMY_TYPES.length)],
                        isBoss: false
                    });
                }
            }
            
            renderEnemies();
        }

        function showBossAlert() {
            const alert = document.getElementById('boss-alert');
            alert.classList.add('active');
            playSound('boss');
            setTimeout(() => alert.classList.remove('active'), 2000);
        }

        function renderEnemies() {
            const container = document.getElementById('enemies-container');
            container.innerHTML = '';
            
            gameState.enemies.forEach((enemy, index) => {
                if (enemy.hp <= 0) return;
                
                const enemyDiv = document.createElement('div');
                enemyDiv.className = 'enemy';
                enemyDiv.style.fontSize = enemy.isBoss ? '40px' : '20px';
                enemyDiv.innerHTML = `
                    ${enemy.type}
                    <div class="enemy-hp">
                        <div class="enemy-hp-fill" style="width: ${(enemy.hp / enemy.maxHp) * 100}%"></div>
                    </div>
                `;
                container.appendChild(enemyDiv);
            });
        }

        function battleTick() {
            if (gameState.enemies.length === 0 || gameState.enemies.every(e => e.hp <= 0)) {
                completeWave();
                return;
            }
            
            const activeMonsters = gameState.grid.filter(m => m !== null);
            if (activeMonsters.length === 0) return;
            
            activeMonsters.forEach(monster => {
                const damage = calculateDamage(monster);
                const target = gameState.enemies.find(e => e.hp > 0);
                
                if (target) {
                    applyDamage(target, damage, monster.element);
                }
            });
            
            renderEnemies();
            updateUI();
        }

        function calculateDamage(monster) {
            const baseDamage = 10 * monster.level;
            const attackBonus = 1 + gameState.upgrades.attack * 0.1;
            const critChance = gameState.upgrades.critical * 0.05;
            const isCrit = Math.random() < critChance;
            
            return baseDamage * attackBonus * (isCrit ? 2 : 1);
        }

        function applyDamage(enemy, damage, element) {
            enemy.hp -= damage;
            playSound('attack');
            
            // Element effects
            switch(element) {
                case 0: // Fire - AOE
                    gameState.enemies.forEach(e => {
                        if (e.hp > 0 && e !== enemy) {
                            e.hp -= damage * 0.3;
                        }
                    });
                    createParticleEffect('#ff6b00');
                    break;
                case 1: // Ice - Slow (visual only)
                    createParticleEffect('#00d4ff');
                    break;
                case 2: // Lightning - Chain
                    const chainTarget = gameState.enemies.find(e => e.hp > 0 && e !== enemy);
                    if (chainTarget) {
                        chainTarget.hp -= damage * 0.5;
                    }
                    createParticleEffect('#ffff00');
                    break;
                case 3: // Poison - DOT
                    enemy.poisonDot = (enemy.poisonDot || 0) + damage * 0.1;
                    createParticleEffect('#00ff00');
                    break;
            }
            
            if (enemy.hp <= 0) {
                enemy.hp = 0;
            }
        }

        function createParticleEffect(color) {
            ctx.fillStyle = color;
            const x = Math.random() * canvas.width;
            const y = Math.random() * canvas.height * 0.3;
            ctx.beginPath();
            ctx.arc(x, y, 5, 0, Math.PI * 2);
            ctx.fill();
        }

        function completeWave() {
            const isBoss = gameState.wave % 10 === 0;
            const goldReward = Math.floor(50 * gameState.stage * gameState.wave * (1 + gameState.upgrades.goldBonus * 0.1));
            
            gameState.gold += goldReward;
            
            if (isBoss) {
                gameState.stage++;
                gameState.wave = 1;
                gameState.gems += 10;
                playSound('levelup');
            } else {
                gameState.wave++;
            }
            
            setTimeout(() => {
                spawnWave();
                updateUI();
            }, 1000);
        }

        // ==================== UPGRADES ====================
        function openUpgradeModal() {
            const modal = document.getElementById('upgrade-modal');
            const list = document.getElementById('upgrade-list');
            list.innerHTML = '';
            
            const upgrades = [
                { key: 'attack', name: 'Í≥µÍ≤©Î†•', desc: 'Î™¨Ïä§ÌÑ∞ Í≥µÍ≤©Î†• +10%', cost: 500 },
                { key: 'attackSpeed', name: 'Í≥µÍ≤© ÏÜçÎèÑ', desc: 'Í≥µÍ≤© ÏÜçÎèÑ +5%', cost: 400 },
                { key: 'summonCost', name: 'ÏÜåÌôò ÎπÑÏö© Í∞êÏÜå', desc: 'ÏÜåÌôò ÎπÑÏö© -5%', cost: 600 },
                { key: 'critical', name: 'ÌÅ¨Î¶¨Ìã∞Ïª¨', desc: 'ÏπòÎ™ÖÌÉÄ ÌôïÎ•† +5%', cost: 700 },
                { key: 'goldBonus', name: 'Í≥®Îìú ÌöçÎìùÎüâ', desc: 'Í≥®Îìú ÌöçÎìù +10%', cost: 550 }
            ];
            
            upgrades.forEach(upgrade => {
                const level = gameState.upgrades[upgrade.key];
                const cost = Math.floor(upgrade.cost * Math.pow(1.5, level));
                
                const item = document.createElement('div');
                item.className = 'upgrade-item';
                item.innerHTML = `
                    <div class="upgrade-name">${upgrade.name}</div>
                    <div class="upgrade-desc">${upgrade.desc}</div>
                    <div class="upgrade-level">Î†àÎ≤®: ${level}</div>
                    <button class="upgrade-button" onclick="buyUpgrade('${upgrade.key}', ${cost})"
                        ${gameState.gold < cost ? 'disabled' : ''}>
                        ÏóÖÍ∑∏Î†àÏù¥Îìú (üí∞ ${cost})
                    </button>
                `;
                list.appendChild(item);
            });
            
            modal.classList.add('active');
        }

        function buyUpgrade(key, cost) {
            if (gameState.gold < cost) return;
            
            gameState.gold -= cost;
            gameState.upgrades[key]++;
            
            playSound('levelup');
            updateUI();
            openUpgradeModal(); // Refresh
        }

        function closeModal(modalId) {
            document.getElementById(modalId).classList.remove('active');
        }

        // ==================== CODEX ====================
        function openCodex() {
            const modal = document.getElementById('codex-modal');
            const grid = document.getElementById('codex-grid');
            grid.innerHTML = '';
            
            for (let level = 1; level <= 7; level++) {
                for (let element = 0; element < 4; element++) {
                    const key = `${level}-${element}`;
                    const unlocked = gameState.codex.has(key);
                    
                    const item = document.createElement('div');
                    item.className = `codex-item ${unlocked ? 'unlocked' : 'locked'}`;
                    item.innerHTML = unlocked ? MONSTERS[level][element] : '‚ùì';
                    item.title = unlocked ? `Lv${level} ${ELEMENT_NAMES[element]}` : '???';
                    grid.appendChild(item);
                }
            }
            
            modal.classList.add('active');
        }

        // ==================== SAVE/LOAD ====================
        function saveGame() {
            const saveData = {
                ...gameState,
                grid: gameState.grid,
                codex: Array.from(gameState.codex),
                lastSave: Date.now()
            };
            
            localStorage.setItem('monsterMergeArena', JSON.stringify(saveData));
            alert('Í≤åÏûÑÏù¥ Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§!');
        }

        function loadGame() {
            const saved = localStorage.getItem('monsterMergeArena');
            if (!saved) return false;
            
            try {
                const data = JSON.parse(saved);
                gameState = {
                    ...data,
                    codex: new Set(data.codex),
                    enemies: [],
                    monsters: []
                };
                
                // Calculate offline earnings
                const offlineTime = Date.now() - data.lastSave;
                const offlineHours = offlineTime / (1000 * 60 * 60);
                const offlineGold = Math.floor(offlineHours * 100 * gameState.stage);
                
                if (offlineGold > 0) {
                    showOfflineEarnings(offlineTime, offlineGold);
                }
                
                return true;
            } catch (e) {
                console.error('Load failed:', e);
                return false;
            }
        }

        function showOfflineEarnings(time, gold) {
            const hours = Math.floor(time / (1000 * 60 * 60));
            const minutes = Math.floor((time % (1000 * 60 * 60)) / (1000 * 60));
            
            document.getElementById('offline-time').textContent = 
                `Ïò§ÌîÑÎùºÏù∏: ${hours}ÏãúÍ∞Ñ ${minutes}Î∂Ñ`;
            document.getElementById('offline-earnings').textContent = `+${gold}`;
            
            const modal = document.getElementById('offline-modal');
            modal.classList.add('active');
            
            gameState.offlineGold = gold;
        }

        function closeOfflineModal() {
            if (gameState.offlineGold) {
                gameState.gold += gameState.offlineGold;
                gameState.offlineGold = 0;
            }
            closeModal('offline-modal');
        }

        // ==================== EVENT LISTENERS ====================
        document.getElementById('summon-btn').addEventListener('click', summonMonster);
        document.getElementById('upgrade-btn').addEventListener('click', openUpgradeModal);
        document.getElementById('codex-btn').addEventListener('click', openCodex);
        document.getElementById('save-btn').addEventListener('click', saveGame);

        // ==================== GAME LOOP ====================
        let lastBattleTick = Date.now();
        let lastAutoSave = Date.now();

        function gameLoop() {
            const now = Date.now();
            
            // Battle tick (attack speed dependent)
            const attackInterval = 1000 / (1 + gameState.upgrades.attackSpeed * 0.05);
            if (now - lastBattleTick > attackInterval) {
                battleTick();
                lastBattleTick = now;
            }
            
            // Auto save every 30s
            if (now - lastAutoSave > 30000) {
                saveGame();
                lastAutoSave = now;
            }
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            requestAnimationFrame(gameLoop);
        }

        // ==================== INITIALIZATION ====================
        function init() {
            const loaded = loadGame();
            
            if (!loaded) {
                // New game - add starter monsters
                gameState.grid[0] = { level: 1, element: 0 };
                gameState.grid[1] = { level: 1, element: 1 };
                gameState.codex.add('1-0');
                gameState.codex.add('1-1');
            }
            
            initGrid();
            spawnWave();
            updateUI();
            gameLoop();
        }

        // Start game
        window.addEventListener('load', init);

        // Prevent context menu on long press
        document.addEventListener('contextmenu', e => e.preventDefault());
    </script>
</body>
</html>
