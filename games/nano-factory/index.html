<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
<title>Nano Factory - ë‚˜ë…¸ íŒ©í† ë¦¬</title>
<style>
*{margin:0;padding:0;box-sizing:border-box;-webkit-tap-highlight-color:transparent}
:root{--bg:#0a0b1e;--panel:#111328;--accent:#00e5ff;--accent2:#7c4dff;--gold:#ffd740;--green:#69f0ae;--red:#ff5252;--text:#e0e0e0;--sub:#888;--grid-bg:#0d0e24;--cell:#161838;--cell-hover:#1e2050;--border:#2a2d5a}
html,body{width:100%;height:100%;overflow:hidden;font-family:'Segoe UI',system-ui,-apple-system,sans-serif;background:var(--bg);color:var(--text)}
#game-container{display:flex;width:100%;height:100%;position:relative}
canvas#mainCanvas{display:block;background:var(--grid-bg)}
#ui-overlay{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:10}
#ui-overlay>*{pointer-events:auto}
#top-bar{position:absolute;top:0;left:0;right:0;height:48px;background:linear-gradient(180deg,rgba(17,19,40,0.95),rgba(17,19,40,0.8));display:flex;align-items:center;padding:0 12px;gap:12px;z-index:20;border-bottom:1px solid var(--border);backdrop-filter:blur(8px)}
.res-display{display:flex;align-items:center;gap:4px;font-size:13px;background:rgba(0,0,0,0.3);padding:4px 10px;border-radius:8px;border:1px solid var(--border)}
.res-display .icon{font-size:16px}
.res-display .val{color:var(--accent);font-weight:700;font-variant-numeric:tabular-nums}
.res-display .label{color:var(--sub);font-size:11px}
#menu-btn{background:none;border:1px solid var(--border);color:var(--text);padding:6px 10px;border-radius:8px;cursor:pointer;font-size:14px;margin-left:auto}
#menu-btn:hover{border-color:var(--accent);color:var(--accent)}
#side-panel{position:absolute;top:48px;right:0;width:280px;height:calc(100% - 48px);background:var(--panel);border-left:1px solid var(--border);overflow-y:auto;z-index:15;transition:transform 0.3s}
#side-panel.hidden{transform:translateX(100%)}
.panel-section{padding:12px;border-bottom:1px solid var(--border)}
.panel-title{font-size:13px;color:var(--accent);font-weight:700;margin-bottom:8px;text-transform:uppercase;letter-spacing:1px}
.part-btn{display:flex;align-items:center;gap:8px;width:100%;padding:8px 10px;margin-bottom:4px;background:rgba(0,0,0,0.2);border:1px solid var(--border);border-radius:8px;color:var(--text);cursor:pointer;font-size:12px;text-align:left;transition:all 0.15s}
.part-btn:hover{border-color:var(--accent);background:rgba(0,229,255,0.08)}
.part-btn.selected{border-color:var(--accent);background:rgba(0,229,255,0.15);box-shadow:0 0 12px rgba(0,229,255,0.2)}
.part-btn.locked{opacity:0.4;cursor:not-allowed}
.part-btn .p-icon{font-size:20px;width:28px;text-align:center}
.part-btn .p-info{flex:1}
.part-btn .p-name{font-weight:600}
.part-btn .p-cost{color:var(--gold);font-size:11px}
.part-btn .p-desc{color:var(--sub);font-size:10px;margin-top:2px}
.upgrade-btn{width:100%;padding:8px;margin-bottom:4px;background:linear-gradient(135deg,rgba(124,77,255,0.2),rgba(0,229,255,0.1));border:1px solid var(--accent2);border-radius:8px;color:var(--text);cursor:pointer;font-size:12px;text-align:left}
.upgrade-btn:hover{background:linear-gradient(135deg,rgba(124,77,255,0.35),rgba(0,229,255,0.2))}
.upgrade-btn.maxed{opacity:0.5;border-color:var(--green);cursor:default}
.upgrade-btn .u-name{font-weight:600}
.upgrade-btn .u-cost{color:var(--gold);font-size:11px}
.upgrade-btn .u-level{color:var(--green);font-size:11px;float:right}
#bottom-bar{position:absolute;bottom:0;left:0;right:0;display:flex;align-items:center;justify-content:center;gap:8px;padding:8px 12px;background:linear-gradient(0deg,rgba(17,19,40,0.95),rgba(17,19,40,0.7));z-index:20;border-top:1px solid var(--border);backdrop-filter:blur(8px)}
.tab-btn{padding:6px 14px;border-radius:8px;border:1px solid var(--border);background:rgba(0,0,0,0.3);color:var(--sub);font-size:12px;cursor:pointer;transition:all 0.15s}
.tab-btn.active{border-color:var(--accent);color:var(--accent);background:rgba(0,229,255,0.1)}
.tab-btn:hover{border-color:var(--accent)}
#tooltip{position:absolute;display:none;background:rgba(17,19,40,0.95);border:1px solid var(--accent);border-radius:8px;padding:10px;font-size:12px;max-width:220px;z-index:100;pointer-events:none;backdrop-filter:blur(8px)}
#tooltip .tt-title{font-weight:700;color:var(--accent);margin-bottom:4px}
#tooltip .tt-desc{color:var(--sub);margin-bottom:4px}
#tooltip .tt-stats{color:var(--green)}
#modal-overlay{position:absolute;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.7);display:none;align-items:center;justify-content:center;z-index:200}
#modal-overlay.show{display:flex}
.modal{background:var(--panel);border:1px solid var(--accent);border-radius:16px;padding:24px;max-width:450px;width:90%;max-height:80vh;overflow-y:auto;text-align:center}
.modal h2{color:var(--accent);margin-bottom:12px;font-size:20px}
.modal p{color:var(--sub);font-size:13px;margin-bottom:8px;line-height:1.5}
.modal-btn{padding:10px 24px;border-radius:8px;border:none;cursor:pointer;font-size:14px;font-weight:600;margin:4px}
.modal-btn.primary{background:linear-gradient(135deg,var(--accent),var(--accent2));color:#000}
.modal-btn.secondary{background:rgba(255,255,255,0.1);color:var(--text);border:1px solid var(--border)}
.modal-btn:hover{filter:brightness(1.2)}
#prestige-modal .prestige-info{background:rgba(124,77,255,0.15);border:1px solid var(--accent2);border-radius:8px;padding:12px;margin:12px 0}
#prestige-modal .prestige-info .val{color:var(--gold);font-size:24px;font-weight:700}
.research-tree{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:8px}
.research-node{padding:8px;border:1px solid var(--border);border-radius:8px;background:rgba(0,0,0,0.2);cursor:pointer;text-align:center;font-size:11px;transition:all 0.15s}
.research-node:hover{border-color:var(--accent2)}
.research-node.unlocked{border-color:var(--green);background:rgba(105,240,174,0.1)}
.research-node.available{border-color:var(--gold);background:rgba(255,215,64,0.08)}
.research-node .r-icon{font-size:20px}
.research-node .r-name{font-weight:600;margin:2px 0}
.research-node .r-cost{color:var(--gold);font-size:10px}
.product-list{max-height:300px;overflow-y:auto}
.product-item{display:flex;align-items:center;gap:8px;padding:6px 8px;border-bottom:1px solid rgba(255,255,255,0.05);font-size:12px}
.product-item .pr-icon{font-size:18px}
.product-item .pr-name{flex:1}
.product-item .pr-price{color:var(--gold)}
.product-item .pr-count{color:var(--green);font-variant-numeric:tabular-nums}
.product-item.locked{opacity:0.3}
#tutorial-overlay{position:absolute;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.8);display:none;z-index:300;align-items:center;justify-content:center}
#tutorial-overlay.show{display:flex}
.tutorial-box{background:var(--panel);border:2px solid var(--accent);border-radius:16px;padding:24px;max-width:400px;width:90%;text-align:center}
.tutorial-box h2{color:var(--accent);margin-bottom:12px}
.tutorial-box p{color:var(--sub);font-size:13px;line-height:1.6;margin-bottom:12px}
.tutorial-box .step-indicator{color:var(--accent2);font-size:12px;margin-bottom:8px}
.tutorial-box .highlight{color:var(--accent);font-weight:700}
#notification{position:absolute;top:56px;left:50%;transform:translateX(-50%);padding:8px 20px;background:linear-gradient(135deg,rgba(0,229,255,0.9),rgba(124,77,255,0.9));color:#000;font-weight:700;font-size:13px;border-radius:8px;z-index:50;opacity:0;transition:opacity 0.3s;pointer-events:none}
#notification.show{opacity:1}
.speed-controls{display:flex;gap:4px;margin-left:8px}
.speed-btn{padding:4px 8px;border-radius:6px;border:1px solid var(--border);background:rgba(0,0,0,0.3);color:var(--sub);font-size:11px;cursor:pointer}
.speed-btn.active{border-color:var(--gold);color:var(--gold);background:rgba(255,215,64,0.1)}
@media(max-width:768px){
#side-panel{width:100%;height:55%;top:auto;bottom:0;border-left:none;border-top:1px solid var(--border)}
#side-panel.hidden{transform:translateY(100%)}
.res-display{padding:3px 6px;font-size:11px}
.res-display .icon{font-size:14px}
#bottom-bar{bottom:0}
}
::-webkit-scrollbar{width:6px}
::-webkit-scrollbar-track{background:var(--bg)}
::-webkit-scrollbar-thumb{background:var(--border);border-radius:3px}
::-webkit-scrollbar-thumb:hover{background:var(--accent)}
</style>
</head>
<body>
<div id="game-container">
<canvas id="mainCanvas"></canvas>
<div id="ui-overlay">
<div id="top-bar">
<div class="res-display"><span class="icon">ğŸ’°</span><span class="val" id="money-val">0</span></div>
<div class="res-display"><span class="icon">âš¡</span><span class="val" id="energy-val">0</span></div>
<div class="res-display"><span class="icon">ğŸ“¦</span><span class="val" id="products-val">0</span><span class="label">/s</span></div>
<div class="res-display"><span class="icon">ğŸ”¬</span><span class="val" id="rp-val">0</span></div>
<div class="speed-controls">
<button class="speed-btn active" data-speed="1">1x</button>
<button class="speed-btn" data-speed="2">2x</button>
<button class="speed-btn" data-speed="5">5x</button>
</div>
<button id="menu-btn" onclick="toggleMenu()">â˜°</button>
</div>
<div id="side-panel" class="hidden">
<div id="panel-content"></div>
</div>
<div id="bottom-bar">
<button class="tab-btn active" data-tab="parts" onclick="switchTab('parts')">ğŸ”§ ë¶€í’ˆ</button>
<button class="tab-btn" data-tab="upgrades" onclick="switchTab('upgrades')">â¬†ï¸ ê°•í™”</button>
<button class="tab-btn" data-tab="research" onclick="switchTab('research')">ğŸ”¬ ì—°êµ¬</button>
<button class="tab-btn" data-tab="products" onclick="switchTab('products')">ğŸ“¦ ì œí’ˆ</button>
<button class="tab-btn" data-tab="prestige" onclick="switchTab('prestige')">âš›ï¸ ì–‘ì</button>
</div>
<div id="tooltip"></div>
<div id="notification"></div>
</div>
<div id="modal-overlay" onclick="if(event.target===this)closeModal()">
<div class="modal" id="modal-box"></div>
</div>
<div id="tutorial-overlay">
<div class="tutorial-box" id="tutorial-box"></div>
</div>
</div>
<script>
"use strict";
// ========== GAME CONSTANTS ==========
const CELL_SIZE = 64;
const ANIM_SPEED = 0.016;
const SAVE_KEY = 'nanoFactory_v1';
const AUTOSAVE_INTERVAL = 30000;

// ========== PART DEFINITIONS ==========
const PART_TYPES = {
    collector: {
        name: 'ìˆ˜ì§‘ê¸°', nameEn: 'Collector', icon: 'ğŸ”µ', color: '#00bcd4',
        desc: 'ì›ìì¬ë¥¼ ìˆ˜ì§‘í•©ë‹ˆë‹¤', baseCost: 10, costMult: 1.15,
        baseRate: 1.0, output: 'raw', input: null, tier: 0
    },
    converter: {
        name: 'ë³€í™˜ê¸°', nameEn: 'Converter', icon: 'ğŸŸ¡', color: '#ffc107',
        desc: 'ì›ìì¬ë¥¼ ê°€ê³µ ì¬ë£Œë¡œ ë³€í™˜', baseCost: 25, costMult: 1.18,
        baseRate: 0.8, output: 'processed', input: 'raw', tier: 0
    },
    assembler: {
        name: 'ì¡°ë¦½ê¸°', nameEn: 'Assembler', icon: 'ğŸŸ¢', color: '#4caf50',
        desc: 'ê°€ê³µ ì¬ë£Œë¡œ ì œí’ˆ ì¡°ë¦½', baseCost: 50, costMult: 1.2,
        baseRate: 0.5, output: 'product', input: 'processed', tier: 0
    },
    shipper: {
        name: 'ì¶œí•˜ê¸°', nameEn: 'Shipper', icon: 'ğŸŸ£', color: '#9c27b0',
        desc: 'ì™„ì„±í’ˆì„ íŒë§¤í•˜ì—¬ ìˆ˜ìµ ì°½ì¶œ', baseCost: 40, costMult: 1.18,
        baseRate: 0.6, output: 'money', input: 'product', tier: 0
    },
    refiner: {
        name: 'ì •ì œê¸°', nameEn: 'Refiner', icon: 'ğŸ’', color: '#e91e63',
        desc: 'ì¬ë£Œ í’ˆì§ˆ í–¥ìƒ (2ë°° ê°€ì¹˜)', baseCost: 100, costMult: 1.25,
        baseRate: 0.4, output: 'refined', input: 'processed', tier: 1
    },
    splitter: {
        name: 'ë¶„ë°°ê¸°', nameEn: 'Splitter', icon: 'ğŸ”€', color: '#ff9800',
        desc: 'ìì›ì„ ì—¬ëŸ¬ ë°©í–¥ìœ¼ë¡œ ë¶„ë°°', baseCost: 75, costMult: 1.2,
        baseRate: 1.2, output: 'split', input: 'any', tier: 1
    },
    merger: {
        name: 'í•©ë¥˜ê¸°', nameEn: 'Merger', icon: 'ğŸ”„', color: '#2196f3',
        desc: 'ì—¬ëŸ¬ ì…ë ¥ì„ í•˜ë‚˜ë¡œ í•©ì¹¨', baseCost: 75, costMult: 1.2,
        baseRate: 1.2, output: 'merged', input: 'multi', tier: 1
    },
    accelerator: {
        name: 'ê°€ì†ê¸°', nameEn: 'Accelerator', icon: 'âš¡', color: '#ffeb3b',
        desc: 'ì¸ì ‘ ë¶€í’ˆ ì†ë„ +50%', baseCost: 150, costMult: 1.3,
        baseRate: 0, output: 'boost', input: null, tier: 2
    },
    quantumCore: {
        name: 'ì–‘ì ì½”ì–´', nameEn: 'Quantum Core', icon: 'ğŸ’ ', color: '#7c4dff',
        desc: 'ëª¨ë“  ìì› ì²˜ë¦¬ (ëŠë¦¬ì§€ë§Œ ë§ŒëŠ¥)', baseCost: 500, costMult: 1.4,
        baseRate: 0.3, output: 'any', input: 'any', tier: 3
    },
    storage: {
        name: 'ì €ì¥ì†Œ', nameEn: 'Storage', icon: 'ğŸ“¦', color: '#607d8b',
        desc: 'ìì› ë²„í¼ (ìš©ëŸ‰ +100)', baseCost: 60, costMult: 1.15,
        baseRate: 0, output: 'buffer', input: 'any', tier: 1
    },
    advAssembler: {
        name: 'ê³ ê¸‰ ì¡°ë¦½ê¸°', nameEn: 'Adv. Assembler', icon: 'ğŸ”©', color: '#00e676',
        desc: 'ì •ì œ ì¬ë£Œë¡œ ê³ ê¸‰ ì œí’ˆ ìƒì‚°', baseCost: 200, costMult: 1.25,
        baseRate: 0.35, output: 'advProduct', input: 'refined', tier: 2
    },
    teleporter: {
        name: 'í…”ë ˆí¬í„°', nameEn: 'Teleporter', icon: 'ğŸŒ€', color: '#00bfa5',
        desc: 'ìì›ì„ ë‹¤ë¥¸ í…”ë ˆí¬í„°ë¡œ ì „ì†¡', baseCost: 300, costMult: 1.3,
        baseRate: 1.0, output: 'teleport', input: 'any', tier: 3
    }
};

// ========== PRODUCT DEFINITIONS ==========
const PRODUCTS = [
    { id: 'nanoWire', name: 'ë‚˜ë…¸ ì™€ì´ì–´', icon: 'ã€°ï¸', basePrice: 5, tier: 0, req: 'assembler' },
    { id: 'nanoChip', name: 'ë‚˜ë…¸ ì¹©', icon: 'ğŸ”²', basePrice: 12, tier: 0, req: 'assembler' },
    { id: 'nanoSensor', name: 'ë‚˜ë…¸ ì„¼ì„œ', icon: 'ğŸ“¡', basePrice: 20, tier: 1, req: 'research_sensors' },
    { id: 'nanoBattery', name: 'ë‚˜ë…¸ ë°°í„°ë¦¬', icon: 'ğŸ”‹', basePrice: 28, tier: 1, req: 'research_energy' },
    { id: 'nanoMotor', name: 'ë‚˜ë…¸ ëª¨í„°', icon: 'âš™ï¸', basePrice: 35, tier: 1, req: 'research_mechanics' },
    { id: 'nanoLens', name: 'ë‚˜ë…¸ ë Œì¦ˆ', icon: 'ğŸ”', basePrice: 50, tier: 2, req: 'refiner' },
    { id: 'nanoMembrane', name: 'ë‚˜ë…¸ ë©¤ë¸Œë ˆì¸', icon: 'ğŸ§«', basePrice: 65, tier: 2, req: 'research_bio' },
    { id: 'nanoCoil', name: 'ë‚˜ë…¸ ì½”ì¼', icon: 'ğŸŒ€', basePrice: 80, tier: 2, req: 'research_magnetics' },
    { id: 'nanoCrystal', name: 'ë‚˜ë…¸ í¬ë¦¬ìŠ¤íƒˆ', icon: 'ğŸ’', basePrice: 120, tier: 3, req: 'advAssembler' },
    { id: 'quantumDot', name: 'ì–‘ìì ', icon: 'âœ¨', basePrice: 200, tier: 3, req: 'research_quantum' },
    { id: 'nanoBot', name: 'ë‚˜ë…¸ë´‡', icon: 'ğŸ¤–', basePrice: 350, tier: 4, req: 'research_ai' },
    { id: 'quantumProcessor', name: 'ì–‘ì í”„ë¡œì„¸ì„œ', icon: 'ğŸ§ ', basePrice: 500, tier: 4, req: 'quantumCore' }
];

// ========== RESEARCH DEFINITIONS ==========
const RESEARCH = {
    speed1: { name: 'ì†ë„ ì—°êµ¬ I', icon: 'â©', desc: 'ëª¨ë“  ë¶€í’ˆ ì†ë„ +20%', cost: 50, effect: { speed: 0.2 }, prereq: [], tier: 0 },
    speed2: { name: 'ì†ë„ ì—°êµ¬ II', icon: 'â©', desc: 'ëª¨ë“  ë¶€í’ˆ ì†ë„ +30%', cost: 200, effect: { speed: 0.3 }, prereq: ['speed1'], tier: 1 },
    efficiency1: { name: 'íš¨ìœ¨ ì—°êµ¬ I', icon: 'â™»ï¸', desc: 'ë³€í™˜ íš¨ìœ¨ +25%', cost: 75, effect: { efficiency: 0.25 }, prereq: [], tier: 0 },
    efficiency2: { name: 'íš¨ìœ¨ ì—°êµ¬ II', icon: 'â™»ï¸', desc: 'ë³€í™˜ íš¨ìœ¨ +40%', cost: 300, effect: { efficiency: 0.4 }, prereq: ['efficiency1'], tier: 1 },
    quality1: { name: 'í’ˆì§ˆ ì—°êµ¬ I', icon: 'â­', desc: 'ì œí’ˆ ê°€ê²© +30%', cost: 100, effect: { quality: 0.3 }, prereq: [], tier: 0 },
    quality2: { name: 'í’ˆì§ˆ ì—°êµ¬ II', icon: 'â­', desc: 'ì œí’ˆ ê°€ê²© +50%', cost: 400, effect: { quality: 0.5 }, prereq: ['quality1'], tier: 1 },
    research_sensors: { name: 'ì„¼ì„œ ê¸°ìˆ ', icon: 'ğŸ“¡', desc: 'ë‚˜ë…¸ ì„¼ì„œ ì–¸ë½', cost: 80, effect: { unlock: 'nanoSensor' }, prereq: ['efficiency1'], tier: 1 },
    research_energy: { name: 'ì—ë„ˆì§€ ê³µí•™', icon: 'ğŸ”‹', desc: 'ë‚˜ë…¸ ë°°í„°ë¦¬ ì–¸ë½', cost: 100, effect: { unlock: 'nanoBattery' }, prereq: ['efficiency1'], tier: 1 },
    research_mechanics: { name: 'ì •ë°€ ê¸°ê³„', icon: 'âš™ï¸', desc: 'ë‚˜ë…¸ ëª¨í„° ì–¸ë½', cost: 120, effect: { unlock: 'nanoMotor' }, prereq: ['speed1'], tier: 1 },
    research_bio: { name: 'ë°”ì´ì˜¤ ë‚˜ë…¸', icon: 'ğŸ§«', desc: 'ë‚˜ë…¸ ë©¤ë¸Œë ˆì¸ ì–¸ë½', cost: 250, effect: { unlock: 'nanoMembrane' }, prereq: ['research_sensors'], tier: 2 },
    research_magnetics: { name: 'ìê¸°ì¥ ê³µí•™', icon: 'ğŸ§²', desc: 'ë‚˜ë…¸ ì½”ì¼ ì–¸ë½', cost: 300, effect: { unlock: 'nanoCoil' }, prereq: ['research_energy'], tier: 2 },
    research_quantum: { name: 'ì–‘ìì—­í•™', icon: 'âš›ï¸', desc: 'ì–‘ìì  ì–¸ë½', cost: 500, effect: { unlock: 'quantumDot' }, prereq: ['research_magnetics', 'research_bio'], tier: 3 },
    research_ai: { name: 'AI ì œì–´', icon: 'ğŸ¤–', desc: 'ë‚˜ë…¸ë´‡ ì–¸ë½', cost: 800, effect: { unlock: 'nanoBot' }, prereq: ['research_quantum'], tier: 3 },
    expand1: { name: 'ê³µì¥ í™•ì¥ I', icon: 'ğŸ—ï¸', desc: 'ê·¸ë¦¬ë“œ 7x7', cost: 150, effect: { expand: 7 }, prereq: ['speed1', 'efficiency1'], tier: 1 },
    expand2: { name: 'ê³µì¥ í™•ì¥ II', icon: 'ğŸ—ï¸', desc: 'ê·¸ë¦¬ë“œ 8x8', cost: 500, effect: { expand: 8 }, prereq: ['expand1'], tier: 2 },
    expand3: { name: 'ê³µì¥ í™•ì¥ III', icon: 'ğŸ—ï¸', desc: 'ê·¸ë¦¬ë“œ 9x9', cost: 1200, effect: { expand: 9 }, prereq: ['expand2'], tier: 3 },
    expand4: { name: 'ê³µì¥ í™•ì¥ IV', icon: 'ğŸ—ï¸', desc: 'ê·¸ë¦¬ë“œ 10x10', cost: 3000, effect: { expand: 10 }, prereq: ['expand3'], tier: 3 },
    autoConnect: { name: 'ìë™ ì—°ê²°', icon: 'ğŸ”—', desc: 'ì¸ì ‘ ë¶€í’ˆ ìë™ ì—°ê²°', cost: 200, effect: { autoConnect: true }, prereq: ['speed1'], tier: 1 },
    doubleOutput: { name: 'ì´ì¤‘ ì¶œë ¥', icon: 'âœ–ï¸', desc: 'ì¶œí•˜ê¸° ìˆ˜ìµ 2ë°°', cost: 600, effect: { doubleShip: true }, prereq: ['quality2'], tier: 2 },
    energyGen: { name: 'ì—ë„ˆì§€ ìƒì„±', icon: 'âš¡', desc: 'ì—ë„ˆì§€ ìë™ ìƒì„±', cost: 100, effect: { energyGen: 1 }, prereq: [], tier: 0 },
    energyGen2: { name: 'ê³ ê¸‰ ì—ë„ˆì§€', icon: 'âš¡', desc: 'ì—ë„ˆì§€ ìƒì„± 3ë°°', cost: 350, effect: { energyGen: 3 }, prereq: ['energyGen'], tier: 1 }
};

// ========== FACTORY STAGES ==========
const FACTORY_STAGES = [
    { name: 'ë‚˜ë…¸ ì—°êµ¬ì‹¤', nameEn: 'Nano Lab', size: 6, color: '#1a237e' },
    { name: 'ë§ˆì´í¬ë¡œ ê³µì¥', nameEn: 'Micro Factory', size: 7, color: '#0d47a1' },
    { name: 'ë©”ì¡° í”ŒëœíŠ¸', nameEn: 'Meso Plant', size: 8, color: '#006064' },
    { name: 'ë§¤í¬ë¡œ ì›ìŠ¤', nameEn: 'Macro Works', size: 9, color: '#1b5e20' },
    { name: 'í€€í…€ í¬ì§€', nameEn: 'Quantum Forge', size: 10, color: '#4a148c' }
];

// ========== PRESTIGE BONUSES ==========
const PRESTIGE_BONUSES = [
    { name: 'ì–‘ì ë°°ìœ¨', desc: 'ëª¨ë“  ìˆ˜ìµ Ã—(1 + 0.1 Ã— ì–‘ìì½”ì–´)', icon: 'ğŸ’°' },
    { name: 'ì–‘ì ì†ë„', desc: 'ëª¨ë“  ë¶€í’ˆ ì†ë„ +(5% Ã— ì–‘ìì½”ì–´)', icon: 'âš¡' },
    { name: 'ì–‘ì í• ì¸', desc: 'ë¶€í’ˆ ë¹„ìš© -(3% Ã— ì–‘ìì½”ì–´)', icon: 'ğŸ·ï¸' },
    { name: 'ì–‘ì ì‹œì‘', desc: 'ì‹œì‘ ìê¸ˆ +(100 Ã— ì–‘ìì½”ì–´)', icon: 'ğŸ' }
];

// ========== GAME STATE ==========
let state = {
    money: 50,
    energy: 100,
    researchPoints: 0,
    totalEarned: 0,
    totalProducts: 0,
    productsPerSec: 0,
    grid: [],
    gridSize: 6,
    factoryStage: 0,
    selectedPart: null,
    selectedCell: null,
    placedParts: {},
    partCounts: {},
    research: {},
    productCounts: {},
    connections: [],
    quantumCores: 0,
    totalQuantumCores: 0,
    prestigeCount: 0,
    gameSpeed: 1,
    tutorialStep: -1,
    tutorialDone: false,
    stats: { totalPlaced: 0, totalSold: 0, totalResearch: 0, playTime: 0 },
    unlockedParts: { collector: true, converter: true, assembler: true, shipper: true },
    notifications: []
};

// ========== CANVAS & RENDERING ==========
const canvas = document.getElementById('mainCanvas');
const ctx = canvas.getContext('2d');
let canvasW, canvasH;
let camX = 0, camY = 0, camZoom = 1;
let isDragging = false, dragStartX = 0, dragStartY = 0, camStartX = 0, camStartY = 0;
let isPlacing = false;
let hoverCell = null;
let particles = [];
let flowParticles = [];
let animTime = 0;
let lastTime = 0;
let panelOpen = false;
let currentTab = 'parts';
let selectedGridPart = null;

// ========== AUDIO ENGINE ==========
const AudioEngine = {
    ctx: null,
    init() {
        if (this.ctx) return;
        try {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        } catch(e) { console.warn('No Web Audio'); }
    },
    play(type) {
        if (!this.ctx) return;
        const now = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        switch(type) {
            case 'place':
                osc.type = 'sine';
                osc.frequency.setValueAtTime(440, now);
                osc.frequency.exponentialRampToValueAtTime(880, now + 0.1);
                gain.gain.setValueAtTime(0.15, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                osc.start(now); osc.stop(now + 0.2);
                break;
            case 'produce':
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(523, now);
                osc.frequency.exponentialRampToValueAtTime(784, now + 0.08);
                osc.frequency.exponentialRampToValueAtTime(1047, now + 0.15);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.25);
                osc.start(now); osc.stop(now + 0.25);
                break;
            case 'upgrade':
                osc.type = 'square';
                osc.frequency.setValueAtTime(330, now);
                osc.frequency.exponentialRampToValueAtTime(660, now + 0.1);
                osc.frequency.exponentialRampToValueAtTime(990, now + 0.2);
                gain.gain.setValueAtTime(0.08, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.35);
                osc.start(now); osc.stop(now + 0.35);
                break;
            case 'sell':
                osc.type = 'sine';
                osc.frequency.setValueAtTime(600, now);
                osc.frequency.exponentialRampToValueAtTime(1200, now + 0.05);
                osc.frequency.setValueAtTime(800, now + 0.05);
                osc.frequency.exponentialRampToValueAtTime(1600, now + 0.1);
                gain.gain.setValueAtTime(0.12, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                osc.start(now); osc.stop(now + 0.2);
                break;
            case 'research':
                osc.type = 'sine';
                osc.frequency.setValueAtTime(261, now);
                osc.frequency.exponentialRampToValueAtTime(523, now + 0.15);
                osc.frequency.exponentialRampToValueAtTime(784, now + 0.25);
                osc.frequency.exponentialRampToValueAtTime(1047, now + 0.35);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
                osc.start(now); osc.stop(now + 0.5);
                break;
            case 'prestige':
                for (let i = 0; i < 5; i++) {
                    const o2 = this.ctx.createOscillator();
                    const g2 = this.ctx.createGain();
                    o2.connect(g2); g2.connect(this.ctx.destination);
                    o2.type = 'sine';
                    o2.frequency.setValueAtTime(261 * (1 + i * 0.5), now + i * 0.12);
                    o2.frequency.exponentialRampToValueAtTime(1500, now + i * 0.12 + 0.3);
                    g2.gain.setValueAtTime(0.08, now + i * 0.12);
                    g2.gain.exponentialRampToValueAtTime(0.001, now + i * 0.12 + 0.4);
                    o2.start(now + i * 0.12); o2.stop(now + i * 0.12 + 0.4);
                }
                break;
            case 'error':
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(200, now);
                osc.frequency.exponentialRampToValueAtTime(100, now + 0.15);
                gain.gain.setValueAtTime(0.1, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                osc.start(now); osc.stop(now + 0.2);
                break;
            case 'click':
                osc.type = 'sine';
                osc.frequency.setValueAtTime(800, now);
                gain.gain.setValueAtTime(0.08, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
                osc.start(now); osc.stop(now + 0.05);
                break;
            case 'levelup':
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(440, now);
                osc.frequency.exponentialRampToValueAtTime(880, now + 0.1);
                gain.gain.setValueAtTime(0.12, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                osc.start(now); osc.stop(now + 0.3);
                const o3 = this.ctx.createOscillator();
                const g3 = this.ctx.createGain();
                o3.connect(g3); g3.connect(this.ctx.destination);
                o3.type = 'triangle';
                o3.frequency.setValueAtTime(660, now + 0.1);
                o3.frequency.exponentialRampToValueAtTime(1320, now + 0.2);
                g3.gain.setValueAtTime(0.12, now + 0.1);
                g3.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
                o3.start(now + 0.1); o3.stop(now + 0.4);
                break;
        }
    }
};

// ========== PARTICLE SYSTEM ==========
function spawnParticles(x, y, color, count, options = {}) {
    for (let i = 0; i < count; i++) {
        particles.push({
            x, y,
            vx: (Math.random() - 0.5) * (options.spread || 100),
            vy: (Math.random() - 0.5) * (options.spread || 100) - (options.upward ? 50 : 0),
            life: 1.0,
            decay: 0.5 + Math.random() * 1.5,
            size: (options.size || 3) + Math.random() * 3,
            color: color,
            type: options.type || 'circle',
            rotation: Math.random() * Math.PI * 2,
            rotSpeed: (Math.random() - 0.5) * 5
        });
    }
}

function spawnFlowParticle(fromX, fromY, toX, toY, color) {
    flowParticles.push({
        x: fromX, y: fromY,
        targetX: toX, targetY: toY,
        progress: 0,
        speed: 0.8 + Math.random() * 0.5,
        color: color,
        size: 2 + Math.random() * 2
    });
}

function updateParticles(dt) {
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.vy += 30 * dt;
        p.life -= p.decay * dt;
        p.rotation += p.rotSpeed * dt;
        if (p.life <= 0) particles.splice(i, 1);
    }
    for (let i = flowParticles.length - 1; i >= 0; i--) {
        const p = flowParticles[i];
        p.progress += p.speed * dt;
        p.x = p.x + (p.targetX - p.x) * p.progress;
        p.y = p.y + (p.targetY - p.y) * p.progress;
        if (p.progress >= 1) flowParticles.splice(i, 1);
    }
}

function drawParticles() {
    ctx.save();
    for (const p of particles) {
        ctx.globalAlpha = Math.max(0, p.life);
        ctx.fillStyle = p.color;
        if (p.type === 'circle') {
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
            ctx.fill();
        } else if (p.type === 'star') {
            ctx.save();
            ctx.translate(p.x, p.y);
            ctx.rotate(p.rotation);
            drawStar(0, 0, p.size * p.life, 5);
            ctx.fill();
            ctx.restore();
        } else if (p.type === 'square') {
            ctx.save();
            ctx.translate(p.x, p.y);
            ctx.rotate(p.rotation);
            const s = p.size * p.life;
            ctx.fillRect(-s/2, -s/2, s, s);
            ctx.restore();
        }
    }
    for (const p of flowParticles) {
        ctx.globalAlpha = 0.8;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 0.3;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size * 2, 0, Math.PI * 2);
        ctx.fill();
    }
    ctx.restore();
}

function drawStar(cx, cy, r, points) {
    ctx.beginPath();
    for (let i = 0; i < points * 2; i++) {
        const angle = (i * Math.PI) / points - Math.PI / 2;
        const rad = i % 2 === 0 ? r : r * 0.4;
        const x = cx + Math.cos(angle) * rad;
        const y = cy + Math.sin(angle) * rad;
        i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
    }
    ctx.closePath();
}

// ========== UTILITY FUNCTIONS ==========
function formatNum(n) {
    if (n === undefined || n === null || isNaN(n)) return '0';
    if (n < 1000) return Math.floor(n).toString();
    if (n < 1e6) return (n / 1000).toFixed(1) + 'K';
    if (n < 1e9) return (n / 1e6).toFixed(2) + 'M';
    if (n < 1e12) return (n / 1e9).toFixed(2) + 'B';
    return (n / 1e12).toFixed(2) + 'T';
}

function getPartCost(type) {
    const def = PART_TYPES[type];
    if (!def) return Infinity;
    const count = state.partCounts[type] || 0;
    let cost = def.baseCost * Math.pow(def.costMult, count);
    const discount = state.quantumCores * 0.03;
    cost *= Math.max(0.3, 1 - discount);
    return Math.ceil(cost);
}

function getPartRate(type, level) {
    const def = PART_TYPES[type];
    if (!def) return 0;
    let rate = def.baseRate * (1 + (level - 1) * 0.3);
    let speedBonus = 0;
    if (state.research.speed1) speedBonus += RESEARCH.speed1.effect.speed;
    if (state.research.speed2) speedBonus += RESEARCH.speed2.effect.speed;
    speedBonus += state.quantumCores * 0.05;
    rate *= (1 + speedBonus);
    return rate;
}

function getProductPrice(product) {
    let price = product.basePrice;
    let qualityBonus = 0;
    if (state.research.quality1) qualityBonus += RESEARCH.quality1.effect.quality;
    if (state.research.quality2) qualityBonus += RESEARCH.quality2.effect.quality;
    price *= (1 + qualityBonus);
    price *= (1 + state.quantumCores * 0.1);
    if (state.research.doubleOutput) price *= 2;
    return Math.ceil(price);
}

function isPartUnlocked(type) {
    if (state.unlockedParts[type]) return true;
    const def = PART_TYPES[type];
    if (!def) return false;
    if (def.tier === 0) return true;
    if (def.tier === 1) return state.factoryStage >= 1 || state.research.expand1;
    if (def.tier === 2) return state.factoryStage >= 2 || state.research.expand2;
    if (def.tier === 3) return state.factoryStage >= 3 || state.research.expand3;
    return false;
}

function isProductUnlocked(product) {
    if (product.tier === 0) return true;
    if (product.req.startsWith('research_')) return !!state.research[product.req];
    if (PART_TYPES[product.req]) return isPartUnlocked(product.req);
    return false;
}

function isResearchAvailable(key) {
    const r = RESEARCH[key];
    if (!r) return false;
    if (state.research[key]) return false;
    for (const pre of r.prereq) {
        if (!state.research[pre]) return false;
    }
    return true;
}

function showNotification(text) {
    const el = document.getElementById('notification');
    el.textContent = text;
    el.classList.add('show');
    setTimeout(() => el.classList.remove('show'), 2000);
}

// ========== GRID OPERATIONS ==========
function initGrid(size) {
    state.gridSize = size;
    state.grid = [];
    for (let y = 0; y < size; y++) {
        state.grid[y] = [];
        for (let x = 0; x < size; x++) {
            state.grid[y][x] = null;
        }
    }
}

function getGridCell(gx, gy) {
    if (gx < 0 || gy < 0 || gx >= state.gridSize || gy >= state.gridSize) return null;
    return state.grid[gy] ? state.grid[gy][gx] : null;
}

function placePart(gx, gy, type) {
    if (gx < 0 || gy < 0 || gx >= state.gridSize || gy >= state.gridSize) return false;
    if (state.grid[gy][gx]) return false;
    const cost = getPartCost(type);
    if (state.money < cost) {
        AudioEngine.play('error');
        showNotification('ğŸ’° ìê¸ˆì´ ë¶€ì¡±í•©ë‹ˆë‹¤!');
        return false;
    }
    state.money -= cost;
    state.partCounts[type] = (state.partCounts[type] || 0) + 1;
    state.stats.totalPlaced++;
    const part = {
        type: type,
        level: 1,
        x: gx, y: gy,
        progress: 0,
        buffer: 0,
        bufferMax: 10,
        outputBuffer: 0,
        connected: [],
        active: false,
        productType: null,
        animPhase: 0,
        totalProduced: 0,
        direction: 0 // 0=right, 1=down, 2=left, 3=up
    };
    // Auto-assign product based on what's unlocked
    if (type === 'assembler' || type === 'advAssembler') {
        const available = PRODUCTS.filter(p => isProductUnlocked(p) && (type === 'advAssembler' ? p.tier >= 2 : p.tier < 2));
        if (available.length > 0) {
            part.productType = available[Math.floor(Math.random() * Math.min(3, available.length))].id;
        }
    }
    state.grid[gy][gx] = part;
    const key = `${gx},${gy}`;
    state.placedParts[key] = part;
    // Auto-connect if research unlocked
    if (state.research.autoConnect) autoConnectPart(gx, gy);
    const worldX = gx * CELL_SIZE + CELL_SIZE / 2;
    const worldY = gy * CELL_SIZE + CELL_SIZE / 2;
    spawnParticles(worldX, worldY, PART_TYPES[type].color, 12, { spread: 60, type: 'star' });
    AudioEngine.play('place');
    return true;
}

function removePart(gx, gy) {
    const cell = getGridCell(gx, gy);
    if (!cell) return false;
    const refund = Math.floor(getPartCost(cell.type) * 0.5);
    state.money += refund;
    // Remove connections
    for (const key of Object.keys(state.placedParts)) {
        const p = state.placedParts[key];
        if (p && p.connected) {
            p.connected = p.connected.filter(c => !(c.x === gx && c.y === gy));
        }
    }
    delete state.placedParts[`${gx},${gy}`];
    state.grid[gy][gx] = null;
    showNotification(`â™»ï¸ ë¶€í’ˆ í•´ì²´ (í™˜ë¶ˆ: ${formatNum(refund)})`);
    return true;
}

function upgradePart(gx, gy) {
    const cell = getGridCell(gx, gy);
    if (!cell) return false;
    const cost = Math.floor(getPartCost(cell.type) * cell.level * 0.8);
    if (state.money < cost) {
        AudioEngine.play('error');
        showNotification('ğŸ’° ìê¸ˆì´ ë¶€ì¡±í•©ë‹ˆë‹¤!');
        return false;
    }
    state.money -= cost;
    cell.level++;
    cell.bufferMax += 5;
    const worldX = gx * CELL_SIZE + CELL_SIZE / 2;
    const worldY = gy * CELL_SIZE + CELL_SIZE / 2;
    spawnParticles(worldX, worldY, '#ffd740', 15, { spread: 50, upward: true, type: 'star' });
    AudioEngine.play('upgrade');
    if (cell.level % 5 === 0) AudioEngine.play('levelup');
    showNotification(`â¬†ï¸ ${PART_TYPES[cell.type].name} Lv.${cell.level}`);
    return true;
}

function autoConnectPart(gx, gy) {
    const cell = getGridCell(gx, gy);
    if (!cell) return;
    const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
    cell.connected = [];
    for (const [dx, dy] of dirs) {
        const nx = gx + dx, ny = gy + dy;
        const neighbor = getGridCell(nx, ny);
        if (neighbor) {
            const canConnect = checkConnection(cell.type, neighbor.type);
            if (canConnect) {
                cell.connected.push({ x: nx, y: ny });
            }
        }
    }
}

function checkConnection(fromType, toType) {
    const flow = {
        collector: ['converter', 'refiner', 'splitter', 'storage', 'quantumCore'],
        converter: ['assembler', 'splitter', 'merger', 'storage', 'quantumCore'],
        refiner: ['advAssembler', 'splitter', 'merger', 'storage', 'quantumCore'],
        assembler: ['shipper', 'storage', 'quantumCore'],
        advAssembler: ['shipper', 'storage', 'quantumCore'],
        splitter: ['converter', 'assembler', 'advAssembler', 'refiner', 'shipper', 'storage', 'quantumCore'],
        merger: ['assembler', 'advAssembler', 'shipper', 'storage', 'quantumCore'],
        storage: ['converter', 'assembler', 'advAssembler', 'refiner', 'shipper', 'splitter', 'merger', 'quantumCore'],
        quantumCore: ['converter', 'assembler', 'advAssembler', 'refiner', 'shipper', 'storage'],
        teleporter: ['teleporter']
    };
    return flow[fromType] && flow[fromType].includes(toType);
}

function manualConnect(fromGX, fromGY, toGX, toGY) {
    const from = getGridCell(fromGX, fromGY);
    const to = getGridCell(toGX, toGY);
    if (!from || !to) return false;
    if (!checkConnection(from.type, to.type)) {
        showNotification('âŒ ì´ ë¶€í’ˆë“¤ì€ ì—°ê²°í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
        return false;
    }
    // Check if already connected
    if (from.connected.some(c => c.x === toGX && c.y === toGY)) {
        // Disconnect
        from.connected = from.connected.filter(c => !(c.x === toGX && c.y === toGY));
        showNotification('ğŸ”— ì—°ê²° í•´ì œ');
        return true;
    }
    from.connected.push({ x: toGX, y: toGY });
    AudioEngine.play('click');
    showNotification('ğŸ”— ì—°ê²° ì™„ë£Œ');
    return true;
}

// ========== SIMULATION ==========
let simAccumulator = 0;
const SIM_STEP = 1/20;

function simulate(dt) {
    const realDt = dt * state.gameSpeed;
    simAccumulator += realDt;
    while (simAccumulator >= SIM_STEP) {
        simAccumulator -= SIM_STEP;
        simStep(SIM_STEP);
    }
    // Energy generation
    if (state.research.energyGen) {
        let rate = RESEARCH.energyGen.effect.energyGen;
        if (state.research.energyGen2) rate = RESEARCH.energyGen2.effect.energyGen;
        state.energy += rate * dt * state.gameSpeed;
    }
    // Research points from production
    state.researchPoints += state.productsPerSec * 0.1 * dt * state.gameSpeed;
    // Stats
    state.stats.playTime += dt;
}

function simStep(dt) {
    let productsThisFrame = 0;
    // Process each placed part
    for (const key of Object.keys(state.placedParts)) {
        const part = state.placedParts[key];
        if (!part) continue;
        const def = PART_TYPES[part.type];
        if (!def) continue;
        const rate = getPartRate(part.type, part.level);
        // Check for accelerator boost
        let boost = 1;
        const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
        for (const [dx,dy] of dirs) {
            const neighbor = getGridCell(part.x + dx, part.y + dy);
            if (neighbor && neighbor.type === 'accelerator') {
                boost += 0.5 * neighbor.level;
            }
        }
        const effectiveRate = rate * boost;
        part.animPhase = (part.animPhase + dt * effectiveRate * 2) % (Math.PI * 2);
        switch(part.type) {
            case 'collector':
                part.progress += effectiveRate * dt;
                if (part.progress >= 1) {
                    part.progress -= 1;
                    part.buffer = Math.min(part.buffer + 1, part.bufferMax);
                    part.active = true;
                    part.totalProduced++;
                }
                break;
            case 'converter':
                if (part.buffer >= 1) {
                    part.progress += effectiveRate * dt;
                    if (part.progress >= 1) {
                        part.progress -= 1;
                        part.buffer--;
                        let output = 1;
                        if (state.research.efficiency1) output *= (1 + RESEARCH.efficiency1.effect.efficiency);
                        if (state.research.efficiency2) output *= (1 + RESEARCH.efficiency2.effect.efficiency);
                        part.outputBuffer = Math.min(part.outputBuffer + output, part.bufferMax);
                        part.active = true;
                        part.totalProduced++;
                    }
                } else {
                    part.active = false;
                }
                break;
            case 'refiner':
                if (part.buffer >= 1) {
                    part.progress += effectiveRate * dt;
                    if (part.progress >= 1) {
                        part.progress -= 1;
                        part.buffer--;
                        part.outputBuffer = Math.min(part.outputBuffer + 1, part.bufferMax);
                        part.active = true;
                        part.totalProduced++;
                    }
                } else { part.active = false; }
                break;
            case 'assembler':
            case 'advAssembler':
                if (part.buffer >= 1) {
                    part.progress += effectiveRate * dt;
                    if (part.progress >= 1) {
                        part.progress -= 1;
                        part.buffer--;
                        part.outputBuffer = Math.min(part.outputBuffer + 1, part.bufferMax);
                        part.active = true;
                        part.totalProduced++;
                        productsThisFrame++;
                        if (part.productType) {
                            state.productCounts[part.productType] = (state.productCounts[part.productType] || 0) + 1;
                        }
                        state.totalProducts++;
                        // Spawn production particle
                        if (Math.random() < 0.3) {
                            const wx = part.x * CELL_SIZE + CELL_SIZE/2;
                            const wy = part.y * CELL_SIZE + CELL_SIZE/2;
                            spawnParticles(wx, wy, def.color, 4, { spread: 30, type: 'circle' });
                            AudioEngine.play('produce');
                        }
                    }
                } else { part.active = false; }
                break;
            case 'shipper':
                if (part.buffer >= 1) {
                    part.progress += effectiveRate * dt;
                    if (part.progress >= 1) {
                        part.progress -= 1;
                        part.buffer--;
                        // Determine price based on what product this is
                        let price = 10;
                        const connectedAssemblers = [];
                        for (const k2 of Object.keys(state.placedParts)) {
                            const p2 = state.placedParts[k2];
                            if (p2 && (p2.type === 'assembler' || p2.type === 'advAssembler') && p2.productType) {
                                if (p2.connected.some(c => c.x === part.x && c.y === part.y)) {
                                    connectedAssemblers.push(p2);
                                }
                            }
                        }
                        if (connectedAssemblers.length > 0) {
                            const prod = PRODUCTS.find(p => p.id === connectedAssemblers[0].productType);
                            if (prod) price = getProductPrice(prod);
                        } else {
                            // Generic price
                            price = 10 * (1 + state.quantumCores * 0.1);
                            if (state.research.quality1) price *= (1 + RESEARCH.quality1.effect.quality);
                        }
                        state.money += price;
                        state.totalEarned += price;
                        state.stats.totalSold++;
                        part.active = true;
                        part.totalProduced++;
                        if (Math.random() < 0.2) {
                            const wx = part.x * CELL_SIZE + CELL_SIZE/2;
                            const wy = part.y * CELL_SIZE + CELL_SIZE/2;
                            spawnParticles(wx, wy, '#ffd740', 6, { spread: 40, upward: true, type: 'star' });
                            AudioEngine.play('sell');
                        }
                    }
                } else { part.active = false; }
                break;
            case 'splitter':
                if (part.buffer >= 1 && part.connected.length > 0) {
                    part.progress += effectiveRate * dt;
                    if (part.progress >= 1) {
                        part.progress -= 1;
                        part.buffer--;
                        // Distribute to connected
                        for (const conn of part.connected) {
                            const target = getGridCell(conn.x, conn.y);
                            if (target) {
                                target.buffer = Math.min(target.buffer + 1 / part.connected.length, target.bufferMax);
                            }
                        }
                        part.active = true;
                    }
                } else { part.active = false; }
                break;
            case 'merger':
                if (part.buffer >= 2) {
                    part.progress += effectiveRate * dt;
                    if (part.progress >= 1) {
                        part.progress -= 1;
                        part.buffer -= 2;
                        part.outputBuffer = Math.min(part.outputBuffer + 1.5, part.bufferMax);
                        part.active = true;
                    }
                } else { part.active = false; }
                break;
            case 'quantumCore':
                if (part.buffer >= 1 || part.type === 'quantumCore') {
                    part.progress += effectiveRate * dt;
                    if (part.progress >= 1) {
                        part.progress -= 1;
                        if (part.buffer >= 1) part.buffer--;
                        part.outputBuffer = Math.min(part.outputBuffer + 0.5, part.bufferMax);
                        // Also generates a bit of money directly
                        state.money += 2 * part.level;
                        state.totalEarned += 2 * part.level;
                        part.active = true;
                        part.totalProduced++;
                    }
                }
                break;
            case 'storage':
                // Storage just holds, doesn't process
                part.bufferMax = 100 + (part.level - 1) * 50;
                part.active = part.buffer > 0;
                break;
            case 'teleporter':
                // Find other teleporters and send resources
                if (part.buffer >= 1) {
                    const otherTeleporters = [];
                    for (const k2 of Object.keys(state.placedParts)) {
                        const p2 = state.placedParts[k2];
                        if (p2 && p2.type === 'teleporter' && (p2.x !== part.x || p2.y !== part.y)) {
                            otherTeleporters.push(p2);
                        }
                    }
                    if (otherTeleporters.length > 0) {
                        part.progress += effectiveRate * dt;
                        if (part.progress >= 1) {
                            part.progress -= 1;
                            part.buffer--;
                            const target = otherTeleporters[Math.floor(Math.random() * otherTeleporters.length)];
                            target.outputBuffer = Math.min(target.outputBuffer + 1, target.bufferMax);
                            part.active = true;
                            // Visual teleport
                            const fx = part.x * CELL_SIZE + CELL_SIZE/2;
                            const fy = part.y * CELL_SIZE + CELL_SIZE/2;
                            const tx = target.x * CELL_SIZE + CELL_SIZE/2;
                            const ty = target.y * CELL_SIZE + CELL_SIZE/2;
                            spawnFlowParticle(fx, fy, tx, ty, '#00bfa5');
                        }
                    }
                } else { part.active = false; }
                break;
            case 'accelerator':
                // Passive, just animate
                part.active = true;
                break;
        }
        // Transfer output to connected parts
        if (part.outputBuffer > 0 && part.connected.length > 0) {
            const transfer = Math.min(part.outputBuffer, dt * effectiveRate * 2);
            const perTarget = transfer / part.connected.length;
            let transferred = 0;
            for (const conn of part.connected) {
                const target = getGridCell(conn.x, conn.y);
                if (target && target.buffer < target.bufferMax) {
                    const amount = Math.min(perTarget, target.bufferMax - target.buffer);
                    target.buffer += amount;
                    transferred += amount;
                    // Flow particle
                    if (Math.random() < 0.05) {
                        const fx = part.x * CELL_SIZE + CELL_SIZE/2;
                        const fy = part.y * CELL_SIZE + CELL_SIZE/2;
                        const tx = conn.x * CELL_SIZE + CELL_SIZE/2;
                        const ty = conn.y * CELL_SIZE + CELL_SIZE/2;
                        spawnFlowParticle(fx, fy, tx, ty, def.color);
                    }
                }
            }
            part.outputBuffer -= transferred;
        }
    }
    // Smooth products per second
    state.productsPerSec = state.productsPerSec * 0.95 + (productsThisFrame / dt) * 0.05;
}

// ========== RENDERING ==========
function resizeCanvas() {
    const panel = document.getElementById('side-panel');
    const isMobile = window.innerWidth <= 768;
    canvasW = window.innerWidth;
    canvasH = window.innerHeight;
    canvas.width = canvasW;
    canvas.height = canvasH;
}

function worldToScreen(wx, wy) {
    return {
        x: (wx - camX) * camZoom + canvasW / 2,
        y: (wy - camY) * camZoom + canvasH / 2
    };
}

function screenToWorld(sx, sy) {
    return {
        x: (sx - canvasW / 2) / camZoom + camX,
        y: (sy - canvasH / 2) / camZoom + camY
    };
}

function screenToGrid(sx, sy) {
    const world = screenToWorld(sx, sy);
    return {
        gx: Math.floor(world.x / CELL_SIZE),
        gy: Math.floor(world.y / CELL_SIZE)
    };
}

function render() {
    ctx.clearRect(0, 0, canvasW, canvasH);
    ctx.save();
    // Apply camera
    ctx.translate(canvasW / 2, canvasH / 2);
    ctx.scale(camZoom, camZoom);
    ctx.translate(-camX, -camY);
    // Draw grid background
    drawGrid();
    // Draw connections
    drawConnections();
    // Draw placed parts
    drawParts();
    // Draw hover preview
    if (hoverCell && state.selectedPart && !selectedGridPart) {
        drawPartPreview(hoverCell.gx, hoverCell.gy, state.selectedPart);
    }
    // Draw selection highlight
    if (selectedGridPart) {
        const cell = getGridCell(selectedGridPart.x, selectedGridPart.y);
        if (cell) {
            ctx.strokeStyle = '#00e5ff';
            ctx.lineWidth = 3;
            ctx.setLineDash([5, 3]);
            ctx.strokeRect(
                selectedGridPart.x * CELL_SIZE - 2,
                selectedGridPart.y * CELL_SIZE - 2,
                CELL_SIZE + 4, CELL_SIZE + 4
            );
            ctx.setLineDash([]);
        }
    }
    // Draw particles
    drawParticles();
    ctx.restore();
    // Draw minimap
    drawMinimap();
}

function drawGrid() {
    const gridPixelSize = state.gridSize * CELL_SIZE;
    // Background glow
    ctx.fillStyle = 'rgba(0, 229, 255, 0.02)';
    ctx.fillRect(-10, -10, gridPixelSize + 20, gridPixelSize + 20);
    // Grid cells
    for (let y = 0; y < state.gridSize; y++) {
        for (let x = 0; x < state.gridSize; x++) {
            const px = x * CELL_SIZE;
            const py = y * CELL_SIZE;
            if (state.grid[y][x]) {
                ctx.fillStyle = 'rgba(22, 24, 56, 0.8)';
            } else if (hoverCell && hoverCell.gx === x && hoverCell.gy === y) {
                ctx.fillStyle = 'rgba(0, 229, 255, 0.1)';
            } else {
                ctx.fillStyle = 'rgba(22, 24, 56, 0.4)';
            }
            ctx.fillRect(px + 1, py + 1, CELL_SIZE - 2, CELL_SIZE - 2);
            ctx.strokeStyle = 'rgba(42, 45, 90, 0.6)';
            ctx.lineWidth = 0.5;
            ctx.strokeRect(px + 1, py + 1, CELL_SIZE - 2, CELL_SIZE - 2);
        }
    }
    // Grid border
    ctx.strokeStyle = 'rgba(0, 229, 255, 0.3)';
    ctx.lineWidth = 2;
    ctx.strokeRect(0, 0, gridPixelSize, gridPixelSize);
    // Corner markers
    const cmSize = 10;
    ctx.strokeStyle = 'rgba(0, 229, 255, 0.5)';
    ctx.lineWidth = 2;
    [[0,0,1,1],
     [gridPixelSize,0,-1,1],
     [0,gridPixelSize,1,-1],
     [gridPixelSize,gridPixelSize,-1,-1]].forEach(([cx,cy,dx,dy]) => {
        ctx.beginPath();
        ctx.moveTo(cx, cy + dy * cmSize);
        ctx.lineTo(cx, cy);
        ctx.lineTo(cx + dx * cmSize, cy);
        ctx.stroke();
    });
}

function drawConnections() {
    ctx.lineWidth = 2;
    for (const key of Object.keys(state.placedParts)) {
        const part = state.placedParts[key];
        if (!part || !part.connected) continue;
        const fromX = part.x * CELL_SIZE + CELL_SIZE / 2;
        const fromY = part.y * CELL_SIZE + CELL_SIZE / 2;
        const def = PART_TYPES[part.type];
        for (const conn of part.connected) {
            const toX = conn.x * CELL_SIZE + CELL_SIZE / 2;
            const toY = conn.y * CELL_SIZE + CELL_SIZE / 2;
            // Draw line
            const gradient = ctx.createLinearGradient(fromX, fromY, toX, toY);
            gradient.addColorStop(0, def.color + '80');
            gradient.addColorStop(1, def.color + '20');
            ctx.strokeStyle = gradient;
            ctx.beginPath();
            ctx.moveTo(fromX, fromY);
            ctx.lineTo(toX, toY);
            ctx.stroke();
            // Arrow
            const angle = Math.atan2(toY - fromY, toX - fromX);
            const midX = (fromX + toX) / 2;
            const midY = (fromY + toY) / 2;
            ctx.fillStyle = def.color + '80';
            ctx.beginPath();
            ctx.moveTo(midX + Math.cos(angle) * 6, midY + Math.sin(angle) * 6);
            ctx.lineTo(midX + Math.cos(angle + 2.5) * 5, midY + Math.sin(angle + 2.5) * 5);
            ctx.lineTo(midX + Math.cos(angle - 2.5) * 5, midY + Math.sin(angle - 2.5) * 5);
            ctx.closePath();
            ctx.fill();
        }
    }
}

function drawParts() {
    for (const key of Object.keys(state.placedParts)) {
        const part = state.placedParts[key];
        if (!part) continue;
        const def = PART_TYPES[part.type];
        if (!def) continue;
        const px = part.x * CELL_SIZE;
        const py = part.y * CELL_SIZE;
        const cx = px + CELL_SIZE / 2;
        const cy = py + CELL_SIZE / 2;
        // Background
        ctx.fillStyle = def.color + '20';
        ctx.fillRect(px + 2, py + 2, CELL_SIZE - 4, CELL_SIZE - 4);
        // Active glow
        if (part.active) {
            ctx.shadowColor = def.color;
            ctx.shadowBlur = 8 + Math.sin(animTime * 3) * 4;
            ctx.fillStyle = def.color + '10';
            ctx.fillRect(px, py, CELL_SIZE, CELL_SIZE);
            ctx.shadowBlur = 0;
        }
        // Border
        ctx.strokeStyle = part.active ? def.color : def.color + '60';
        ctx.lineWidth = part.active ? 2 : 1;
        ctx.strokeRect(px + 2, py + 2, CELL_SIZE - 4, CELL_SIZE - 4);
        // Icon
        ctx.font = '24px serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(def.icon, cx, cy - 4);
        // Level badge
        if (part.level > 1) {
            ctx.font = 'bold 9px sans-serif';
            ctx.fillStyle = '#ffd740';
            ctx.fillText('Lv.' + part.level, cx, py + CELL_SIZE - 8);
        }
        // Buffer bar
        if (part.bufferMax > 0 && part.type !== 'accelerator') {
            const barW = CELL_SIZE - 12;
            const barH = 3;
            const barX = px + 6;
            const barY = py + CELL_SIZE - 5;
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillRect(barX, barY, barW, barH);
            const fill = Math.min(1, part.buffer / part.bufferMax);
            ctx.fillStyle = fill > 0.8 ? '#ff5252' : fill > 0.5 ? '#ffd740' : '#69f0ae';
            ctx.fillRect(barX, barY, barW * fill, barH);
        }
        // Processing indicator
        if (part.active && def.baseRate > 0) {
            const indSize = 4;
            const indX = px + CELL_SIZE - 10;
            const indY = py + 8;
            ctx.fillStyle = '#69f0ae';
            ctx.globalAlpha = 0.5 + Math.sin(animTime * 5) * 0.5;
            ctx.beginPath();
            ctx.arc(indX, indY, indSize, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
        }
    }
}

function drawPartPreview(gx, gy, type) {
    if (gx < 0 || gy < 0 || gx >= state.gridSize || gy >= state.gridSize) return;
    if (state.grid[gy] && state.grid[gy][gx]) return;
    const def = PART_TYPES[type];
    if (!def) return;
    const px = gx * CELL_SIZE;
    const py = gy * CELL_SIZE;
    ctx.globalAlpha = 0.5 + Math.sin(animTime * 4) * 0.2;
    ctx.fillStyle = def.color + '30';
    ctx.fillRect(px + 2, py + 2, CELL_SIZE - 4, CELL_SIZE - 4);
    ctx.strokeStyle = def.color;
    ctx.lineWidth = 2;
    ctx.setLineDash([4, 4]);
    ctx.strokeRect(px + 2, py + 2, CELL_SIZE - 4, CELL_SIZE - 4);
    ctx.setLineDash([]);
    ctx.font = '24px serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(def.icon, px + CELL_SIZE/2, py + CELL_SIZE/2);
    ctx.globalAlpha = 1;
}

function drawMinimap() {
    const mmSize = 80;
    const mmPadding = 10;
    const mmX = mmPadding;
    const mmY = canvasH - mmSize - mmPadding - 48;
    ctx.fillStyle = 'rgba(10, 11, 30, 0.8)';
    ctx.strokeStyle = 'rgba(0, 229, 255, 0.3)';
    ctx.lineWidth = 1;
    ctx.fillRect(mmX, mmY, mmSize, mmSize);
    ctx.strokeRect(mmX, mmY, mmSize, mmSize);
    const scale = mmSize / (state.gridSize * CELL_SIZE);
    for (const key of Object.keys(state.placedParts)) {
        const part = state.placedParts[key];
        if (!part) continue;
        const def = PART_TYPES[part.type];
        ctx.fillStyle = def.color;
        ctx.fillRect(
            mmX + part.x * CELL_SIZE * scale,
            mmY + part.y * CELL_SIZE * scale,
            CELL_SIZE * scale,
            CELL_SIZE * scale
        );
    }
    // Camera viewport
    const vpLeft = (camX - canvasW / 2 / camZoom);
    const vpTop = (camY - canvasH / 2 / camZoom);
    const vpW = canvasW / camZoom;
    const vpH = canvasH / camZoom;
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
    ctx.lineWidth = 1;
    ctx.strokeRect(
        mmX + vpLeft * scale,
        mmY + vpTop * scale,
        vpW * scale,
        vpH * scale
    );
}

// ========== UI PANEL RENDERING ==========
function renderPanel() {
    const panel = document.getElementById('panel-content');
    switch(currentTab) {
        case 'parts': renderPartsPanel(panel); break;
        case 'upgrades': renderUpgradesPanel(panel); break;
        case 'research': renderResearchPanel(panel); break;
        case 'products': renderProductsPanel(panel); break;
        case 'prestige': renderPrestigePanel(panel); break;
    }
}

function renderPartsPanel(panel) {
    let html = '<div class="panel-section"><div class="panel-title">ğŸ”§ ë¶€í’ˆ ë°°ì¹˜</div>';
    html += '<p style="font-size:11px;color:var(--sub);margin-bottom:8px">ë¶€í’ˆì„ ì„ íƒí•˜ê³  ê·¸ë¦¬ë“œë¥¼ í´ë¦­í•˜ì—¬ ë°°ì¹˜</p>';
    const categories = [
        { name: 'ê¸°ë³¸ ë¶€í’ˆ', types: ['collector', 'converter', 'assembler', 'shipper'] },
        { name: 'ê°€ê³µ ë¶€í’ˆ', types: ['refiner', 'splitter', 'merger', 'storage'] },
        { name: 'ê³ ê¸‰ ë¶€í’ˆ', types: ['accelerator', 'advAssembler', 'teleporter', 'quantumCore'] }
    ];
    for (const cat of categories) {
        html += `<div style="font-size:11px;color:var(--accent2);margin:8px 0 4px;font-weight:600">${cat.name}</div>`;
        for (const type of cat.types) {
            const def = PART_TYPES[type];
            const unlocked = isPartUnlocked(type);
            const cost = getPartCost(type);
            const canAfford = state.money >= cost;
            const selected = state.selectedPart === type;
            html += `<button class="part-btn ${selected ? 'selected' : ''} ${!unlocked ? 'locked' : ''}" 
                ${unlocked ? `onclick="selectPart('${type}')"` : ''}>
                <span class="p-icon">${def.icon}</span>
                <div class="p-info">
                    <div class="p-name">${def.name}</div>
                    <div class="p-cost">${unlocked ? 'ğŸ’° ' + formatNum(cost) : 'ğŸ”’ ì ê¹€'}</div>
                    <div class="p-desc">${def.desc}</div>
                </div>
            </button>`;
        }
    }
    html += '</div>';
    // Selected part info
    if (selectedGridPart) {
        const cell = getGridCell(selectedGridPart.x, selectedGridPart.y);
        if (cell) {
            const def = PART_TYPES[cell.type];
            const upgCost = Math.floor(getPartCost(cell.type) * cell.level * 0.8);
            html += `<div class="panel-section">
                <div class="panel-title">${def.icon} ì„ íƒëœ ë¶€í’ˆ</div>
                <div style="font-size:13px;margin-bottom:6px"><strong>${def.name}</strong> Lv.${cell.level}</div>
                <div style="font-size:11px;color:var(--sub);margin-bottom:4px">ìœ„ì¹˜: (${cell.x}, ${cell.y})</div>
                <div style="font-size:11px;color:var(--sub);margin-bottom:4px">ë²„í¼: ${Math.floor(cell.buffer)}/${cell.bufferMax}</div>
                <div style="font-size:11px;color:var(--sub);margin-bottom:4px">ì´ ìƒì‚°: ${formatNum(cell.totalProduced)}</div>
                <div style="font-size:11px;color:var(--sub);margin-bottom:4px">ì—°ê²°: ${cell.connected.length}ê°œ</div>
                ${cell.productType ? `<div style="font-size:11px;color:var(--green);margin-bottom:8px">ì œí’ˆ: ${PRODUCTS.find(p=>p.id===cell.productType)?.name || '?'}</div>` : ''}
                <button class="upgrade-btn" onclick="upgradePart(${cell.x},${cell.y});renderPanel()">
                    <div class="u-name">â¬†ï¸ ë ˆë²¨ì—…</div>
                    <div class="u-cost">ğŸ’° ${formatNum(upgCost)}</div>
                    <div class="u-level">â†’ Lv.${cell.level + 1}</div>
                </button>`;
            if (cell.type === 'assembler' || cell.type === 'advAssembler') {
                html += '<div style="margin-top:6px;font-size:11px;color:var(--accent)">ì œí’ˆ ë³€ê²½:</div>';
                const available = PRODUCTS.filter(p => isProductUnlocked(p) && (cell.type === 'advAssembler' ? p.tier >= 2 : true));
                for (const prod of available) {
                    const selected = cell.productType === prod.id;
                    html += `<button class="part-btn ${selected ? 'selected' : ''}" style="padding:4px 8px;margin:2px 0" onclick="changeProduct(${cell.x},${cell.y},'${prod.id}');renderPanel()">
                        <span style="font-size:14px">${prod.icon}</span>
                        <div class="p-info"><div class="p-name" style="font-size:11px">${prod.name}</div>
                        <div class="p-cost" style="font-size:10px">ğŸ’°${formatNum(getProductPrice(prod))}/ê°œ</div></div>
                    </button>`;
                }
            }
            html += `<button class="part-btn" style="margin-top:8px;border-color:var(--red)" onclick="removePart(${cell.x},${cell.y});selectedGridPart=null;renderPanel()">
                <span class="p-icon">ğŸ—‘ï¸</span>
                <div class="p-info"><div class="p-name" style="color:var(--red)">í•´ì²´ (50% í™˜ë¶ˆ)</div></div>
            </button>`;
            html += '</div>';
        }
    }
    panel.innerHTML = html;
}

function renderUpgradesPanel(panel) {
    let html = '<div class="panel-section"><div class="panel-title">â¬†ï¸ ì „ì²´ ê°•í™”</div>';
    html += '<p style="font-size:11px;color:var(--sub);margin-bottom:8px">ë°°ì¹˜ëœ ë¶€í’ˆë“¤ì„ ì¼ê´„ ê°•í™”í•©ë‹ˆë‹¤</p>';
    // Global upgrades
    const partTypes = [...new Set(Object.values(state.placedParts).filter(p=>p).map(p=>p.type))];
    for (const type of partTypes) {
        const parts = Object.values(state.placedParts).filter(p => p && p.type === type);
        const def = PART_TYPES[type];
        const avgLevel = parts.reduce((s, p) => s + p.level, 0) / parts.length;
        const minLevel = Math.min(...parts.map(p => p.level));
        const cost = Math.floor(getPartCost(type) * minLevel * 0.8) * parts.length;
        html += `<button class="upgrade-btn" onclick="upgradeAllOfType('${type}');renderPanel()">
            <div class="u-name">${def.icon} ${def.name} ì „ì²´ (${parts.length}ê°œ)</div>
            <div class="u-cost">ğŸ’° ${formatNum(cost)}</div>
            <div class="u-level">í‰ê·  Lv.${avgLevel.toFixed(1)}</div>
        </button>`;
    }
    if (partTypes.length === 0) {
        html += '<p style="color:var(--sub);font-size:12px;text-align:center;padding:20px">ë¶€í’ˆì„ ë°°ì¹˜í•˜ë©´ ì—¬ê¸°ì„œ ê°•í™”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤</p>';
    }
    html += '</div>';
    // Factory info
    const stage = FACTORY_STAGES[state.factoryStage];
    html += `<div class="panel-section">
        <div class="panel-title">ğŸ­ íŒ©í† ë¦¬ ì •ë³´</div>
        <div style="font-size:13px;margin-bottom:4px"><strong>${stage.name}</strong> (${stage.nameEn})</div>
        <div style="font-size:11px;color:var(--sub)">ê·¸ë¦¬ë“œ: ${state.gridSize}Ã—${state.gridSize}</div>
        <div style="font-size:11px;color:var(--sub)">ë°°ì¹˜ëœ ë¶€í’ˆ: ${Object.keys(state.placedParts).length}ê°œ</div>
        <div style="font-size:11px;color:var(--sub)">ì´ ìˆ˜ìµ: ğŸ’°${formatNum(state.totalEarned)}</div>
        <div style="font-size:11px;color:var(--sub)">ì´ ìƒì‚°: ğŸ“¦${formatNum(state.totalProducts)}</div>
        <div style="font-size:11px;color:var(--sub)">í”Œë ˆì´ ì‹œê°„: ${Math.floor(state.stats.playTime / 60)}ë¶„</div>
    </div>`;
    // Save/Load
    html += `<div class="panel-section">
        <div class="panel-title">ğŸ’¾ ì„¸ì´ë¸Œ/ë¡œë“œ</div>
        <button class="upgrade-btn" onclick="saveGame();showNotification('ğŸ’¾ ì €ì¥ ì™„ë£Œ!')">
            <div class="u-name">ğŸ’¾ ìˆ˜ë™ ì €ì¥</div>
        </button>
        <button class="upgrade-btn" onclick="if(confirm('ì •ë§ ë¡œë“œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?'))loadGame()">
            <div class="u-name">ğŸ“‚ ë¶ˆëŸ¬ì˜¤ê¸°</div>
        </button>
        <button class="upgrade-btn" style="border-color:var(--red)" onclick="if(confirm('ì •ë§ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ? ëª¨ë“  ì§„í–‰ì´ ì‚­ì œë©ë‹ˆë‹¤.'))resetGame()">
            <div class="u-name" style="color:var(--red)">ğŸ—‘ï¸ ì´ˆê¸°í™”</div>
        </button>
    </div>`;
    panel.innerHTML = html;
}

function renderResearchPanel(panel) {
    let html = `<div class="panel-section"><div class="panel-title">ğŸ”¬ ì—°êµ¬ íŠ¸ë¦¬</div>
        <p style="font-size:11px;color:var(--sub);margin-bottom:8px">ğŸ”¬ ${formatNum(state.researchPoints)} ì—°êµ¬ í¬ì¸íŠ¸ ë³´ìœ </p>`;
    html += '<div class="research-tree">';
    for (const [key, r] of Object.entries(RESEARCH)) {
        const done = !!state.research[key];
        const available = isResearchAvailable(key);
        const canAfford = state.researchPoints >= r.cost;
        let cls = done ? 'unlocked' : (available ? 'available' : '');
        html += `<div class="research-node ${cls}" 
            ${available && canAfford && !done ? `onclick="doResearch('${key}');renderPanel()"` : ''}
            ${!available && !done ? 'style="opacity:0.3"' : ''}>
            <div class="r-icon">${r.icon}</div>
            <div class="r-name">${r.name}</div>
            ${done ? '<div style="color:var(--green);font-size:10px">âœ… ì™„ë£Œ</div>' :
              `<div class="r-cost">ğŸ”¬ ${formatNum(r.cost)}</div>`}
            <div style="font-size:9px;color:var(--sub);margin-top:2px">${r.desc}</div>
        </div>`;
    }
    html += '</div></div>';
    panel.innerHTML = html;
}

function renderProductsPanel(panel) {
    let html = '<div class="panel-section"><div class="panel-title">ğŸ“¦ ì œí’ˆ ëª©ë¡</div>';
    html += '<div class="product-list">';
    for (const prod of PRODUCTS) {
        const unlocked = isProductUnlocked(prod);
        const count = state.productCounts[prod.id] || 0;
        const price = getProductPrice(prod);
        html += `<div class="product-item ${unlocked ? '' : 'locked'}">
            <span class="pr-icon">${prod.icon}</span>
            <span class="pr-name">${unlocked ? prod.name : '???'}</span>
            <span class="pr-price">ğŸ’°${formatNum(price)}</span>
            <span class="pr-count">Ã—${formatNum(count)}</span>
        </div>`;
    }
    html += '</div></div>';
    // Stats
    html += `<div class="panel-section">
        <div class="panel-title">ğŸ“Š í†µê³„</div>
        <div style="font-size:11px;color:var(--sub)">
            <div>ì´ ë°°ì¹˜: ${state.stats.totalPlaced}ê°œ</div>
            <div>ì´ íŒë§¤: ${formatNum(state.stats.totalSold)}íšŒ</div>
            <div>ì´ ì—°êµ¬: ${Object.keys(state.research).length}/${Object.keys(RESEARCH).length}</div>
            <div>í”„ë ˆìŠ¤í‹°ì§€: ${state.prestigeCount}íšŒ</div>
            <div>ì–‘ì ì½”ì–´: âš›ï¸${state.totalQuantumCores}</div>
        </div>
    </div>`;
    panel.innerHTML = html;
}

function renderPrestigePanel(panel) {
    const earned = calculatePrestigeReward();
    let html = `<div class="panel-section">
        <div class="panel-title">âš›ï¸ ì–‘ì ë„ì•½ (í”„ë ˆìŠ¤í‹°ì§€)</div>
        <div class="prestige-info">
            <p style="font-size:12px;color:var(--sub)">ëª¨ë“  ê²ƒì„ ë¦¬ì…‹í•˜ê³  ì˜êµ¬ ë³´ë„ˆìŠ¤ë¥¼ íšë“í•©ë‹ˆë‹¤</p>
            <div style="margin:8px 0">
                <div class="val">âš›ï¸ +${earned}</div>
                <div style="font-size:11px;color:var(--sub)">ì–‘ì ì½”ì–´ íšë“</div>
            </div>
            <div style="font-size:11px;color:var(--sub)">
                í˜„ì¬ ë³´ìœ : âš›ï¸${state.totalQuantumCores}<br>
                ì´ ìˆ˜ìµ ê¸°ì¤€: ğŸ’°${formatNum(state.totalEarned)}<br>
                ìµœì†Œ í•„ìš”: ğŸ’°${formatNum(1000)}
            </div>
        </div>`;
    if (earned > 0) {
        html += `<button class="modal-btn primary" style="width:100%;margin-top:8px" onclick="confirmPrestige()">âš›ï¸ ì–‘ì ë„ì•½ ì‹¤í–‰</button>`;
    } else {
        html += `<p style="color:var(--red);font-size:12px;margin-top:8px">ë” ë§ì€ ìˆ˜ìµì„ ì˜¬ë¦¬ë©´ ì–‘ì ì½”ì–´ë¥¼ íšë“í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤</p>`;
    }
    html += '</div>';
    // Prestige bonuses
    html += '<div class="panel-section"><div class="panel-title">âš›ï¸ ì˜êµ¬ ë³´ë„ˆìŠ¤</div>';
    for (const bonus of PRESTIGE_BONUSES) {
        html += `<div style="font-size:12px;margin-bottom:6px;padding:6px;background:rgba(0,0,0,0.2);border-radius:6px">
            <span>${bonus.icon}</span> <strong>${bonus.name}</strong><br>
            <span style="color:var(--sub);font-size:11px">${bonus.desc}</span>
        </div>`;
    }
    html += '</div>';
    panel.innerHTML = html;
}

function calculatePrestigeReward() {
    if (state.totalEarned < 1000) return 0;
    return Math.floor(Math.sqrt(state.totalEarned / 1000));
}

function confirmPrestige() {
    const earned = calculatePrestigeReward();
    if (earned <= 0) return;
    const html = `<h2>âš›ï¸ ì–‘ì ë„ì•½</h2>
        <div class="prestige-info">
            <p>ëª¨ë“  ë¶€í’ˆ, ì—°êµ¬, ìê¸ˆì´ ë¦¬ì…‹ë©ë‹ˆë‹¤.</p>
            <div class="val" style="margin:12px 0">âš›ï¸ +${earned} ì–‘ì ì½”ì–´</div>
            <p>ì˜êµ¬ ë³´ë„ˆìŠ¤ê°€ ì ìš©ë©ë‹ˆë‹¤!</p>
        </div>
        <button class="modal-btn primary" onclick="doPrestige()">í™•ì¸</button>
        <button class="modal-btn secondary" onclick="closeModal()">ì·¨ì†Œ</button>`;
    showModal(html);
}

function doPrestige() {
    const earned = calculatePrestigeReward();
    state.totalQuantumCores += earned;
    state.quantumCores = state.totalQuantumCores;
    state.prestigeCount++;
    // Reset
    state.money = 50 + state.quantumCores * 100;
    state.energy = 100;
    state.researchPoints = 0;
    state.totalEarned = 0;
    state.totalProducts = 0;
    state.productsPerSec = 0;
    state.placedParts = {};
    state.partCounts = {};
    state.research = {};
    state.productCounts = {};
    state.connections = [];
    state.stats.totalPlaced = 0;
    state.stats.totalSold = 0;
    selectedGridPart = null;
    state.selectedPart = null;
    // Reset grid
    initGrid(6);
    state.factoryStage = 0;
    state.gridSize = 6;
    // Spawn prestige particles at center
    const cx = state.gridSize * CELL_SIZE / 2;
    const cy = state.gridSize * CELL_SIZE / 2;
    for (let i = 0; i < 100; i++) {
        spawnParticles(cx, cy, ['#7c4dff', '#00e5ff', '#ffd740', '#69f0ae', '#e91e63'][Math.floor(Math.random()*5)], 1, {
            spread: 200, type: ['star', 'circle', 'square'][Math.floor(Math.random()*3)], size: 4
        });
    }
    AudioEngine.play('prestige');
    closeModal();
    showNotification(`âš›ï¸ ì–‘ì ë„ì•½! +${earned} ì–‘ì ì½”ì–´`);
    centerCamera();
    renderPanel();
    saveGame();
}

// ========== GAME ACTIONS ==========
function selectPart(type) {
    if (!isPartUnlocked(type)) return;
    AudioEngine.play('click');
    if (state.selectedPart === type) {
        state.selectedPart = null;
    } else {
        state.selectedPart = type;
        selectedGridPart = null;
    }
    renderPanel();
}

function changeProduct(gx, gy, productId) {
    const cell = getGridCell(gx, gy);
    if (!cell) return;
    cell.productType = productId;
    AudioEngine.play('click');
}

function upgradeAllOfType(type) {
    const parts = Object.values(state.placedParts).filter(p => p && p.type === type);
    let upgraded = 0;
    for (const p of parts) {
        const cost = Math.floor(getPartCost(type) * p.level * 0.8);
        if (state.money >= cost) {
            state.money -= cost;
            p.level++;
            p.bufferMax += 5;
            upgraded++;
        }
    }
    if (upgraded > 0) {
        AudioEngine.play('upgrade');
        showNotification(`â¬†ï¸ ${PART_TYPES[type].name} ${upgraded}ê°œ ê°•í™”!`);
    }
}

function doResearch(key) {
    const r = RESEARCH[key];
    if (!r || state.research[key] || !isResearchAvailable(key)) return;
    if (state.researchPoints < r.cost) {
        showNotification('ğŸ”¬ ì—°êµ¬ í¬ì¸íŠ¸ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤!');
        AudioEngine.play('error');
        return;
    }
    state.researchPoints -= r.cost;
    state.research[key] = true;
    state.stats.totalResearch++;
    // Apply effects
    if (r.effect.expand) {
        const newSize = r.effect.expand;
        if (newSize > state.gridSize) {
            expandGrid(newSize);
            state.factoryStage = newSize - 6;
        }
    }
    if (r.effect.unlock) {
        // Product unlock handled dynamically
    }
    // Unlock parts based on tier
    for (const [type, def] of Object.entries(PART_TYPES)) {
        if (def.tier <= state.factoryStage + 1) {
            state.unlockedParts[type] = true;
        }
    }
    AudioEngine.play('research');
    const cx = state.gridSize * CELL_SIZE / 2;
    const cy = state.gridSize * CELL_SIZE / 2;
    spawnParticles(cx, cy, '#7c4dff', 20, { spread: 120, type: 'star', size: 5 });
    showNotification(`ğŸ”¬ ${r.name} ì—°êµ¬ ì™„ë£Œ!`);
    renderPanel();
    saveGame();
}

function expandGrid(newSize) {
    const oldSize = state.gridSize;
    state.gridSize = newSize;
    // Expand grid array
    for (let y = 0; y < newSize; y++) {
        if (!state.grid[y]) state.grid[y] = [];
        for (let x = 0; x < newSize; x++) {
            if (state.grid[y][x] === undefined) state.grid[y][x] = null;
        }
    }
    const stageIdx = Math.min(newSize - 6, FACTORY_STAGES.length - 1);
    state.factoryStage = stageIdx;
    showNotification(`ğŸ—ï¸ ${FACTORY_STAGES[stageIdx].name}ìœ¼ë¡œ í™•ì¥!`);
    centerCamera();
}

function toggleMenu() {
    const panel = document.getElementById('side-panel');
    panelOpen = !panelOpen;
    panel.classList.toggle('hidden', !panelOpen);
    if (panelOpen) renderPanel();
}

function switchTab(tab) {
    currentTab = tab;
    document.querySelectorAll('.tab-btn').forEach(b => b.classList.toggle('active', b.dataset.tab === tab));
    panelOpen = true;
    document.getElementById('side-panel').classList.remove('hidden');
    renderPanel();
}

function showModal(html) {
    document.getElementById('modal-box').innerHTML = html;
    document.getElementById('modal-overlay').classList.add('show');
}

function closeModal() {
    document.getElementById('modal-overlay').classList.remove('show');
}

function centerCamera() {
    camX = state.gridSize * CELL_SIZE / 2;
    camY = state.gridSize * CELL_SIZE / 2;
    const gridPixels = state.gridSize * CELL_SIZE;
    const minDim = Math.min(canvasW, canvasH - 96);
    camZoom = Math.min(1.5, minDim / (gridPixels + 40));
}

// ========== SAVE / LOAD ==========
function saveGame() {
    try {
        const saveData = {
            version: 2,
            money: state.money,
            energy: state.energy,
            researchPoints: state.researchPoints,
            totalEarned: state.totalEarned,
            totalProducts: state.totalProducts,
            gridSize: state.gridSize,
            factoryStage: state.factoryStage,
            partCounts: state.partCounts,
            research: state.research,
            productCounts: state.productCounts,
            quantumCores: state.quantumCores,
            totalQuantumCores: state.totalQuantumCores,
            prestigeCount: state.prestigeCount,
            stats: state.stats,
            unlockedParts: state.unlockedParts,
            tutorialDone: state.tutorialDone,
            parts: []
        };
        for (const key of Object.keys(state.placedParts)) {
            const p = state.placedParts[key];
            if (!p) continue;
            saveData.parts.push({
                type: p.type, x: p.x, y: p.y, level: p.level,
                buffer: p.buffer, outputBuffer: p.outputBuffer,
                bufferMax: p.bufferMax, productType: p.productType,
                totalProduced: p.totalProduced, direction: p.direction,
                connected: p.connected
            });
        }
        localStorage.setItem(SAVE_KEY, JSON.stringify(saveData));
    } catch(e) { console.error('Save failed:', e); }
}

function loadGame() {
    try {
        const raw = localStorage.getItem(SAVE_KEY);
        if (!raw) return false;
        const data = JSON.parse(raw);
        if (!data || !data.version) return false;
        state.money = data.money || 50;
        state.energy = data.energy || 100;
        state.researchPoints = data.researchPoints || 0;
        state.totalEarned = data.totalEarned || 0;
        state.totalProducts = data.totalProducts || 0;
        state.gridSize = data.gridSize || 6;
        state.factoryStage = data.factoryStage || 0;
        state.partCounts = data.partCounts || {};
        state.research = data.research || {};
        state.productCounts = data.productCounts || {};
        state.quantumCores = data.quantumCores || 0;
        state.totalQuantumCores = data.totalQuantumCores || 0;
        state.prestigeCount = data.prestigeCount || 0;
        state.stats = data.stats || { totalPlaced: 0, totalSold: 0, totalResearch: 0, playTime: 0 };
        state.unlockedParts = data.unlockedParts || { collector: true, converter: true, assembler: true, shipper: true };
        state.tutorialDone = data.tutorialDone || false;
        // Rebuild grid
        initGrid(state.gridSize);
        state.placedParts = {};
        if (data.parts) {
            for (const pd of data.parts) {
                if (pd.x >= 0 && pd.y >= 0 && pd.x < state.gridSize && pd.y < state.gridSize) {
                    const part = {
                        type: pd.type, x: pd.x, y: pd.y, level: pd.level || 1,
                        progress: 0, buffer: pd.buffer || 0,
                        bufferMax: pd.bufferMax || 10, outputBuffer: pd.outputBuffer || 0,
                        connected: pd.connected || [], active: false,
                        productType: pd.productType || null, animPhase: 0,
                        totalProduced: pd.totalProduced || 0, direction: pd.direction || 0
                    };
                    state.grid[pd.y][pd.x] = part;
                    state.placedParts[`${pd.x},${pd.y}`] = part;
                }
            }
        }
        showNotification('ğŸ“‚ ë¡œë“œ ì™„ë£Œ!');
        centerCamera();
        renderPanel();
        return true;
    } catch(e) {
        console.error('Load failed:', e);
        return false;
    }
}

function resetGame() {
    localStorage.removeItem(SAVE_KEY);
    location.reload();
}

// ========== TUTORIAL ==========
const TUTORIAL_STEPS = [
    {
        title: 'ğŸ­ ë‚˜ë…¸ íŒ©í† ë¦¬ì— ì˜¤ì‹  ê±¸ í™˜ì˜í•©ë‹ˆë‹¤!',
        text: 'ë¯¸ì‹œ ì„¸ê³„ì—ì„œ ë‚˜ë…¸ ë¨¸ì‹ ì„ ì¡°ë¦½í•˜ëŠ” íŒ©í† ë¦¬ ê²Œì„ì…ë‹ˆë‹¤.\nê·¸ë¦¬ë“œ ìœ„ì— ë¶€í’ˆì„ ë°°ì¹˜í•˜ê³  ìì› íë¦„ì„ ìµœì í™”í•˜ì„¸ìš”!'
    },
    {
        title: 'ğŸ”µ ìˆ˜ì§‘ê¸° ë°°ì¹˜',
        text: 'í•˜ë‹¨ì˜ <span class="highlight">ğŸ”§ ë¶€í’ˆ</span> íƒ­ì—ì„œ <span class="highlight">ìˆ˜ì§‘ê¸°</span>ë¥¼ ì„ íƒí•˜ê³ \nê·¸ë¦¬ë“œë¥¼ í´ë¦­í•˜ì—¬ ë°°ì¹˜í•˜ì„¸ìš”.\nìˆ˜ì§‘ê¸°ëŠ” ì›ìì¬ë¥¼ ìë™ìœ¼ë¡œ ìˆ˜ì§‘í•©ë‹ˆë‹¤.'
    },
    {
        title: 'ğŸŸ¡ ë³€í™˜ê¸° ì—°ê²°',
        text: '<span class="highlight">ë³€í™˜ê¸°</span>ë¥¼ ìˆ˜ì§‘ê¸° ì˜†ì— ë°°ì¹˜í•˜ì„¸ìš”.\nì¸ì ‘í•œ ë¶€í’ˆì€ ìë™ìœ¼ë¡œ ì—°ê²°ë©ë‹ˆë‹¤.\n(ì—°êµ¬ > ìë™ ì—°ê²° í•„ìš”. ìˆ˜ë™ ì—°ê²°: ë¶€í’ˆ í´ë¦­ í›„ ë“œë˜ê·¸)'
    },
    {
        title: 'ğŸŸ¢ ì¡°ë¦½ê¸° â†’ ğŸŸ£ ì¶œí•˜ê¸°',
        text: '<span class="highlight">ì¡°ë¦½ê¸°</span>ëŠ” ê°€ê³µ ì¬ë£Œë¥¼ ì œí’ˆìœ¼ë¡œ ë§Œë“¤ê³ \n<span class="highlight">ì¶œí•˜ê¸°</span>ëŠ” ì œí’ˆì„ íŒë§¤í•˜ì—¬ ëˆì„ ë²Œì–´ì¤ë‹ˆë‹¤.\n\nìˆ˜ì§‘ê¸° â†’ ë³€í™˜ê¸° â†’ ì¡°ë¦½ê¸° â†’ ì¶œí•˜ê¸°\nì´ ê¸°ë³¸ ìƒì‚° ë¼ì¸ì„ ë§Œë“¤ì–´ë³´ì„¸ìš”!'
    },
    {
        title: 'ğŸ”¬ ì—°êµ¬ & â¬†ï¸ ê°•í™”',
        text: 'ìƒì‚°í•˜ë©´ <span class="highlight">ì—°êµ¬ í¬ì¸íŠ¸</span>ê°€ ìŒ“ì…ë‹ˆë‹¤.\n<span class="highlight">ğŸ”¬ ì—°êµ¬</span> íƒ­ì—ì„œ ìƒˆ ê¸°ìˆ ì„ í•´ê¸ˆí•˜ê³ \n<span class="highlight">â¬†ï¸ ê°•í™”</span> íƒ­ì—ì„œ ë¶€í’ˆì„ ë ˆë²¨ì—…í•˜ì„¸ìš”!'
    },
    {
        title: 'âš›ï¸ ì–‘ì ë„ì•½',
        text: 'ì¶©ë¶„íˆ ëˆì„ ë²Œë©´ <span class="highlight">ì–‘ì ë„ì•½</span>ìœ¼ë¡œ\nëª¨ë“  ê²ƒì„ ë¦¬ì…‹í•˜ê³  ì˜êµ¬ ë³´ë„ˆìŠ¤ë¥¼ ì–»ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n\nì´ì œ ë‚˜ë…¸ íŒ©í† ë¦¬ë¥¼ ì‹œì‘í•˜ì„¸ìš”! ğŸš€'
    }
];

function showTutorial(step) {
    state.tutorialStep = step;
    const s = TUTORIAL_STEPS[step];
    if (!s) {
        state.tutorialDone = true;
        document.getElementById('tutorial-overlay').classList.remove('show');
        saveGame();
        return;
    }
    const box = document.getElementById('tutorial-box');
    box.innerHTML = `
        <div class="step-indicator">${step + 1} / ${TUTORIAL_STEPS.length}</div>
        <h2>${s.title}</h2>
        <p>${s.text.replace(/\n/g, '<br>')}</p>
        <button class="modal-btn primary" onclick="showTutorial(${step + 1})">${step < TUTORIAL_STEPS.length - 1 ? 'ë‹¤ìŒ â†’' : 'ì‹œì‘í•˜ê¸°! ğŸš€'}</button>
        ${step > 0 ? `<button class="modal-btn secondary" onclick="showTutorial(${step - 1})">â† ì´ì „</button>` : ''}
        <br><button class="modal-btn secondary" style="margin-top:8px;font-size:11px" onclick="state.tutorialDone=true;document.getElementById('tutorial-overlay').classList.remove('show')">íŠœí† ë¦¬ì–¼ ê±´ë„ˆë›°ê¸°</button>
    `;
    document.getElementById('tutorial-overlay').classList.add('show');
}

// ========== INPUT HANDLING ==========
let touchStartDist = 0;
let touchStartZoom = 1;
let lastTouchX = 0, lastTouchY = 0;
let connectMode = false;
let connectFrom = null;

canvas.addEventListener('mousedown', (e) => {
    AudioEngine.init();
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    if (e.button === 0) {
        const { gx, gy } = screenToGrid(mx, my);
        // Check if clicking on existing part
        const existing = getGridCell(gx, gy);
        if (state.selectedPart && !existing) {
            // Place part
            if (gx >= 0 && gy >= 0 && gx < state.gridSize && gy < state.gridSize) {
                placePart(gx, gy, state.selectedPart);
                renderPanel();
            }
        } else if (existing && !state.selectedPart) {
            // Select/deselect part
            if (selectedGridPart && selectedGridPart.x === gx && selectedGridPart.y === gy) {
                selectedGridPart = null;
            } else {
                selectedGridPart = { x: gx, y: gy };
                connectFrom = { x: gx, y: gy };
            }
            renderPanel();
        } else if (!existing && !state.selectedPart) {
            // Start camera drag
            isDragging = true;
            dragStartX = mx;
            dragStartY = my;
            camStartX = camX;
            camStartY = camY;
            selectedGridPart = null;
            renderPanel();
        }
    } else if (e.button === 2) {
        // Right click to deselect
        state.selectedPart = null;
        selectedGridPart = null;
        renderPanel();
    }
});

canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    if (isDragging) {
        camX = camStartX - (mx - dragStartX) / camZoom;
        camY = camStartY - (my - dragStartY) / camZoom;
    }
    const { gx, gy } = screenToGrid(mx, my);
    if (gx >= 0 && gy >= 0 && gx < state.gridSize && gy < state.gridSize) {
        hoverCell = { gx, gy };
    } else {
        hoverCell = null;
    }
});

canvas.addEventListener('mouseup', (e) => {
    if (isDragging) {
        isDragging = false;
        return;
    }
    // Check for connection drag
    if (connectFrom) {
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;
        const { gx, gy } = screenToGrid(mx, my);
        if ((gx !== connectFrom.x || gy !== connectFrom.y) && getGridCell(gx, gy)) {
            manualConnect(connectFrom.x, connectFrom.y, gx, gy);
            renderPanel();
        }
        connectFrom = null;
    }
});

canvas.addEventListener('wheel', (e) => {
    e.preventDefault();
    const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
    camZoom = Math.max(0.3, Math.min(3, camZoom * zoomFactor));
}, { passive: false });

canvas.addEventListener('contextmenu', (e) => e.preventDefault());

// Touch handling
canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    AudioEngine.init();
    if (e.touches.length === 2) {
        // Pinch zoom
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        touchStartDist = Math.sqrt(dx*dx + dy*dy);
        touchStartZoom = camZoom;
    } else if (e.touches.length === 1) {
        const rect = canvas.getBoundingClientRect();
        const tx = e.touches[0].clientX - rect.left;
        const ty = e.touches[0].clientY - rect.top;
        lastTouchX = tx;
        lastTouchY = ty;
        const { gx, gy } = screenToGrid(tx, ty);
        const existing = getGridCell(gx, gy);
        if (state.selectedPart && !existing) {
            if (gx >= 0 && gy >= 0 && gx < state.gridSize && gy < state.gridSize) {
                placePart(gx, gy, state.selectedPart);
                renderPanel();
            }
        } else if (existing && !state.selectedPart) {
            if (selectedGridPart && selectedGridPart.x === gx && selectedGridPart.y === gy) {
                selectedGridPart = null;
            } else {
                selectedGridPart = { x: gx, y: gy };
            }
            renderPanel();
        } else {
            isDragging = true;
            dragStartX = tx;
            dragStartY = ty;
            camStartX = camX;
            camStartY = camY;
        }
    }
}, { passive: false });

canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    if (e.touches.length === 2) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const dist = Math.sqrt(dx*dx + dy*dy);
        camZoom = Math.max(0.3, Math.min(3, touchStartZoom * (dist / touchStartDist)));
    } else if (e.touches.length === 1 && isDragging) {
        const rect = canvas.getBoundingClientRect();
        const tx = e.touches[0].clientX - rect.left;
        const ty = e.touches[0].clientY - rect.top;
        camX = camStartX - (tx - dragStartX) / camZoom;
        camY = camStartY - (ty - dragStartY) / camZoom;
    }
}, { passive: false });

canvas.addEventListener('touchend', (e) => {
    isDragging = false;
});

// Speed controls
document.querySelectorAll('.speed-btn').forEach(btn => {
    btn.addEventListener('click', () => {
        const speed = parseInt(btn.dataset.speed);
        state.gameSpeed = speed;
        document.querySelectorAll('.speed-btn').forEach(b => b.classList.toggle('active', b === btn));
    });
});

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
    switch(e.key) {
        case 'Escape':
            state.selectedPart = null;
            selectedGridPart = null;
            renderPanel();
            break;
        case '1': selectPart('collector'); break;
        case '2': selectPart('converter'); break;
        case '3': selectPart('assembler'); break;
        case '4': selectPart('shipper'); break;
        case 'Delete':
        case 'Backspace':
            if (selectedGridPart) {
                removePart(selectedGridPart.x, selectedGridPart.y);
                selectedGridPart = null;
                renderPanel();
            }
            break;
    }
});

// ========== MAIN GAME LOOP ==========
function updateUI() {
    document.getElementById('money-val').textContent = formatNum(state.money);
    document.getElementById('energy-val').textContent = formatNum(state.energy);
    document.getElementById('products-val').textContent = state.productsPerSec.toFixed(1);
    document.getElementById('rp-val').textContent = formatNum(state.researchPoints);
}

let uiUpdateTimer = 0;
let autoSaveTimer = 0;

function gameLoop(timestamp) {
    if (!lastTime) lastTime = timestamp;
    const dt = Math.min((timestamp - lastTime) / 1000, 0.1);
    lastTime = timestamp;
    animTime += dt;
    // Simulate
    simulate(dt);
    // Update particles
    updateParticles(dt);
    // Render
    render();
    // UI updates (throttled)
    uiUpdateTimer += dt;
    if (uiUpdateTimer >= 0.25) {
        uiUpdateTimer = 0;
        updateUI();
    }
    // Auto-save
    autoSaveTimer += dt * 1000;
    if (autoSaveTimer >= AUTOSAVE_INTERVAL) {
        autoSaveTimer = 0;
        saveGame();
    }
    requestAnimationFrame(gameLoop);
}

// ========== INITIALIZATION ==========
function init() {
    resizeCanvas();
    window.addEventListener('resize', () => {
        resizeCanvas();
        centerCamera();
    });
    // Try load save
    const loaded = loadGame();
    if (!loaded) {
        initGrid(6);
        state.money = 50;
        state.energy = 100;
        // Unlock tier 0 parts
        for (const [type, def] of Object.entries(PART_TYPES)) {
            if (def.tier === 0) state.unlockedParts[type] = true;
        }
    }
    centerCamera();
    // Start tutorial if new game
    if (!state.tutorialDone && !loaded) {
        setTimeout(() => showTutorial(0), 500);
    }
    // Start game loop
    requestAnimationFrame(gameLoop);
    // Render initial panel
    switchTab('parts');
}

init();
</script>
</body>
</html>
