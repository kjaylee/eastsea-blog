<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no,maximum-scale=1.0">
<title>Rogue Cards â€” ë¡œê·¸ë¼ì´í¬ ë±ë¹Œë”©</title>
<meta name="description" content="ì¹´ë“œë¥¼ ì¡°í•©í•´ ë˜ì „ì„ íƒí—˜í•˜ëŠ” ì‹±ê¸€í”Œë ˆì´ ë±ë¹Œë”© ë¡œê·¸ë¼ì´í¬ ê²Œì„">
<style>
*{margin:0;padding:0;box-sizing:border-box;-webkit-tap-highlight-color:transparent}
:root{--bg:#0d1117;--card-bg:#161b22;--panel:#1c2333;--accent:#58a6ff;--red:#f85149;--green:#3fb950;--gold:#d29922;--purple:#bc8cff;--text:#e6edf3;--dim:#8b949e;--blue:#58a6ff;--orange:#f0883e;--shield:#79c0ff}
html,body{width:100%;height:100%;overflow:hidden;touch-action:manipulation}
body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif;background:var(--bg);color:var(--text);display:flex;justify-content:center;align-items:center}
#app{width:100%;height:100%;max-width:480px;position:relative;overflow:hidden}
canvas#fx{position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:1000}
.screen{position:absolute;top:0;left:0;width:100%;height:100%;display:none;flex-direction:column;overflow-y:auto;overflow-x:hidden;-webkit-overflow-scrolling:touch}
.screen.active{display:flex}
.shake{animation:shake 0.3s ease-in-out}
@keyframes shake{0%,100%{transform:translate(0)}10%{transform:translate(-8px,4px)}30%{transform:translate(6px,-4px)}50%{transform:translate(-4px,6px)}70%{transform:translate(4px,-2px)}90%{transform:translate(-2px,2px)}}
@keyframes cardIn{0%{transform:translateY(100px) scale(0.7) rotate(5deg);opacity:0}100%{transform:translateY(0) scale(1) rotate(0);opacity:1}}
@keyframes cardPlay{0%{transform:scale(1)}30%{transform:scale(1.15) translateY(-30px)}100%{transform:scale(0.3) translateY(-200px);opacity:0}}
@keyframes fadeIn{0%{opacity:0;transform:translateY(20px)}100%{opacity:1;transform:translateY(0)}}
@keyframes pulse{0%,100%{transform:scale(1)}50%{transform:scale(1.08)}}
@keyframes glow{0%,100%{box-shadow:0 0 5px var(--accent)}50%{box-shadow:0 0 20px var(--accent),0 0 40px rgba(88,166,255,0.3)}}
@keyframes dmgFlash{0%{background:rgba(248,81,73,0.4)}100%{background:transparent}}
@keyframes floatUp{0%{opacity:1;transform:translateY(0) scale(1)}100%{opacity:0;transform:translateY(-60px) scale(1.3)}}
@keyframes slideDown{0%{transform:translateY(-100%)}100%{transform:translateY(0)}}
@keyframes bounceIn{0%{transform:scale(0);opacity:0}50%{transform:scale(1.2)}100%{transform:scale(1);opacity:1}}
.float-text{position:absolute;pointer-events:none;font-weight:bold;font-size:1.3rem;z-index:500;animation:floatUp 1s ease-out forwards;text-shadow:0 2px 4px rgba(0,0,0,0.8)}
/* === TITLE === */
.title-screen{background:linear-gradient(180deg,#0d1117 0%,#161b22 50%,#1c2333 100%);align-items:center;justify-content:center;padding:20px;text-align:center}
.title-logo{font-size:3rem;margin-bottom:8px;text-shadow:0 0 30px rgba(88,166,255,0.5)}
.title-name{font-size:2rem;font-weight:900;background:linear-gradient(135deg,var(--accent),var(--purple));-webkit-background-clip:text;-webkit-text-fill-color:transparent;margin-bottom:4px}
.title-sub{color:var(--dim);font-size:0.9rem;margin-bottom:30px}
.title-stats{color:var(--dim);font-size:0.8rem;margin-bottom:20px}
.title-stats span{color:var(--gold);font-weight:bold}
.btn{padding:14px 36px;border:none;border-radius:12px;font-size:1.1rem;font-weight:700;cursor:pointer;transition:all 0.2s;position:relative;overflow:hidden}
.btn:active{transform:scale(0.95)}
.btn-primary{background:linear-gradient(135deg,var(--accent),#1f6feb);color:#fff;box-shadow:0 4px 15px rgba(88,166,255,0.3)}
.btn-gold{background:linear-gradient(135deg,var(--gold),var(--orange));color:#fff;box-shadow:0 4px 15px rgba(210,153,34,0.3)}
.btn-red{background:linear-gradient(135deg,var(--red),#da3633);color:#fff}
.btn-sm{padding:10px 20px;font-size:0.9rem;border-radius:8px}
.btn-dim{background:var(--panel);color:var(--dim);border:1px solid rgba(255,255,255,0.1)}
.btn:disabled{opacity:0.4;pointer-events:none}
.btn-row{display:flex;gap:10px;justify-content:center;flex-wrap:wrap;margin:10px 0}
/* === SHOP === */
.shop-screen{padding:15px;background:var(--bg)}
.shop-title{text-align:center;font-size:1.5rem;font-weight:800;padding:10px 0}
.shop-gold{text-align:center;font-size:1.2rem;color:var(--gold);margin-bottom:15px}
.shop-grid{display:flex;flex-direction:column;gap:10px;padding-bottom:80px}
.shop-item{background:var(--panel);border-radius:12px;padding:14px;display:flex;align-items:center;gap:12px;border:1px solid rgba(255,255,255,0.06)}
.shop-item .icon{font-size:2rem;width:50px;text-align:center;flex-shrink:0}
.shop-item .info{flex:1;min-width:0}
.shop-item .info h3{font-size:0.95rem;margin-bottom:3px}
.shop-item .info p{font-size:0.8rem;color:var(--dim)}
.shop-item .level{font-size:0.75rem;color:var(--accent);margin-top:2px}
/* === BATTLE === */
.battle-screen{background:var(--bg)}
.battle-top{padding:8px 12px;display:flex;justify-content:space-between;align-items:center;background:rgba(0,0,0,0.3);font-size:0.8rem}
.battle-stage{color:var(--accent);font-weight:700}
.battle-relics{display:flex;gap:4px;font-size:0.9rem}
.enemy-area{flex:1;display:flex;align-items:center;justify-content:center;gap:12px;padding:10px;min-height:180px;flex-wrap:wrap}
.enemy{text-align:center;background:var(--panel);border-radius:12px;padding:12px 10px;min-width:80px;max-width:120px;border:2px solid transparent;transition:all 0.2s;position:relative}
.enemy.targeted{border-color:var(--red);box-shadow:0 0 15px rgba(248,81,73,0.3)}
.enemy.hit{animation:dmgFlash 0.3s}
.enemy-emoji{font-size:2.2rem;margin-bottom:4px}
.enemy-name{font-size:0.7rem;color:var(--dim);margin-bottom:4px}
.enemy-intent{font-size:0.7rem;color:var(--orange);margin-bottom:4px}
.enemy-hp-bar{width:100%;height:6px;background:rgba(255,255,255,0.1);border-radius:3px;overflow:hidden;margin-top:4px}
.enemy-hp-fill{height:100%;background:var(--red);transition:width 0.3s;border-radius:3px}
.enemy-hp-text{font-size:0.7rem;color:var(--dim);margin-top:2px}
.enemy-status{font-size:0.7rem;margin-top:3px}
.player-area{background:var(--panel);border-top:1px solid rgba(255,255,255,0.06);padding:8px 12px}
.player-stats{display:flex;justify-content:space-around;align-items:center;margin-bottom:6px}
.stat{display:flex;align-items:center;gap:4px;font-size:0.85rem;font-weight:600}
.stat.hp{color:var(--red)}
.stat.shield{color:var(--shield)}
.stat.mana{color:var(--blue)}
.stat.gold{color:var(--gold)}
.hp-bar{width:100%;height:8px;background:rgba(255,255,255,0.1);border-radius:4px;overflow:hidden;margin-bottom:8px}
.hp-fill{height:100%;border-radius:4px;transition:width 0.3s}
.hp-fill.health{background:linear-gradient(90deg,var(--red),#f0883e)}
.hp-fill.shield-bar{background:var(--shield);position:absolute;top:0;right:0;height:100%}
.hand-area{padding:8px 6px 6px;min-height:130px}
.hand{display:flex;gap:6px;justify-content:center;overflow-x:auto;padding:4px 0;scroll-snap-type:x mandatory}
.card{width:90px;min-width:90px;flex-shrink:0;background:var(--card-bg);border-radius:10px;padding:8px 6px;text-align:center;border:2px solid rgba(255,255,255,0.08);cursor:pointer;transition:all 0.15s;animation:cardIn 0.3s ease-out;position:relative;scroll-snap-align:center;user-select:none}
.card:active{transform:scale(0.95)}
.card.selected{border-color:var(--accent);transform:translateY(-10px);box-shadow:0 8px 25px rgba(88,166,255,0.3)}
.card.disabled{opacity:0.4;pointer-events:none}
.card.playing{animation:cardPlay 0.4s ease-in forwards}
.card-cost{position:absolute;top:-6px;right:-6px;width:22px;height:22px;background:var(--blue);color:#fff;border-radius:50%;font-size:0.7rem;font-weight:800;display:flex;align-items:center;justify-content:center;border:2px solid var(--bg)}
.card-emoji{font-size:1.6rem;margin:4px 0}
.card-name{font-size:0.65rem;font-weight:700;margin-bottom:3px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.card-desc{font-size:0.55rem;color:var(--dim);line-height:1.3}
.card-tier{font-size:0.55rem;color:var(--gold);margin-top:2px}
.card.tier2{border-color:rgba(63,185,80,0.3);background:linear-gradient(180deg,rgba(63,185,80,0.08),var(--card-bg))}
.card.tier3{border-color:rgba(188,140,255,0.3);background:linear-gradient(180deg,rgba(188,140,255,0.1),var(--card-bg));animation:cardIn 0.3s ease-out,glow 2s infinite}
.card.type-attack .card-cost{background:var(--red)}
.card.type-defense .card-cost{background:var(--green)}
.card.type-skill .card-cost{background:var(--purple)}
.end-turn{width:100%;padding:10px;margin-top:4px}
/* === DRAFT / RELIC PICK === */
.pick-screen{padding:20px;align-items:center;justify-content:center;background:rgba(0,0,0,0.95);text-align:center}
.pick-title{font-size:1.3rem;font-weight:800;margin-bottom:5px}
.pick-sub{font-size:0.85rem;color:var(--dim);margin-bottom:20px}
.pick-cards{display:flex;gap:12px;justify-content:center;flex-wrap:wrap;margin-bottom:20px}
.pick-card{width:120px;background:var(--card-bg);border-radius:14px;padding:14px 10px;text-align:center;cursor:pointer;border:2px solid rgba(255,255,255,0.08);transition:all 0.2s;animation:bounceIn 0.4s ease-out}
.pick-card:nth-child(2){animation-delay:0.1s}
.pick-card:nth-child(3){animation-delay:0.2s}
.pick-card:hover,.pick-card:active{border-color:var(--accent);transform:scale(1.05)}
.pick-card .emoji{font-size:2.5rem;margin-bottom:8px}
.pick-card .name{font-size:0.95rem;font-weight:700;margin-bottom:4px}
.pick-card .desc{font-size:0.75rem;color:var(--dim);line-height:1.3;margin-bottom:6px}
.pick-card .tier{font-size:0.7rem;color:var(--gold)}
.pick-card .cost-badge{display:inline-block;padding:2px 8px;border-radius:8px;font-size:0.7rem;font-weight:700;color:#fff;margin-bottom:6px}
.pick-card.type-attack .cost-badge{background:var(--red)}
.pick-card.type-defense .cost-badge{background:var(--green)}
.pick-card.type-skill .cost-badge{background:var(--purple)}
/* === RELIC === */
.relic-card{width:130px;background:var(--panel);border-radius:14px;padding:16px 10px;text-align:center;cursor:pointer;border:2px solid rgba(255,255,255,0.08);transition:all 0.2s;animation:bounceIn 0.4s ease-out}
.relic-card:hover,.relic-card:active{border-color:var(--gold);transform:scale(1.05)}
.relic-card .emoji{font-size:2.5rem;margin-bottom:8px}
.relic-card .name{font-size:0.9rem;font-weight:700;margin-bottom:4px;color:var(--gold)}
.relic-card .desc{font-size:0.75rem;color:var(--dim);line-height:1.3}
/* === FUSION === */
.fusion-screen{padding:15px;background:var(--bg)}
.fusion-title{text-align:center;font-size:1.3rem;font-weight:800;padding:10px 0}
.fusion-sub{text-align:center;font-size:0.8rem;color:var(--dim);margin-bottom:15px}
.fusion-deck{display:flex;flex-wrap:wrap;gap:8px;justify-content:center;padding-bottom:80px}
.fusion-card{width:80px;background:var(--card-bg);border-radius:10px;padding:8px 6px;text-align:center;border:2px solid rgba(255,255,255,0.08);transition:all 0.2s;cursor:pointer}
.fusion-card.fusable{border-color:var(--gold);animation:pulse 1.5s infinite}
.fusion-card .emoji{font-size:1.5rem}
.fusion-card .name{font-size:0.6rem;font-weight:600;margin-top:3px}
.fusion-card .count{font-size:0.6rem;color:var(--gold);margin-top:2px}
/* === GAME OVER === */
.go-screen{align-items:center;justify-content:center;padding:20px;text-align:center;background:rgba(0,0,0,0.95)}
.go-title{font-size:2rem;font-weight:900;margin-bottom:10px}
.go-stats{margin:15px 0;font-size:0.9rem;color:var(--dim);line-height:2}
.go-stats span{color:var(--text);font-weight:700}
.go-gold{font-size:1.5rem;color:var(--gold);font-weight:800;margin:10px 0}
/* === DECK VIEW === */
.deck-screen{padding:15px;background:var(--bg)}
.deck-title{text-align:center;font-size:1.3rem;font-weight:800;padding:10px 0}
.deck-cards{display:flex;flex-wrap:wrap;gap:8px;justify-content:center;padding-bottom:80px}
.fixed-bottom{position:sticky;bottom:0;left:0;right:0;padding:10px;background:linear-gradient(transparent,var(--bg) 20%);text-align:center}
</style>
</head>
<body>
<div id="app">
<!-- Title Screen -->
<div id="titleScreen" class="screen title-screen active">
<div class="title-logo">ğŸƒ</div>
<div class="title-name">ROGUE CARDS</div>
<div class="title-sub">ë¡œê·¸ë¼ì´í¬ ë±ë¹Œë”©</div>
<div class="title-stats">
  ìµœê³  ìŠ¤í…Œì´ì§€: <span id="bestStage">0</span> &nbsp;|&nbsp; ê³¨ë“œ: <span id="totalGold">0</span> ğŸ’°
</div>
<div class="btn-row">
  <button class="btn btn-primary" onclick="Game.startRun()">âš”ï¸ ë˜ì „ ì…ì¥</button>
</div>
<div class="btn-row">
  <button class="btn btn-gold btn-sm" onclick="Game.showShop()">ğŸª ì˜êµ¬ ê°•í™”</button>
  <button class="btn btn-dim btn-sm" onclick="Game.showCollection()">ğŸ“– ë„ê°</button>
</div>
<div style="margin-top:20px;font-size:0.7rem;color:var(--dim)">
  ì¹´ë“œë¥¼ ì¡°í•©í•´ ë˜ì „ì„ ì •ë³µí•˜ë¼!<br>
  ê°™ì€ ì¹´ë“œ 3ì¥ â†’ ìƒìœ„ ì¹´ë“œë¡œ ì§„í™” â¬†ï¸
</div>
</div>
<!-- Shop Screen -->
<div id="shopScreen" class="screen shop-screen">
<div class="shop-title">ğŸª ì˜êµ¬ ê°•í™”</div>
<div class="shop-gold">ğŸ’° <span id="shopGold">0</span></div>
<div class="shop-grid" id="shopGrid"></div>
<div class="fixed-bottom"><button class="btn btn-dim btn-sm" onclick="Game.showTitle()">â† ëŒì•„ê°€ê¸°</button></div>
</div>
<!-- Card Draft Screen -->
<div id="draftScreen" class="screen pick-screen">
<div class="pick-title">ğŸ“¦ ì¹´ë“œ íšë“</div>
<div class="pick-sub">ë±ì— ì¶”ê°€í•  ì¹´ë“œë¥¼ ì„ íƒí•˜ì„¸ìš”</div>
<div class="pick-cards" id="draftCards"></div>
<button class="btn btn-dim btn-sm" onclick="Game.skipDraft()">ê±´ë„ˆë›°ê¸°</button>
</div>
<!-- Battle Screen -->
<div id="battleScreen" class="screen battle-screen">
<div class="battle-top">
  <span class="battle-stage" id="stageLabel">Stage 1</span>
  <div class="battle-relics" id="relicIcons"></div>
  <span class="stat gold">ğŸ’° <span id="battleGold">0</span></span>
</div>
<div class="enemy-area" id="enemyArea"></div>
<div class="player-area">
  <div class="player-stats">
    <span class="stat hp">â¤ï¸ <span id="pHP">50</span>/<span id="pMaxHP">50</span></span>
    <span class="stat shield">ğŸ›¡ï¸ <span id="pShield">0</span></span>
    <span class="stat mana">ğŸ’ <span id="pMana">3</span>/<span id="pMaxMana">3</span></span>
  </div>
  <div class="hp-bar" style="position:relative">
    <div class="hp-fill health" id="hpBar" style="width:100%"></div>
  </div>
  <div class="hand-area">
    <div class="hand" id="handArea"></div>
    <div style="display:flex;gap:8px;margin-top:4px">
      <button class="btn btn-red btn-sm end-turn" onclick="Game.endTurn()" id="endTurnBtn">â© í„´ ì¢…ë£Œ</button>
      <button class="btn btn-dim btn-sm" style="width:50px" onclick="Game.showDeckView()">ğŸ“‹</button>
    </div>
  </div>
</div>
</div>
<!-- Relic Pick Screen -->
<div id="relicScreen" class="screen pick-screen">
<div class="pick-title">âœ¨ ìœ ë¬¼ ë°œê²¬!</div>
<div class="pick-sub">ìœ ë¬¼ í•˜ë‚˜ë¥¼ ì„ íƒí•˜ì„¸ìš”</div>
<div class="pick-cards" id="relicCards"></div>
<button class="btn btn-dim btn-sm" onclick="Game.skipRelic()">ê±´ë„ˆë›°ê¸°</button>
</div>
<!-- Fusion Screen -->
<div id="fusionScreen" class="screen fusion-screen">
<div class="fusion-title">âš—ï¸ ì¹´ë“œ í•©ì„±</div>
<div class="fusion-sub">ê°™ì€ ì¹´ë“œ 3ì¥ â†’ ìƒìœ„ ì¹´ë“œë¡œ ì§„í™”!</div>
<div class="fusion-deck" id="fusionDeck"></div>
<div class="fixed-bottom">
  <button class="btn btn-primary btn-sm" onclick="Game.continueBattle()">â–¶ ë‹¤ìŒ ì „íˆ¬</button>
</div>
</div>
<!-- Deck View -->
<div id="deckScreen" class="screen deck-screen">
<div class="deck-title">ğŸ“‹ ë‚´ ë± (<span id="deckCount">0</span>)</div>
<div class="deck-cards" id="deckCards"></div>
<div class="fixed-bottom"><button class="btn btn-dim btn-sm" onclick="Game.closeDeckView()">â† ëŒì•„ê°€ê¸°</button></div>
</div>
<!-- Game Over -->
<div id="gameOverScreen" class="screen go-screen">
<div class="go-title" id="goTitle">ğŸ’€ Game Over</div>
<div class="go-stats" id="goStats"></div>
<div class="go-gold" id="goGold"></div>
<div class="btn-row">
  <button class="btn btn-primary" onclick="Game.showTitle()">ğŸ  ë¡œë¹„ë¡œ</button>
  <button class="btn btn-gold" onclick="Game.startRun()">ğŸ”„ ì¬ë„ì „</button>
</div>
</div>
<!-- Collection -->
<div id="collectionScreen" class="screen deck-screen">
<div class="deck-title">ğŸ“– ì¹´ë“œ ë„ê° (<span id="collUnlocked">0</span>/<span id="collTotal">0</span>)</div>
<div class="deck-cards" id="collCards"></div>
<div class="fixed-bottom"><button class="btn btn-dim btn-sm" onclick="Game.showTitle()">â† ëŒì•„ê°€ê¸°</button></div>
</div>
</div>
<canvas id="fx"></canvas>
<script>
// ============================================================
// AUDIO ENGINE - Web Audio API procedural sound effects
// ============================================================
const Audio = (() => {
  let ctx = null;
  const init = () => { if (!ctx) ctx = new (window.AudioContext || window.webkitAudioContext)(); };
  const play = (freq, type, dur, vol=0.3, slide=0) => {
    try {
      init();
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.type = type;
      osc.frequency.setValueAtTime(freq, ctx.currentTime);
      if (slide) osc.frequency.exponentialRampToValueAtTime(Math.max(slide, 20), ctx.currentTime + dur);
      gain.gain.setValueAtTime(vol, ctx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + dur);
      osc.connect(gain);
      gain.connect(ctx.destination);
      osc.start(ctx.currentTime);
      osc.stop(ctx.currentTime + dur);
    } catch(e) {}
  };
  const noise = (dur, vol=0.15) => {
    try {
      init();
      const bufSize = ctx.sampleRate * dur;
      const buf = ctx.createBuffer(1, bufSize, ctx.sampleRate);
      const data = buf.getChannelData(0);
      for (let i = 0; i < bufSize; i++) data[i] = Math.random() * 2 - 1;
      const src = ctx.createBufferSource();
      src.buffer = buf;
      const gain = ctx.createGain();
      gain.gain.setValueAtTime(vol, ctx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + dur);
      src.connect(gain);
      gain.connect(ctx.destination);
      src.start();
    } catch(e) {}
  };
  return {
    cardDraw() { play(800, 'sine', 0.08, 0.15); setTimeout(() => play(1200, 'sine', 0.06, 0.1), 40); },
    cardPlay() { play(400, 'sine', 0.12, 0.2, 800); },
    attack() { noise(0.12, 0.2); play(200, 'square', 0.1, 0.15, 80); },
    heavyAttack() { noise(0.2, 0.3); play(150, 'sawtooth', 0.15, 0.2, 50); setTimeout(() => play(100, 'square', 0.1, 0.15), 80); },
    playerHit() { play(150, 'sawtooth', 0.2, 0.25, 60); noise(0.15, 0.2); },
    shield() { play(600, 'sine', 0.15, 0.15, 900); play(800, 'triangle', 0.1, 0.1); },
    heal() { play(523, 'sine', 0.15, 0.15); setTimeout(() => play(659, 'sine', 0.15, 0.15), 100); setTimeout(() => play(784, 'sine', 0.2, 0.15), 200); },
    enemyDie() { play(300, 'square', 0.1, 0.15, 100); noise(0.2, 0.2); setTimeout(() => play(500, 'sine', 0.15, 0.1), 100); },
    poison() { play(200, 'sawtooth', 0.3, 0.1, 100); },
    buff() { play(440, 'triangle', 0.1, 0.15); setTimeout(() => play(660, 'triangle', 0.1, 0.15), 80); },
    debuff() { play(300, 'sawtooth', 0.2, 0.12, 150); },
    victory() { [523,659,784,1047].forEach((f,i) => setTimeout(() => play(f, 'sine', 0.3, 0.15), i * 120)); },
    gameOver() { [400,350,300,200].forEach((f,i) => setTimeout(() => play(f, 'sine', 0.4, 0.15), i * 200)); },
    click() { play(600, 'sine', 0.05, 0.1); },
    fusion() { play(400, 'sine', 0.1, 0.15); setTimeout(() => play(600, 'sine', 0.1, 0.15), 80); setTimeout(() => play(900, 'sine', 0.2, 0.2), 160); setTimeout(() => play(1200, 'triangle', 0.3, 0.15), 240); },
    boss() { play(100, 'sawtooth', 0.5, 0.2, 50); setTimeout(() => play(80, 'square', 0.5, 0.2, 40), 200); noise(0.3, 0.15); },
    relic() { play(800, 'sine', 0.2, 0.15); setTimeout(() => play(1000, 'triangle', 0.2, 0.15), 100); setTimeout(() => play(1200, 'sine', 0.3, 0.2), 200); },
    coin() { play(1500, 'sine', 0.08, 0.1); setTimeout(() => play(2000, 'sine', 0.08, 0.1), 60); },
  };
})();

// ============================================================
// PARTICLE SYSTEM
// ============================================================
const Particles = (() => {
  const canvas = document.getElementById('fx');
  const pCtx = canvas.getContext('2d');
  let particles = [];
  let w, h;
  const resize = () => { w = canvas.width = window.innerWidth; h = canvas.height = window.innerHeight; };
  window.addEventListener('resize', resize);
  resize();
  const spawn = (x, y, count, color, speed=3, life=40, size=3) => {
    for (let i = 0; i < count; i++) {
      const angle = Math.random() * Math.PI * 2;
      const spd = Math.random() * speed + 1;
      particles.push({ x, y, vx: Math.cos(angle)*spd, vy: Math.sin(angle)*spd - 1, life, maxLife: life, color, size: Math.random()*size+1 });
    }
  };
  const spawnText = (x, y, text, color) => {
    const el = document.createElement('div');
    el.className = 'float-text';
    el.style.left = x + 'px'; el.style.top = y + 'px'; el.style.color = color;
    el.textContent = text;
    document.getElementById('app').appendChild(el);
    setTimeout(() => el.remove(), 1000);
  };
  const update = () => {
    pCtx.clearRect(0, 0, w, h);
    particles = particles.filter(p => {
      p.x += p.vx; p.y += p.vy; p.vy += 0.05; p.life--;
      const alpha = p.life / p.maxLife;
      pCtx.globalAlpha = alpha;
      pCtx.fillStyle = p.color;
      pCtx.beginPath();
      pCtx.arc(p.x, p.y, p.size * alpha, 0, Math.PI * 2);
      pCtx.fill();
      return p.life > 0;
    });
    pCtx.globalAlpha = 1;
    requestAnimationFrame(update);
  };
  update();
  return { spawn, spawnText };
})();

// ============================================================
// GAME DATA - Cards, Relics, Enemies, Upgrades
// ============================================================
const CARD_DEFS = [
  // ATTACK CARDS (id, name, emoji, type, cost[t1,t2,t3], desc_fn, effect_fn)
  { id:'strike', name:['íƒ€ê²©','ê°•íƒ€','ë©¸ì‚´'], emoji:'âš”ï¸', type:'attack',
    cost:[1,1,2], desc: t => [`${6+t*6} ë°ë¯¸ì§€`,`${12+t*4} ë°ë¯¸ì§€`,`${20+t*4} ë°ë¯¸ì§€`][t],
    fx: (g,t) => { g.dealDamage([6,12,20][t]); }},
  { id:'fireball', name:['í™”ì—¼íƒ„','í™”ì—¼êµ¬','ì¸í˜ë¥´ë…¸'], emoji:'ğŸ”¥', type:'attack',
    cost:[2,2,3], desc: t => [`${10+t*6} ë°ë¯¸ì§€`,`${16+t*4} ë°ë¯¸ì§€`,`ì  ì „ì²´ ${12+t*6} ë°ë¯¸ì§€`][t],
    fx: (g,t) => { if(t<2) g.dealDamage([10,16,24][t]); else g.dealDamageAll([10,16,24][t]); }},
  { id:'ice_spike', name:['ì–¼ìŒì¹¨','ë¹™ê²°ì°½','ë¸”ë¦¬ìë“œ'], emoji:'â„ï¸', type:'attack',
    cost:[1,2,2], desc: t => [`${5+t*4} ë°ë¯¸ì§€+ì•½í™”1`,`${9+t*3} ë°ë¯¸ì§€+ì•½í™”2`,`ì „ì²´ ${7+t*5} ë°ë¯¸ì§€+ì•½í™”2`][t],
    fx: (g,t) => { const d=[5,9,17][t]; const w=[1,2,2][t]; if(t<2){g.dealDamage(d);g.applyWeak(w);}else{g.dealDamageAll(d);g.applyWeakAll(w);} }},
  { id:'poison_dagger', name:['ë…ë‹¨ê²€','ë…ì•ˆê°œ','ì—­ë³‘'], emoji:'ğŸ—¡ï¸', type:'attack',
    cost:[1,1,2], desc: t => [`${3+t*2} ë°ë¯¸ì§€+ë…${3+t*2}`,`${5+t*2} ë°ë¯¸ì§€+ë…${5+t*2}`,`${7+t*3} ë°ë¯¸ì§€+ë…${7+t*3}`][t],
    fx: (g,t) => { const d=[3,5,10][t]; const p=[3,5,10][t]; g.dealDamage(d); g.applyPoison(p); }},
  { id:'quick_slash', name:['ì†ê³µ','ì—°íƒ€','ì¹¼ë°”ëŒ'], emoji:'ğŸ’¨', type:'attack',
    cost:[1,1,2], desc: t => [`${4+t*1}Ã—${[1,2,3][t]}íšŒ`,`${5+t*1}Ã—${[1,2,3][t]}íšŒ`,`${6+t*1}Ã—${[1,2,3][t]}íšŒ`][t],
    fx: (g,t) => { const d=[4,5,7][t]; const n=[1,2,3][t]; for(let i=0;i<n;i++) setTimeout(()=>g.dealDamage(d,true),i*150); }},
  { id:'smite', name:['ì²œë²Œ','ì‹¬íŒ','ì‹ ì˜ë¶„ë…¸'], emoji:'âš¡', type:'attack',
    cost:[2,2,3], desc: t => [`${8+t*5} ë°ë¯¸ì§€`,`${13+t*4} ë°ë¯¸ì§€+ê´€í†µ`,`${20+t*5} ë°ë¯¸ì§€+ê´€í†µ`][t],
    fx: (g,t) => { g.dealDamage([8,13,25][t],false,t>=1); }},
  { id:'shadow_strike', name:['ê·¸ë¦¼ìë² ê¸°','ì•”í‘ì¼ê²©','ë³´ì´ë“œìŠ¬ë˜ì‹œ'], emoji:'ğŸŒ‘', type:'attack',
    cost:[1,1,2], desc: t => [`${5+t*4} ë°ë¯¸ì§€, ì¹´ë“œ1ì¥`,`${9+t*3} ë°ë¯¸ì§€, ì¹´ë“œ1ì¥`,`${14+t*4} ë°ë¯¸ì§€, ì¹´ë“œ2ì¥`][t],
    fx: (g,t) => { g.dealDamage([5,9,18][t]); g.drawCards(t<2?1:2); }},
  // DEFENSE CARDS
  { id:'guard', name:['ë°©ì–´','ì² ë²½','ìš”ìƒˆ'], emoji:'ğŸ›¡ï¸', type:'defense',
    cost:[1,1,2], desc: t => [`ë°©ì–´ ${6+t*5}`,`ë°©ì–´ ${11+t*4}`,`ë°©ì–´ ${18+t*4}`][t],
    fx: (g,t) => { g.gainShield([6,11,22][t]); }},
  { id:'heal', name:['ì¹˜ìœ ','ëŒ€ì¹˜ìœ ','ì™„ì „íšŒë³µ'], emoji:'ğŸ’š', type:'defense',
    cost:[1,2,3], desc: t => [`HP ${5+t*4} íšŒë³µ`,`HP ${9+t*4} íšŒë³µ`,`HP ì „ì²´ íšŒë³µ`][t],
    fx: (g,t) => { if(t<2) g.healPlayer([5,9,15][t]); else g.healPlayer(999); }},
  { id:'barrier', name:['ì¥ë²½','ë§ˆë‚˜ì‹¤ë“œ','ì•„ì¼€ì¸ì¥ë²½'], emoji:'ğŸ”®', type:'defense',
    cost:[0,1,1], desc: t => [`ë°©ì–´ ${3+t*3}`,`ë°©ì–´ ${6+t*3}+ë§ˆë‚˜1`,`ë°©ì–´ ${12+t*3}+ë§ˆë‚˜2`][t],
    fx: (g,t) => { g.gainShield([3,6,15][t]); if(t>=1) g.gainMana(t>=2?2:1); }},
  { id:'thorn_armor', name:['ê°€ì‹œê°‘ì˜·','ë°˜ê²©ê°‘ì˜·','ë³´ë³µì˜ê°‘ì˜·'], emoji:'ğŸŒ¿', type:'defense',
    cost:[1,1,2], desc: t => [`ë°©ì–´ ${4+t*3}+ê°€ì‹œ${2+t}`,`ë°©ì–´ ${7+t*3}+ê°€ì‹œ${3+t}`,`ë°©ì–´ ${12+t*3}+ê°€ì‹œ${5+t}`][t],
    fx: (g,t) => { g.gainShield([4,7,15][t]); g.gainThorns([2,3,7][t]); }},
  // SKILL CARDS
  { id:'rage', name:['ê²©ë…¸','ê´‘í­','í”¼ì˜ê°ˆì¦'], emoji:'ğŸ˜¤', type:'skill',
    cost:[0,0,1], desc: t => [`ì´ë²ˆí„´ ê³µê²©+${3+t*2}`,`ì´ë²ˆí„´ ê³µê²©+${5+t*2}`,`ì´ë²ˆí„´ ê³µê²©+${8+t*3}`][t],
    fx: (g,t) => { g.gainStrength([3,5,11][t]); }},
  { id:'draw_card', name:['ë“œë¡œìš°','ì‹¬ì¸µíƒìƒ‰','ì¹´ë“œí­ì£¼'], emoji:'ğŸ“œ', type:'skill',
    cost:[1,1,2], desc: t => [`ì¹´ë“œ ${1+t}ì¥ ë½‘ê¸°`,`ì¹´ë“œ ${2+t}ì¥ ë½‘ê¸°`,`ì¹´ë“œ ${3+t}ì¥ ë½‘ê¸°`][t],
    fx: (g,t) => { g.drawCards([1,2,3][t]); }},
  { id:'weaken', name:['ì•½í™”','ì‡ ì•½','ë¶„ì‡„'], emoji:'ğŸ’«', type:'skill',
    cost:[1,1,2], desc: t => [`ì  ê³µê²©-${2+t*2} (2í„´)`,`ì  ê³µê²©-${4+t*2} (2í„´)`,`ì „ì²´ ê³µê²©-${6+t*2} (3í„´)`][t],
    fx: (g,t) => { if(t<2){g.applyWeak([2,4,8][t]);}else{g.applyWeakAll([2,4,8][t]);} }},
  { id:'lifesteal', name:['í¡í˜ˆ','ë±€íŒŒì´ë¦­í„°ì¹˜','ì˜í˜¼í¡ìˆ˜'], emoji:'ğŸ¦‡', type:'skill',
    cost:[2,2,2], desc: t => [`${4+t*3} ë°ë¯¸ì§€, HPíšŒë³µ`,`${7+t*3} ë°ë¯¸ì§€, HPíšŒë³µ`,`${12+t*3} ë°ë¯¸ì§€, HPíšŒë³µ`][t],
    fx: (g,t) => { const d=[4,7,15][t]; g.dealDamage(d); g.healPlayer(d); }},
  { id:'empower', name:['ê°•í™”','ì¦í­','ì´ˆì›”'], emoji:'âœ¨', type:'skill',
    cost:[1,1,2], desc: t => [`ë‹¤ìŒì¹´ë“œ íš¨ê³¼Ã—${[1.5,1.8,2.5][t]}`,`ë‹¤ìŒì¹´ë“œ íš¨ê³¼Ã—${[1.5,1.8,2.5][t]}`,`ë‹¤ìŒì¹´ë“œ íš¨ê³¼Ã—${[1.5,1.8,2.5][t]}`][t],
    fx: (g,t) => { g.state.empower = [1.5,1.8,2.5][t]; }},
  { id:'combo', name:['ì—°ê³„','ì²´ì¸','ë¬´í•œì—°ê³„'], emoji:'ğŸ”—', type:'skill',
    cost:[1,1,1], desc: t => [`${3+t*2} ë°ë¯¸ì§€, 0ì½”ìŠ¤íŠ¸ì‹œ+ì¹´ë“œ`,`${5+t*2} ë°ë¯¸ì§€, 0ì½”ìŠ¤íŠ¸ì‹œ+ì¹´ë“œ`,`${8+t*2} ë°ë¯¸ì§€, í•­ìƒ+ì¹´ë“œ`][t],
    fx: (g,t) => { g.dealDamage([3,5,10][t]); if(t>=2||g.state.mana===g.state.maxMana) g.drawCards(1); }},
  { id:'sacrifice', name:['í¬ìƒ','í˜ˆì•½','ì–´ë‘ ì˜ì œë¬¼'], emoji:'ğŸ’€', type:'skill',
    cost:[0,0,0], desc: t => [`HP-${[3,5,6][t]}, ë§ˆë‚˜+${[2,2,3][t]}`,`HP-${[3,5,6][t]}, ë§ˆë‚˜+${[2,2,3][t]}`,`HP-${[3,5,6][t]}, ë§ˆë‚˜+${[2,2,3][t]}+ì¹´ë“œ2`][t],
    fx: (g,t) => { g.loseHP([3,5,6][t]); g.gainMana([2,2,3][t]); if(t>=2) g.drawCards(2); }},
  { id:'fortify', name:['ê°•í™”ë°©ì–´','ë³´ê°•','ë‚œê³µë¶ˆë½'], emoji:'ğŸ°', type:'skill',
    cost:[1,1,2], desc: t => [`ë°©ì–´ ${4+t*3}+ë‹¤ìŒí„´ ë°©ì–´ìœ ì§€`,`ë°©ì–´ ${7+t*3}+ë°©ì–´ìœ ì§€`,`ë°©ì–´ ${13+t*3}+ë°©ì–´ìœ ì§€+HP5`][t],
    fx: (g,t) => { g.gainShield([4,7,16][t]); g.state.retainShield=true; if(t>=2) g.healPlayer(5); }},
];

const RELIC_DEFS = [
  { id:'warrior_amulet', name:'ì „ì‚¬ì˜ ë¶€ì ', emoji:'ğŸ—¡ï¸', desc:'ìµœëŒ€ HP +10', fx: s => { s.maxHP+=10; s.hp+=10; }},
  { id:'mana_crystal', name:'ë§ˆë‚˜ ìˆ˜ì •', emoji:'ğŸ’', desc:'ë§¤ í„´ ë§ˆë‚˜ +1', fx: s => { s.maxMana+=1; }},
  { id:'thorn_ring', name:'ê°€ì‹œ ë°˜ì§€', emoji:'ğŸŒ¹', desc:'í”¼ê²© ì‹œ ë°˜ì‚¬ 3 ë°ë¯¸ì§€', onHit: (s,e) => { e.hp -= 3; }},
  { id:'healing_orb', name:'ì¹˜ìœ ì˜ êµ¬ìŠ¬', emoji:'ğŸ’š', desc:'ì „íˆ¬ ì‹œì‘ ì‹œ HP 5 íšŒë³µ', onBattleStart: s => { s.hp = Math.min(s.maxHP, s.hp+5); }},
  { id:'lucky_coin', name:'í–‰ìš´ì˜ ë™ì „', emoji:'ğŸ’°', desc:'ê³¨ë“œ íšë“ +40%', goldMult: 1.4},
  { id:'shield_gem', name:'ì‹¤ë“œ ë³´ì„', emoji:'ğŸ›¡ï¸', desc:'ì „íˆ¬ ì‹œì‘ ì‹œ ë°©ì–´ 8', onBattleStart: s => { s.shield += 8; }},
  { id:'vampire_fang', name:'ë±€íŒŒì´ì–´ ì†¡ê³³ë‹ˆ', emoji:'ğŸ¦‡', desc:'ì  ì²˜ì¹˜ ì‹œ HP 3 íšŒë³µ', onKill: s => { s.hp = Math.min(s.maxHP, s.hp+3); }},
  { id:'power_stone', name:'íŒŒì›Œ ìŠ¤í†¤', emoji:'âš¡', desc:'ëª¨ë“  ê³µê²© ë°ë¯¸ì§€ +3', atkBonus: 3},
  { id:'card_pouch', name:'ì¹´ë“œ ì£¼ë¨¸ë‹ˆ', emoji:'ğŸ“œ', desc:'í„´ ì‹œì‘ ì‹œ ì¹´ë“œ 1ì¥ ì¶”ê°€', drawBonus: 1},
  { id:'phoenix_feather', name:'ë¶ˆì‚¬ì¡° ê¹ƒí„¸', emoji:'ğŸ”¥', desc:'1íšŒ ë¶€í™œ (HP 30%)', revive: true},
  { id:'frost_amulet', name:'ì„œë¦¬ ë¶€ì ', emoji:'â„ï¸', desc:'25% í™•ë¥ ë¡œ ì  ë™ê²° (1í„´ ìŠ¤í‚µ)', freezeChance: 0.25},
  { id:'chaos_orb', name:'í˜¼ëˆì˜ ì˜¤ë¸Œ', emoji:'ğŸ²', desc:'ëª¨ë“  íš¨ê³¼ Ã—1.5, 20% ë¹—ë‚˜ê°', chaosMult: 1.5, chaosMiss: 0.2},
];

const ENEMY_TEMPLATES = {
  slime: {name:'ìŠ¬ë¼ì„',emoji:'ğŸŸ¢',hp:18,atk:5,gold:8},
  rat: {name:'ì¥',emoji:'ğŸ€',hp:14,atk:6,gold:7},
  bat: {name:'ë°•ì¥',emoji:'ğŸ¦‡',hp:16,atk:7,gold:9},
  skeleton: {name:'í•´ê³¨',emoji:'ğŸ’€',hp:28,atk:8,gold:12},
  goblin: {name:'ê³ ë¸”ë¦°',emoji:'ğŸ‘º',hp:24,atk:9,gold:11},
  orc: {name:'ì˜¤í¬',emoji:'ğŸ‘¹',hp:38,atk:11,gold:16},
  dark_mage: {name:'í‘ë§ˆë²•ì‚¬',emoji:'ğŸ§™',hp:30,atk:13,gold:18},
  golem: {name:'ê³¨ë ˜',emoji:'ğŸ—¿',hp:55,atk:12,gold:22},
  wraith: {name:'ë ˆì´ìŠ¤',emoji:'ğŸ‘»',hp:42,atk:15,gold:20},
  demon: {name:'ì•…ë§ˆ',emoji:'ğŸ˜ˆ',hp:60,atk:16,gold:25},
  vampire: {name:'ë±€íŒŒì´ì–´',emoji:'ğŸ§›',hp:50,atk:14,gold:24,lifesteal:true},
  lich: {name:'ë¦¬ì¹˜',emoji:'â˜ ï¸',hp:65,atk:17,gold:28},
  // Bosses
  boss_dragon: {name:'ë“œë˜ê³¤',emoji:'ğŸ‰',hp:100,atk:18,gold:50,boss:true},
  boss_demon_lord: {name:'ë§ˆì™•',emoji:'ğŸ‘¿',hp:140,atk:22,gold:70,boss:true},
  boss_ancient: {name:'ê³ ëŒ€ì‹ ',emoji:'ğŸŒ€',hp:200,atk:28,gold:100,boss:true},
};

const STAGE_WAVES = [
  // Stage 1
  [['slime'],['rat','rat'],['slime','bat']],
  // Stage 2
  [['skeleton'],['goblin','bat'],['skeleton','rat']],
  // Stage 3
  [['orc'],['dark_mage','goblin'],['orc','skeleton']],
  // Stage 4
  [['golem'],['wraith','dark_mage'],['golem','goblin']],
  // Stage 5 (Boss)
  [['demon','demon'],['boss_dragon']],
  // Stage 6
  [['vampire','wraith'],['lich','demon'],['demon','vampire']],
  // Stage 7
  [['lich','golem'],['vampire','lich'],['demon','wraith']],
  // Stage 8
  [['lich','demon','wraith'],['boss_demon_lord']],
  // Stage 9
  [['lich','lich','demon'],['vampire','golem','wraith']],
  // Stage 10 (Final)
  [['demon','lich','vampire'],['boss_ancient']],
];

const UPGRADES = [
  { id:'max_hp', name:'ìµœëŒ€ ì²´ë ¥', emoji:'â¤ï¸', desc:'+8 HP', levels:5, costs:[50,100,180,300,500], fx: (s,l) => { s.baseMaxHP += 8; }},
  { id:'max_mana', name:'ë§ˆë‚˜ ì¦ê°€', emoji:'ğŸ’', desc:'+1 ë§ˆë‚˜', levels:3, costs:[120,250,500], fx: (s,l) => { s.baseMana += 1; }},
  { id:'atk_bonus', name:'ê¸°ë³¸ ê³µê²©ë ¥', emoji:'âš”ï¸', desc:'+2 ë°ë¯¸ì§€', levels:5, costs:[80,160,300,500,800], fx: (s,l) => { s.baseAtk += 2; }},
  { id:'start_shield', name:'ì‹œì‘ ë°©ì–´ë ¥', emoji:'ğŸ›¡ï¸', desc:'+5 ì‹œì‘ ì‹¤ë“œ', levels:4, costs:[60,120,220,400], fx: (s,l) => { s.baseShield += 5; }},
  { id:'gold_bonus', name:'ê³¨ë“œ ë³´ë„ˆìŠ¤', emoji:'ğŸ’°', desc:'+20% ê³¨ë“œ', levels:5, costs:[75,150,280,450,700], fx: (s,l) => { s.goldMult += 0.2; }},
  { id:'card_draw', name:'ì¶”ê°€ ë“œë¡œìš°', emoji:'ğŸ“œ', desc:'+1 ì‹œì‘ ì¹´ë“œ', levels:2, costs:[200,500], fx: (s,l) => { s.baseDraw += 1; }},
  { id:'start_relic', name:'ì‹œì‘ ìœ ë¬¼', emoji:'âœ¨', desc:'ìœ ë¬¼ 1ê°œ ì§€ê¸‰', levels:2, costs:[300,600], fx: (s,l) => { s.startRelics += 1; }},
  { id:'heal_per_stage', name:'ìŠ¤í…Œì´ì§€ íšŒë³µ', emoji:'ğŸ’š', desc:'+5 HP/ìŠ¤í…Œì´ì§€', levels:3, costs:[100,200,400], fx: (s,l) => { s.stageHeal += 5; }},
];

// ============================================================
// SAVE SYSTEM
// ============================================================
const Save = {
  KEY: 'rogue_cards_v2',
  data: { gold: 0, bestStage: 0, upgrades: {}, unlocked: [], totalRuns: 0, totalKills: 0 },
  load() {
    try {
      const d = JSON.parse(localStorage.getItem(this.KEY));
      if (d) Object.assign(this.data, d);
    } catch(e) {}
  },
  save() {
    try { localStorage.setItem(this.KEY, JSON.stringify(this.data)); } catch(e) {}
  },
  getUpgradeLevel(id) { return this.data.upgrades[id] || 0; },
  unlockCard(cardId) {
    if (!this.data.unlocked.includes(cardId)) { this.data.unlocked.push(cardId); this.save(); }
  }
};

// ============================================================
// UTILITY
// ============================================================
const $ = id => document.getElementById(id);
const shuffle = arr => { const a=[...arr]; for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];} return a; };
const pick = arr => arr[Math.floor(Math.random()*arr.length)];
const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
const rng = (min, max) => Math.floor(Math.random()*(max-min+1))+min;
const sleep = ms => new Promise(r => setTimeout(r, ms));

function makeCard(defId, tier=0) {
  const def = CARD_DEFS.find(d => d.id === defId);
  if (!def) return null;
  return {
    defId: def.id,
    name: def.name[tier],
    emoji: def.emoji,
    type: def.type,
    cost: def.cost[tier],
    tier: tier,
    desc: def.desc(tier),
    uid: Math.random().toString(36).slice(2,8)
  };
}

function tierStars(t) { return t === 0 ? '' : t === 1 ? 'â˜…â˜…' : 'â˜…â˜…â˜…'; }

// ============================================================
// MAIN GAME
// ============================================================
const Game = (() => {
  let state = {};
  let screenStack = [];
  let animating = false;

  function showScreen(id) {
    document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
    $(id).classList.add('active');
  }

  function initState() {
    // Calculate base stats from permanent upgrades
    let baseMaxHP = 50, baseMana = 3, baseAtk = 0, baseShield = 0;
    let goldMult = 1, baseDraw = 5, startRelics = 0, stageHeal = 0;
    const perm = { baseMaxHP, baseMana, baseAtk, baseShield, goldMult, baseDraw, startRelics, stageHeal };
    UPGRADES.forEach(u => {
      const lvl = Save.getUpgradeLevel(u.id);
      for (let i = 0; i < lvl; i++) u.fx(perm, i);
    });

    state = {
      // Player
      hp: perm.baseMaxHP, maxHP: perm.baseMaxHP,
      mana: perm.baseMana, maxMana: perm.baseMana,
      shield: perm.baseShield,
      strength: 0, // temp attack bonus
      thorns: 0,
      empower: 1,
      retainShield: false,
      baseAtk: perm.baseAtk,
      goldMult: perm.goldMult,
      baseDraw: perm.baseDraw,
      stageHeal: perm.stageHeal,
      // Run
      stage: 1, wave: 0, gold: 0,
      deck: [], hand: [], discard: [], drawPile: [],
      relics: [],
      enemies: [],
      target: 0,
      // Flags
      phase: 'player', // player, enemy, animating
      revived: false,
      cardsPlayed: 0,
      turnsTotal: 0,
      killsThisRun: 0,
    };

    // Starting deck: 4 Strike, 3 Guard, 2 Heal, 1 Rage
    const starterDeck = [
      ...Array(4).fill('strike'),
      ...Array(3).fill('guard'),
      ...Array(2).fill('heal'),
      'rage'
    ];
    state.deck = starterDeck.map(id => makeCard(id, 0));
    state.deck.forEach(c => Save.unlockCard(c.defId + '_0'));

    // Starting relics from permanent upgrades
    if (perm.startRelics > 0) {
      const available = shuffle([...RELIC_DEFS]);
      for (let i = 0; i < Math.min(perm.startRelics, available.length); i++) {
        applyRelic(available[i]);
      }
    }
  }

  function applyRelic(relicDef) {
    state.relics.push({...relicDef});
    if (relicDef.fx) relicDef.fx(state);
    if (relicDef.atkBonus) state.baseAtk += relicDef.atkBonus;
    if (relicDef.drawBonus) state.baseDraw += relicDef.drawBonus;
  }

  function hasRelic(id) { return state.relics.some(r => r.id === id); }

  // ---- SCREENS ----
  function showTitle() {
    Save.load();
    $('bestStage').textContent = Save.data.bestStage;
    $('totalGold').textContent = Save.data.gold;
    showScreen('titleScreen');
  }

  function showShop() {
    Save.load();
    $('shopGold').textContent = Save.data.gold;
    const grid = $('shopGrid');
    grid.innerHTML = '';
    UPGRADES.forEach(u => {
      const lvl = Save.getUpgradeLevel(u.id);
      const maxed = lvl >= u.levels;
      const cost = maxed ? '-' : u.costs[lvl];
      const canBuy = !maxed && Save.data.gold >= cost;
      const item = document.createElement('div');
      item.className = 'shop-item';
      item.style.opacity = maxed ? '0.5' : '1';
      item.innerHTML = `
        <div class="icon">${u.emoji}</div>
        <div class="info">
          <h3>${u.name}</h3>
          <p>${u.desc}</p>
          <div class="level">Lv.${lvl}/${u.levels}</div>
        </div>
        <button class="btn btn-gold btn-sm" ${canBuy?'':'disabled'}>
          ${maxed?'MAX':cost+'ğŸ’°'}
        </button>`;
      if (canBuy) {
        item.querySelector('button').onclick = () => {
          Save.data.gold -= cost;
          Save.data.upgrades[u.id] = lvl + 1;
          Save.save();
          Audio.coin();
          showShop();
        };
      }
      grid.appendChild(item);
    });
    showScreen('shopScreen');
  }

  function showCollection() {
    Save.load();
    const container = $('collCards');
    container.innerHTML = '';
    let total = 0, unlocked = 0;
    CARD_DEFS.forEach(def => {
      for (let t = 0; t < 3; t++) {
        total++;
        const key = def.id + '_' + t;
        const isUnlocked = Save.data.unlocked.includes(key);
        if (isUnlocked) unlocked++;
        const card = makeCard(def.id, t);
        const el = document.createElement('div');
        el.className = `card type-${def.type} ${t>0?'tier'+t:''}`;
        el.style.opacity = isUnlocked ? '1' : '0.3';
        el.innerHTML = `
          <div class="card-cost">${card.cost}</div>
          <div class="card-emoji">${isUnlocked ? card.emoji : 'â“'}</div>
          <div class="card-name">${isUnlocked ? card.name : '???'}</div>
          <div class="card-desc">${isUnlocked ? card.desc : 'ë¯¸ë°œê²¬'}</div>
          ${t > 0 ? `<div class="card-tier">${tierStars(t)}</div>` : ''}`;
        container.appendChild(el);
      }
    });
    $('collUnlocked').textContent = unlocked;
    $('collTotal').textContent = total;
    showScreen('collectionScreen');
  }

  // ---- RUN ----
  function startRun() {
    Audio.click();
    initState();
    showDraft();
  }

  // ---- DRAFT ----
  function showDraft() {
    const container = $('draftCards');
    container.innerHTML = '';
    // Offer 3 random cards, tier based on stage
    const tierChance = Math.min(state.stage * 0.08, 0.5);
    const tier2Chance = Math.min(state.stage * 0.03, 0.2);
    const offers = [];
    const usedIds = new Set();
    while (offers.length < 3) {
      const def = pick(CARD_DEFS);
      if (usedIds.has(def.id)) continue;
      usedIds.add(def.id);
      let tier = 0;
      if (Math.random() < tier2Chance) tier = 2;
      else if (Math.random() < tierChance) tier = 1;
      offers.push(makeCard(def.id, tier));
    }
    offers.forEach(card => {
      const el = document.createElement('div');
      el.className = `pick-card type-${card.type}`;
      el.innerHTML = `
        <div class="cost-badge">${card.cost} ğŸ’</div>
        <div class="emoji">${card.emoji}</div>
        <div class="name">${card.name}</div>
        <div class="desc">${card.desc}</div>
        ${card.tier > 0 ? `<div class="tier">${tierStars(card.tier)}</div>` : ''}`;
      el.onclick = () => {
        Audio.cardDraw();
        state.deck.push(card);
        Save.unlockCard(card.defId + '_' + card.tier);
        Save.save();
        startBattle();
      };
      container.appendChild(el);
    });
    showScreen('draftScreen');
  }

  function skipDraft() { Audio.click(); startBattle(); }

  // ---- BATTLE ----
  function startBattle() {
    const stageIdx = Math.min(state.stage - 1, STAGE_WAVES.length - 1);
    const waves = STAGE_WAVES[stageIdx];
    state.wave = 0;
    spawnWave(waves[0]);
    state.discard = [];
    state.drawPile = shuffle([...state.deck]);
    state.hand = [];
    state.shield = state.retainShield ? state.shield : 0;
    state.thorns = 0;
    state.empower = 1;
    state.retainShield = false;
    state.cardsPlayed = 0;

    // On battle start relics
    state.relics.forEach(r => { if (r.onBattleStart) r.onBattleStart(state); });

    // Permanent shield upgrade
    const shieldUpg = Save.getUpgradeLevel('start_shield');
    if (shieldUpg > 0 && state.shield < shieldUpg * 5) state.shield = shieldUpg * 5;

    showScreen('battleScreen');
    renderBattle();
    startPlayerTurn();
  }

  function spawnWave(templateIds) {
    const stageScale = 1 + (state.stage - 1) * 0.15;
    state.enemies = templateIds.map((id, i) => {
      const t = {...ENEMY_TEMPLATES[id]};
      return {
        ...t,
        hp: Math.ceil(t.hp * stageScale),
        maxHP: Math.ceil(t.hp * stageScale),
        atk: Math.ceil(t.atk * stageScale),
        baseAtk: Math.ceil(t.atk * stageScale),
        weak: 0, poison: 0, frozen: 0,
        idx: i, templateId: id
      };
    });
    state.target = 0;
    if (state.enemies.some(e => e.boss)) Audio.boss();
  }

  function startPlayerTurn() {
    state.phase = 'player';
    state.mana = state.maxMana;
    state.strength = 0;
    state.empower = 1;
    if (!state.retainShield) state.shield = 0;
    state.retainShield = false;
    state.thorns = 0;
    drawCards(state.baseDraw);
    renderBattle();
  }

  function drawCards(n) {
    for (let i = 0; i < n; i++) {
      if (state.drawPile.length === 0) {
        if (state.discard.length === 0) break;
        state.drawPile = shuffle([...state.discard]);
        state.discard = [];
      }
      const card = state.drawPile.pop();
      if (card) { state.hand.push(card); Audio.cardDraw(); }
    }
  }

  function renderBattle() {
    // Stage label
    $('stageLabel').textContent = `Stage ${state.stage}`;
    $('battleGold').textContent = state.gold;

    // Relics
    $('relicIcons').innerHTML = state.relics.map(r => `<span title="${r.name}">${r.emoji}</span>`).join('');

    // Player stats
    $('pHP').textContent = state.hp;
    $('pMaxHP').textContent = state.maxHP;
    $('pShield').textContent = state.shield;
    $('pMana').textContent = state.mana;
    $('pMaxMana').textContent = state.maxMana;
    $('hpBar').style.width = (state.hp / state.maxHP * 100) + '%';

    // Enemies
    const ea = $('enemyArea');
    ea.innerHTML = '';
    state.enemies.forEach((e, i) => {
      if (e.hp <= 0) return;
      const div = document.createElement('div');
      div.className = `enemy ${i === state.target ? 'targeted' : ''} ${e.boss ? 'boss' : ''}`;
      if (e.boss) div.style.minWidth = '120px';
      const intent = e.frozen > 0 ? 'â„ï¸ ë™ê²°' :
        e.weak > 0 ? `âš”ï¸ ${Math.max(1, e.atk - e.weak)} (-${e.weak})` :
        `âš”ï¸ ${e.atk}`;
      let statusText = '';
      if (e.poison > 0) statusText += `ğŸ§ª${e.poison} `;
      if (e.weak > 0) statusText += `ğŸ’«-${e.weak} `;
      if (e.frozen > 0) statusText += `â„ï¸${e.frozen} `;
      div.innerHTML = `
        <div class="enemy-emoji">${e.emoji}</div>
        <div class="enemy-name">${e.name}${e.boss?' ğŸ‘‘':''}</div>
        <div class="enemy-intent">${intent}</div>
        <div class="enemy-hp-bar"><div class="enemy-hp-fill" style="width:${e.hp/e.maxHP*100}%"></div></div>
        <div class="enemy-hp-text">${e.hp}/${e.maxHP}</div>
        ${statusText ? `<div class="enemy-status">${statusText}</div>` : ''}`;
      div.onclick = () => { state.target = i; renderBattle(); };
      ea.appendChild(div);
    });

    // Hand
    const ha = $('handArea');
    ha.innerHTML = '';
    state.hand.forEach((card, i) => {
      const canPlay = state.mana >= card.cost && state.phase === 'player';
      const el = document.createElement('div');
      el.className = `card type-${card.type} ${card.tier>0?'tier'+card.tier:''} ${canPlay?'':'disabled'}`;
      el.style.animationDelay = (i * 0.05) + 's';
      el.innerHTML = `
        <div class="card-cost">${card.cost}</div>
        <div class="card-emoji">${card.emoji}</div>
        <div class="card-name">${card.name}</div>
        <div class="card-desc">${card.desc}</div>
        ${card.tier > 0 ? `<div class="card-tier">${tierStars(card.tier)}</div>` : ''}`;
      if (canPlay) {
        el.onclick = () => playCard(i);
      }
      ha.appendChild(el);
    });

    // End turn button
    $('endTurnBtn').disabled = state.phase !== 'player';
  }

  // ---- PLAY CARD ----
  async function playCard(handIdx) {
    if (state.phase !== 'player' || animating) return;
    const card = state.hand[handIdx];
    if (!card || state.mana < card.cost) return;

    animating = true;
    state.mana -= card.cost;
    state.hand.splice(handIdx, 1);
    state.cardsPlayed++;
    Audio.cardPlay();

    // Visual: animate card
    const handEl = $('handArea');
    const cardEls = handEl.querySelectorAll('.card');
    if (cardEls[handIdx]) {
      cardEls[handIdx].classList.add('playing');
    }

    await sleep(150);

    // Apply card effect
    const def = CARD_DEFS.find(d => d.id === card.defId);
    if (def) {
      // Chaos orb check
      const chaos = state.relics.find(r => r.id === 'chaos_orb');
      if (chaos && Math.random() < chaos.chaosMiss) {
        // Miss!
        const rect = $('app').getBoundingClientRect();
        Particles.spawnText(rect.width/2, rect.height/2, 'MISS!', '#aaa');
      } else {
        def.fx(Game, card.tier);
      }
    }

    state.discard.push(card);
    state.empower = 1; // reset empower after use (if it wasn't the empower card itself)

    await sleep(200);
    animating = false;

    // Check if all enemies dead
    if (checkEnemiesDead()) return;

    renderBattle();
  }

  // ---- CARD EFFECT HELPERS ----
  function getEmpowerMult() {
    let mult = state.empower;
    const chaos = state.relics.find(r => r.id === 'chaos_orb');
    if (chaos) mult *= chaos.chaosMult;
    return mult;
  }

  function dealDamage(baseDmg, isMulti=false, piercing=false) {
    const target = state.enemies[state.target];
    if (!target || target.hp <= 0) {
      // Find next alive
      const alive = state.enemies.find(e => e.hp > 0);
      if (!alive) return;
      state.target = state.enemies.indexOf(alive);
      return dealDamage(baseDmg, isMulti, piercing);
    }
    let dmg = Math.ceil((baseDmg + state.baseAtk + state.strength) * getEmpowerMult());
    if (piercing) { /* ignore nothing special for now */ }
    target.hp -= dmg;
    Audio.attack();

    // Particles
    const enemyEls = $('enemyArea').children;
    const el = enemyEls[state.target];
    if (el) {
      const rect = el.getBoundingClientRect();
      Particles.spawn(rect.left + rect.width/2, rect.top + rect.height/2, 8, '#f85149', 4, 30);
      Particles.spawnText(rect.left + rect.width/2, rect.top, `-${dmg}`, '#f85149');
      el.classList.add('hit');
      setTimeout(() => el.classList.remove('hit'), 300);
    }

    if (target.hp <= 0) {
      enemyKilled(target);
    }
  }

  function dealDamageAll(baseDmg) {
    state.enemies.forEach((e, i) => {
      if (e.hp <= 0) return;
      const old = state.target;
      state.target = i;
      dealDamage(baseDmg, true);
      state.target = old;
    });
  }

  function applyWeak(amount) {
    const target = state.enemies[state.target];
    if (target && target.hp > 0) { target.weak += amount; Audio.debuff(); }
  }

  function applyWeakAll(amount) {
    state.enemies.forEach(e => { if (e.hp > 0) { e.weak += amount; } });
    Audio.debuff();
  }

  function applyPoison(amount) {
    const target = state.enemies[state.target];
    if (target && target.hp > 0) { target.poison += Math.ceil(amount * getEmpowerMult()); Audio.poison(); }
  }

  function gainShield(amount) {
    state.shield += Math.ceil(amount * getEmpowerMult());
    Audio.shield();
    // Particles
    const rect = $('app').getBoundingClientRect();
    Particles.spawn(rect.width/2, rect.height - 150, 6, '#79c0ff', 3, 25);
  }

  function healPlayer(amount) {
    const actual = Math.min(Math.ceil(amount * getEmpowerMult()), state.maxHP - state.hp);
    state.hp += actual;
    Audio.heal();
    const rect = $('app').getBoundingClientRect();
    Particles.spawn(rect.width/2, rect.height - 150, 8, '#3fb950', 3, 30);
    Particles.spawnText(rect.width/2, rect.height - 180, `+${actual}`, '#3fb950');
  }

  function gainMana(amount) {
    state.mana = Math.min(state.mana + amount, state.maxMana + 3);
    Audio.buff();
  }

  function gainStrength(amount) {
    state.strength += Math.ceil(amount * getEmpowerMult());
    Audio.buff();
  }

  function gainThorns(amount) {
    state.thorns += Math.ceil(amount * getEmpowerMult());
  }

  function loseHP(amount) {
    state.hp -= amount;
    if (state.hp <= 0) state.hp = 1; // sacrifice shouldn't kill
  }

  function enemyKilled(enemy) {
    Audio.enemyDie();
    const el = $('enemyArea').children[state.enemies.indexOf(enemy)];
    if (el) {
      const rect = el.getBoundingClientRect();
      Particles.spawn(rect.left + rect.width/2, rect.top + rect.height/2, 20, '#d29922', 5, 40);
    }
    state.killsThisRun++;
    Save.data.totalKills++;
    let goldEarned = Math.ceil(enemy.gold * state.goldMult);
    const luckyRelic = state.relics.find(r => r.goldMult);
    if (luckyRelic) goldEarned = Math.ceil(goldEarned * luckyRelic.goldMult);
    state.gold += goldEarned;
    Audio.coin();

    // Vampire fang relic
    state.relics.forEach(r => { if (r.onKill) r.onKill(state); });
  }

  function checkEnemiesDead() {
    if (state.enemies.every(e => e.hp <= 0)) {
      // Wave complete - check for more waves
      const stageIdx = Math.min(state.stage - 1, STAGE_WAVES.length - 1);
      const waves = STAGE_WAVES[stageIdx];
      state.wave++;
      if (state.wave < waves.length) {
        // Next wave
        setTimeout(() => {
          spawnWave(waves[state.wave]);
          state.target = 0;
          renderBattle();
        }, 500);
        return true;
      }
      // Stage complete!
      setTimeout(() => stageComplete(), 500);
      return true;
    }
    // Auto-target next alive enemy
    if (state.enemies[state.target] && state.enemies[state.target].hp <= 0) {
      const alive = state.enemies.findIndex(e => e.hp > 0);
      if (alive >= 0) state.target = alive;
    }
    return false;
  }

  // ---- ENEMY TURN ----
  async function endTurn() {
    if (state.phase !== 'player' || animating) return;
    state.phase = 'enemy';
    animating = true;
    $('endTurnBtn').disabled = true;

    // Discard hand
    state.discard.push(...state.hand);
    state.hand = [];

    await sleep(300);

    // Enemy actions
    for (let i = 0; i < state.enemies.length; i++) {
      const e = state.enemies[i];
      if (e.hp <= 0) continue;

      // Poison tick
      if (e.poison > 0) {
        e.hp -= e.poison;
        Audio.poison();
        const el = $('enemyArea').children[i];
        if (el) {
          const rect = el.getBoundingClientRect();
          Particles.spawn(rect.left + rect.width/2, rect.top + rect.height/2, 5, '#3fb950', 2, 20);
          Particles.spawnText(rect.left + rect.width/2, rect.top, `-${e.poison}ğŸ§ª`, '#3fb950');
        }
        e.poison = Math.max(0, e.poison - 1);
        await sleep(200);
        if (e.hp <= 0) {
          enemyKilled(e);
          if (checkEnemiesDead()) { animating = false; return; }
          renderBattle();
          continue;
        }
      }

      // Frozen check
      if (e.frozen > 0) {
        e.frozen--;
        await sleep(200);
        continue;
      }

      // Attack
      let atkDmg = Math.max(1, e.atk - (e.weak > 0 ? e.weak : 0));

      // Frost amulet relic
      const frostRelic = state.relics.find(r => r.freezeChance);
      if (frostRelic && Math.random() < frostRelic.freezeChance) {
        e.frozen += 1;
        const el = $('enemyArea').children[i];
        if (el) {
          const rect = el.getBoundingClientRect();
          Particles.spawnText(rect.left + rect.width/2, rect.top, 'â„ï¸ FROZEN', '#79c0ff');
        }
        await sleep(300);
        continue;
      }

      // Apply damage to player
      let remaining = atkDmg;
      if (state.shield > 0) {
        const blocked = Math.min(state.shield, remaining);
        state.shield -= blocked;
        remaining -= blocked;
      }
      if (remaining > 0) {
        state.hp -= remaining;
        Audio.playerHit();
        // Screen shake
        $('battleScreen').classList.add('shake');
        setTimeout(() => $('battleScreen').classList.remove('shake'), 300);
        // Particles
        const rect = $('app').getBoundingClientRect();
        Particles.spawn(rect.width/2, rect.height - 100, 10, '#f85149', 4, 30);
        Particles.spawnText(rect.width/2, rect.height - 160, `-${remaining}`, '#f85149');
      }

      // Thorns & thorn ring
      if (state.thorns > 0) {
        e.hp -= state.thorns;
      }
      state.relics.forEach(r => { if (r.onHit) r.onHit(state, e); });

      // Vampire enemy lifesteal
      if (e.lifesteal) {
        e.hp = Math.min(e.maxHP, e.hp + Math.ceil(atkDmg * 0.3));
      }

      // Weak decay
      if (e.weak > 0) e.weak = Math.max(0, e.weak - 1);

      if (e.hp <= 0) {
        enemyKilled(e);
        if (checkEnemiesDead()) { animating = false; return; }
      }

      renderBattle();
      await sleep(400);

      // Check player death
      if (state.hp <= 0) {
        // Phoenix feather?
        const phoenix = state.relics.find(r => r.revive && !state.revived);
        if (phoenix) {
          state.revived = true;
          state.hp = Math.ceil(state.maxHP * 0.3);
          Audio.heal();
          const rect = $('app').getBoundingClientRect();
          Particles.spawn(rect.width/2, rect.height/2, 30, '#f0883e', 6, 50, 5);
          Particles.spawnText(rect.width/2, rect.height/2, 'ğŸ”¥ ë¶€í™œ!', '#f0883e');
          renderBattle();
          await sleep(500);
        } else {
          animating = false;
          gameOver(false);
          return;
        }
      }
    }

    animating = false;
    state.turnsTotal++;

    // Check enemies dead from poison/thorns
    if (checkEnemiesDead()) return;

    // Start next player turn
    startPlayerTurn();
  }

  // ---- STAGE COMPLETE ----
  function stageComplete() {
    Audio.victory();
    if (state.stage > Save.data.bestStage) {
      Save.data.bestStage = state.stage;
    }

    // Stage heal
    if (state.stageHeal > 0) {
      state.hp = Math.min(state.maxHP, state.hp + state.stageHeal);
    }

    // Check if final stage
    if (state.stage >= 10) {
      gameOver(true);
      return;
    }

    state.stage++;

    // Show relic pick
    showRelicPick();
  }

  // ---- RELIC PICK ----
  function showRelicPick() {
    const container = $('relicCards');
    container.innerHTML = '';
    const available = RELIC_DEFS.filter(r => !state.relics.some(sr => sr.id === r.id));
    const offers = shuffle(available).slice(0, 3);
    if (offers.length === 0) { showFusion(); return; }
    offers.forEach(relic => {
      const el = document.createElement('div');
      el.className = 'relic-card';
      el.innerHTML = `
        <div class="emoji">${relic.emoji}</div>
        <div class="name">${relic.name}</div>
        <div class="desc">${relic.desc}</div>`;
      el.onclick = () => {
        Audio.relic();
        applyRelic(relic);
        showFusion();
      };
      container.appendChild(el);
    });
    showScreen('relicScreen');
  }

  function skipRelic() { Audio.click(); showFusion(); }

  // ---- FUSION ----
  function showFusion() {
    const container = $('fusionDeck');
    container.innerHTML = '';

    // Group cards by defId and tier
    const groups = {};
    state.deck.forEach(card => {
      const key = card.defId + '_' + card.tier;
      if (!groups[key]) groups[key] = { card, count: 0, cards: [] };
      groups[key].count++;
      groups[key].cards.push(card);
    });

    Object.entries(groups).forEach(([key, group]) => {
      const canFuse = group.count >= 3 && group.card.tier < 2;
      const el = document.createElement('div');
      el.className = `fusion-card ${canFuse ? 'fusable' : ''}`;
      el.innerHTML = `
        <div class="emoji">${group.card.emoji}</div>
        <div class="name">${group.card.name}</div>
        <div class="count">Ã—${group.count} ${canFuse ? 'â†’ í•©ì„±!' : ''}</div>`;
      if (canFuse) {
        el.onclick = () => {
          Audio.fusion();
          // Remove 3 cards, add 1 upgraded
          let removed = 0;
          state.deck = state.deck.filter(c => {
            if (removed >= 3) return true;
            if (c.defId === group.card.defId && c.tier === group.card.tier) {
              removed++;
              return false;
            }
            return true;
          });
          const newCard = makeCard(group.card.defId, group.card.tier + 1);
          state.deck.push(newCard);
          Save.unlockCard(newCard.defId + '_' + newCard.tier);
          Save.save();

          // Particle
          const rect = el.getBoundingClientRect();
          Particles.spawn(rect.left + rect.width/2, rect.top + rect.height/2, 20, '#bc8cff', 5, 40, 4);

          showFusion();
        };
      }
      container.appendChild(el);
    });

    showScreen('fusionScreen');
  }

  function continueBattle() {
    Audio.click();
    showDraft();
  }

  // ---- DECK VIEW ----
  function showDeckView() {
    const container = $('deckCards');
    container.innerHTML = '';
    $('deckCount').textContent = state.deck.length;
    state.deck.forEach(card => {
      const el = document.createElement('div');
      el.className = `card type-${card.type} ${card.tier>0?'tier'+card.tier:''}`;
      el.innerHTML = `
        <div class="card-cost">${card.cost}</div>
        <div class="card-emoji">${card.emoji}</div>
        <div class="card-name">${card.name}</div>
        <div class="card-desc">${card.desc}</div>
        ${card.tier > 0 ? `<div class="card-tier">${tierStars(card.tier)}</div>` : ''}`;
      container.appendChild(el);
    });
    showScreen('deckScreen');
  }

  function closeDeckView() { Audio.click(); showScreen('battleScreen'); }

  // ---- GAME OVER ----
  function gameOver(victory) {
    if (victory) {
      Audio.victory();
      Particles.spawn(window.innerWidth/2, window.innerHeight/2, 50, '#d29922', 8, 60, 5);
    } else {
      Audio.gameOver();
    }

    // Give gold
    const earnedGold = state.gold;
    Save.data.gold += earnedGold;
    Save.data.totalRuns++;
    Save.save();

    $('goTitle').textContent = victory ? 'ğŸ† ë˜ì „ ì •ë³µ!' : 'ğŸ’€ Game Over';
    $('goTitle').style.color = victory ? 'var(--gold)' : 'var(--red)';
    $('goStats').innerHTML = `
      ë„ë‹¬ ìŠ¤í…Œì´ì§€: <span>${state.stage}</span><br>
      ì²˜ì¹˜í•œ ì : <span>${state.killsThisRun}</span><br>
      ì‚¬ìš©í•œ ì¹´ë“œ: <span>${state.cardsPlayed}</span><br>
      í”Œë ˆì´ í„´: <span>${state.turnsTotal}</span><br>
      ë³´ìœ  ìœ ë¬¼: <span>${state.relics.length}</span><br>
      ì´ ëŸ° íšŸìˆ˜: <span>${Save.data.totalRuns}</span>`;
    $('goGold').textContent = `ğŸ’° ${earnedGold} ê³¨ë“œ íšë“!`;
    showScreen('gameOverScreen');
  }

  // Public API
  return {
    state,
    showTitle, showShop, showCollection,
    startRun, skipDraft,
    endTurn, playCard,
    showDeckView, closeDeckView,
    skipRelic, continueBattle,
    // Card effect helpers (called from card definitions)
    dealDamage, dealDamageAll,
    applyWeak, applyWeakAll, applyPoison,
    gainShield, healPlayer, gainMana, gainStrength, gainThorns,
    loseHP, drawCards,
    get state() { return state; },
  };
})();

// ---- INIT ----
Save.load();
Game.showTitle();

// Prevent zoom on double-tap
document.addEventListener('touchstart', e => {
  if (e.touches.length > 1) e.preventDefault();
}, { passive: false });
let lastTouchEnd = 0;
document.addEventListener('touchend', e => {
  const now = Date.now();
  if (now - lastTouchEnd <= 300) e.preventDefault();
  lastTouchEnd = now;
}, false);

// Init audio context on first interaction
document.addEventListener('touchstart', () => { try { Audio.click(); } catch(e) {} }, { once: true });
document.addEventListener('click', () => { try { Audio.click(); } catch(e) {} }, { once: true });
</script>
</body>
</html>
