<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>üîÆ Spell Surge - ÎßàÎ≤ï ÏÑúÎ∞îÏù¥Î≤å</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        body {
            font-family: 'Arial', sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
            touch-action: none;
        }
        #gameCanvas {
            display: block;
            margin: 0 auto;
            background: #0a0a14;
            box-shadow: 0 0 50px rgba(138, 43, 226, 0.8);
        }
        .hud {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            pointer-events: none;
            z-index: 10;
        }
        .hp-bar {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #ff4444;
            border-radius: 10px;
            height: 30px;
            margin-bottom: 10px;
            overflow: hidden;
            position: relative;
        }
        .hp-fill {
            background: linear-gradient(90deg, #ff4444 0%, #ff8888 100%);
            height: 100%;
            transition: width 0.3s;
        }
        .hp-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-weight: bold;
            text-shadow: 0 0 5px #000;
        }
        .stats {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }
        .stat-item {
            background: rgba(0, 0, 0, 0.8);
            padding: 5px 12px;
            border-radius: 5px;
            border: 2px solid #8a2be2;
            font-size: 14px;
        }
        .exp-bar {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #4af;
            border-radius: 10px;
            height: 20px;
            overflow: hidden;
        }
        .exp-fill {
            background: linear-gradient(90deg, #4af 0%, #88f 100%);
            height: 100%;
            transition: width 0.3s;
        }
        .joystick {
            position: absolute;
            bottom: 50px;
            left: 50px;
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            pointer-events: auto;
            z-index: 10;
        }
        .joystick-handle {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 50px;
            height: 50px;
            background: rgba(138, 43, 226, 0.7);
            border: 3px solid #8a2be2;
            border-radius: 50%;
            transition: all 0.1s;
        }
        #levelUpModal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 3px solid #ffd700;
            border-radius: 15px;
            padding: 20px;
            display: none;
            z-index: 100;
            max-width: 400px;
            box-shadow: 0 0 50px rgba(255, 215, 0, 0.5);
        }
        .modal-title {
            text-align: center;
            font-size: 24px;
            color: #ffd700;
            margin-bottom: 15px;
            text-shadow: 0 0 10px #ffd700;
        }
        .spell-choice {
            background: rgba(138, 43, 226, 0.2);
            border: 2px solid #8a2be2;
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
            cursor: pointer;
            transition: all 0.2s;
        }
        .spell-choice:hover {
            background: rgba(138, 43, 226, 0.4);
            transform: scale(1.05);
        }
        .spell-name {
            font-size: 18px;
            font-weight: bold;
            color: #4af;
            margin-bottom: 5px;
        }
        .spell-desc {
            font-size: 14px;
            color: #ccc;
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 3px solid #ff4444;
            border-radius: 15px;
            padding: 30px;
            display: none;
            z-index: 100;
            text-align: center;
            min-width: 300px;
        }
        .game-over-title {
            font-size: 32px;
            color: #ff4444;
            margin-bottom: 20px;
        }
        .game-over-stats {
            font-size: 18px;
            margin: 10px 0;
        }
        #restartBtn {
            padding: 12px 30px;
            font-size: 18px;
            font-weight: bold;
            background: linear-gradient(135deg, #8a2be2 0%, #4b0082 100%);
            color: #fff;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            margin-top: 20px;
        }
        #upgradeMenu {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #ffd700;
            border-radius: 10px;
            padding: 15px;
            pointer-events: auto;
            z-index: 10;
            max-width: 200px;
        }
        .upgrade-title {
            color: #ffd700;
            font-weight: bold;
            margin-bottom: 10px;
            text-align: center;
        }
        .upgrade-btn {
            width: 100%;
            padding: 8px;
            margin: 5px 0;
            background: rgba(138, 43, 226, 0.5);
            border: 1px solid #8a2be2;
            border-radius: 5px;
            color: #fff;
            font-size: 12px;
            cursor: pointer;
        }
        .upgrade-btn:active {
            transform: scale(0.95);
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div class="hud">
        <div class="hp-bar">
            <div class="hp-fill" id="hpFill"></div>
            <div class="hp-text" id="hpText">100 / 100</div>
        </div>
        <div class="stats">
            <div class="stat-item">‚öîÔ∏è Lv.<span id="levelDisplay">1</span></div>
            <div class="stat-item">üíÄ Wave: <span id="waveDisplay">1</span></div>
            <div class="stat-item">üí∞ <span id="coinsDisplay">0</span></div>
            <div class="stat-item">‚è±Ô∏è <span id="timeDisplay">0:00</span></div>
        </div>
        <div class="exp-bar">
            <div class="exp-fill" id="expFill"></div>
        </div>
    </div>
    
    <div class="joystick" id="joystick">
        <div class="joystick-handle" id="joystickHandle"></div>
    </div>
    
    <div id="upgradeMenu">
        <div class="upgrade-title">üíé ÏòÅÍµ¨ Í∞ïÌôî</div>
        <button class="upgrade-btn" id="upgradeDamage">‚öîÔ∏è Í≥µÍ≤©Î†• +10% (100üí∞)</button>
        <button class="upgrade-btn" id="upgradeHP">‚ù§Ô∏è ÏµúÎåÄHP +20 (150üí∞)</button>
        <button class="upgrade-btn" id="upgradeSpeed">üèÉ Ïù¥ÎèôÏÜçÎèÑ +5% (120üí∞)</button>
    </div>
    
    <div id="levelUpModal">
        <div class="modal-title">‚¨ÜÔ∏è LEVEL UP!</div>
        <div id="spellChoices"></div>
    </div>
    
    <div id="gameOver">
        <div class="game-over-title">üíÄ GAME OVER</div>
        <div class="game-over-stats">
            <div>‚è±Ô∏è ÏÉùÏ°¥ÏãúÍ∞Ñ: <span id="finalTime">0:00</span></div>
            <div>üíÄ Wave: <span id="finalWave">1</span></div>
            <div>üí∞ ÌöçÎìù ÏΩîÏù∏: <span id="earnedCoins">0</span></div>
        </div>
        <button id="restartBtn">üîÑ Îã§Ïãú ÏãúÏûë</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Responsive canvas
        function resizeCanvas() {
            const dpr = window.devicePixelRatio || 1;
            canvas.width = Math.min(800, window.innerWidth) * dpr;
            canvas.height = Math.min(600, window.innerHeight) * dpr;
            canvas.style.width = Math.min(800, window.innerWidth) + 'px';
            canvas.style.height = Math.min(600, window.innerHeight) + 'px';
            ctx.scale(dpr, dpr);
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Audio
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        function playSound(type) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            
            switch(type) {
                case 'shoot':
                    osc.frequency.value = 800;
                    osc.type = 'sine';
                    gain.gain.setValueAtTime(0.05, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                    osc.start();
                    osc.stop(audioCtx.currentTime + 0.1);
                    break;
                case 'hit':
                    osc.frequency.value = 150;
                    osc.type = 'sawtooth';
                    gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
                    osc.start();
                    osc.stop(audioCtx.currentTime + 0.15);
                    break;
                case 'levelup':
                    osc.frequency.value = 1000;
                    gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(1500, audioCtx.currentTime + 0.4);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);
                    osc.start();
                    osc.stop(audioCtx.currentTime + 0.5);
                    break;
                case 'damage':
                    osc.frequency.value = 100;
                    osc.type = 'square';
                    gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
                    osc.start();
                    osc.stop(audioCtx.currentTime + 0.2);
                    break;
                case 'coin':
                    osc.frequency.value = 1200;
                    gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
                    osc.start();
                    osc.stop(audioCtx.currentTime + 0.15);
                    break;
            }
        }

        // Spell definitions
        const spellLibrary = {
            fireball: {
                name: 'üî• ÌôîÏóºÍµ¨',
                desc: 'Ï†ÑÎ∞©ÏúºÎ°ú ÌôîÏóºÍµ¨ Î∞úÏÇ¨',
                maxLevel: 5,
                damage: 10,
                cooldown: 500,
                projectileSpeed: 5
            },
            lightning: {
                name: '‚ö° Î≤àÍ∞ú',
                desc: 'Í∞ÄÏû• Í∞ÄÍπåÏö¥ Ï†ÅÏóêÍ≤å Î≤àÍ∞ú ÎÇôÌïò',
                maxLevel: 5,
                damage: 25,
                cooldown: 1500,
                range: 300
            },
            icewall: {
                name: '‚ùÑÔ∏è ÏñºÏùåÎ≤Ω',
                desc: 'Ï£ºÎ≥ÄÏóê ÏñºÏùåÎ≤Ω ÏÉùÏÑ±',
                maxLevel: 3,
                damage: 5,
                cooldown: 3000,
                duration: 2000
            },
            poison: {
                name: '‚ò†Ô∏è ÎèÖÏïàÍ∞ú',
                desc: 'Ï£ºÎ≥ÄÏóê ÏßÄÏÜç Îç∞ÎØ∏ÏßÄ',
                maxLevel: 5,
                damage: 3,
                cooldown: 100,
                radius: 80
            },
            tornado: {
                name: 'üå™Ô∏è ÌöåÏò§Î¶¨',
                desc: 'ÌöåÏ†ÑÌïòÎ©∞ Ï†Å Í≥µÍ≤©',
                maxLevel: 4,
                damage: 8,
                cooldown: 800,
                radius: 60
            },
            meteor: {
                name: '‚òÑÔ∏è Ïö¥ÏÑù',
                desc: 'ÎûúÎç§ ÏúÑÏπòÏóê Ïö¥ÏÑù ÎÇôÌïò',
                maxLevel: 3,
                damage: 50,
                cooldown: 4000,
                radius: 80
            },
            shield: {
                name: 'üõ°Ô∏è Î≥¥Ìò∏Îßâ',
                desc: 'ÌîºÌï¥ Í∞êÏÜå +20%',
                maxLevel: 3,
                passive: true
            },
            haste: {
                name: 'üí® Ïã†ÏÜç',
                desc: 'Ïù¥ÎèôÏÜçÎèÑ +15%',
                maxLevel: 3,
                passive: true
            },
            multishot: {
                name: 'üéØ Îã§Ï§ë Î∞úÏÇ¨',
                desc: 'ÌôîÏóºÍµ¨ Í∞úÏàò +2',
                maxLevel: 3,
                passive: true
            },
            vampire: {
                name: 'ü©∏ Ìù°Ìòà',
                desc: 'ÌîºÌï¥Ïùò 5%ÎßåÌÅº HP ÌöåÎ≥µ',
                maxLevel: 3,
                passive: true
            }
        };

        // Game state
        let gameState = {
            player: {
                x: 400,
                y: 300,
                hp: 100,
                maxHp: 100,
                speed: 3,
                level: 1,
                exp: 0,
                expToNext: 100
            },
            coins: 0,
            totalCoins: 0,
            wave: 1,
            time: 0,
            enemies: [],
            projectiles: [],
            particles: [],
            spells: {},
            spellCooldowns: {},
            joystick: { active: false, x: 0, y: 0 },
            isPaused: false,
            gameOver: false,
            permanentUpgrades: {
                damage: 1,
                maxHp: 1,
                speed: 1
            }
        };

        // Load permanent upgrades
        function loadUpgrades() {
            const saved = localStorage.getItem('spellSurgeUpgrades');
            if (saved) {
                gameState.permanentUpgrades = JSON.parse(saved);
                gameState.player.maxHp = 100 * gameState.permanentUpgrades.maxHp;
                gameState.player.hp = gameState.player.maxHp;
                gameState.player.speed = 3 * gameState.permanentUpgrades.speed;
            }
            const savedCoins = localStorage.getItem('spellSurgeCoins');
            if (savedCoins) {
                gameState.coins = parseInt(savedCoins);
            }
        }

        function saveUpgrades() {
            localStorage.setItem('spellSurgeUpgrades', JSON.stringify(gameState.permanentUpgrades));
            localStorage.setItem('spellSurgeCoins', gameState.coins.toString());
        }

        // Upgrade buttons
        document.getElementById('upgradeDamage').addEventListener('click', () => {
            if (gameState.coins >= 100) {
                gameState.coins -= 100;
                gameState.permanentUpgrades.damage *= 1.1;
                saveUpgrades();
                playSound('levelup');
            }
        });

        document.getElementById('upgradeHP').addEventListener('click', () => {
            if (gameState.coins >= 150) {
                gameState.coins -= 150;
                gameState.permanentUpgrades.maxHp += 0.2;
                gameState.player.maxHp = 100 * gameState.permanentUpgrades.maxHp;
                gameState.player.hp = gameState.player.maxHp;
                saveUpgrades();
                playSound('levelup');
            }
        });

        document.getElementById('upgradeSpeed').addEventListener('click', () => {
            if (gameState.coins >= 120) {
                gameState.coins -= 120;
                gameState.permanentUpgrades.speed *= 1.05;
                gameState.player.speed = 3 * gameState.permanentUpgrades.speed;
                saveUpgrades();
                playSound('levelup');
            }
        });

        // Joystick
        const joystick = document.getElementById('joystick');
        const joystickHandle = document.getElementById('joystickHandle');
        
        joystick.addEventListener('touchstart', handleJoystickStart);
        joystick.addEventListener('touchmove', handleJoystickMove);
        joystick.addEventListener('touchend', handleJoystickEnd);
        joystick.addEventListener('mousedown', handleJoystickStart);
        document.addEventListener('mousemove', handleJoystickMove);
        document.addEventListener('mouseup', handleJoystickEnd);

        function handleJoystickStart(e) {
            e.preventDefault();
            gameState.joystick.active = true;
        }

        function handleJoystickMove(e) {
            if (!gameState.joystick.active) return;
            e.preventDefault();
            
            const rect = joystick.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            
            let dx = clientX - centerX;
            let dy = clientY - centerY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const maxDistance = 35;
            
            if (distance > maxDistance) {
                dx = (dx / distance) * maxDistance;
                dy = (dy / distance) * maxDistance;
            }
            
            gameState.joystick.x = dx / maxDistance;
            gameState.joystick.y = dy / maxDistance;
            
            joystickHandle.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
        }

        function handleJoystickEnd(e) {
            gameState.joystick.active = false;
            gameState.joystick.x = 0;
            gameState.joystick.y = 0;
            joystickHandle.style.transform = 'translate(-50%, -50%)';
        }

        // Enemies
        function spawnEnemy() {
            const side = Math.floor(Math.random() * 4);
            const w = canvas.width / (window.devicePixelRatio || 1);
            const h = canvas.height / (window.devicePixelRatio || 1);
            let x, y;
            
            switch(side) {
                case 0: x = Math.random() * w; y = -20; break;
                case 1: x = w + 20; y = Math.random() * h; break;
                case 2: x = Math.random() * w; y = h + 20; break;
                case 3: x = -20; y = Math.random() * h; break;
            }
            
            const isBoss = gameState.wave % 5 === 0 && Math.random() < 0.2;
            
            gameState.enemies.push({
                x, y,
                hp: isBoss ? 50 + gameState.wave * 10 : 10 + gameState.wave * 2,
                maxHp: isBoss ? 50 + gameState.wave * 10 : 10 + gameState.wave * 2,
                speed: isBoss ? 0.8 : 1 + gameState.wave * 0.05,
                damage: isBoss ? 20 : 5 + gameState.wave,
                size: isBoss ? 25 : 15,
                isBoss,
                color: isBoss ? '#ff00ff' : '#ff4444'
            });
        }

        function updateEnemies(deltaTime) {
            // Spawn enemies
            if (Math.random() < 0.02 + gameState.wave * 0.005) {
                spawnEnemy();
            }
            
            // Move enemies toward player
            gameState.enemies.forEach(enemy => {
                const dx = gameState.player.x - enemy.x;
                const dy = gameState.player.y - enemy.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > 0) {
                    enemy.x += (dx / dist) * enemy.speed;
                    enemy.y += (dy / dist) * enemy.speed;
                }
                
                // Collision with player
                if (dist < 30) {
                    const shieldReduction = gameState.spells.shield ? 0.8 : 1;
                    gameState.player.hp -= enemy.damage * shieldReduction * (deltaTime / 1000);
                    playSound('damage');
                    
                    if (gameState.player.hp <= 0) {
                        endGame();
                    }
                }
            });
            
            // Remove dead enemies
            gameState.enemies = gameState.enemies.filter(e => e.hp > 0);
        }

        // Spells
        function updateSpells(deltaTime) {
            Object.keys(gameState.spells).forEach(spellKey => {
                const spell = spellLibrary[spellKey];
                if (spell.passive) return;
                
                if (!gameState.spellCooldowns[spellKey]) {
                    gameState.spellCooldowns[spellKey] = 0;
                }
                
                gameState.spellCooldowns[spellKey] -= deltaTime;
                
                if (gameState.spellCooldowns[spellKey] <= 0) {
                    castSpell(spellKey);
                    gameState.spellCooldowns[spellKey] = spell.cooldown;
                }
            });
        }

        function castSpell(spellKey) {
            const spell = spellLibrary[spellKey];
            const level = gameState.spells[spellKey];
            
            switch(spellKey) {
                case 'fireball':
                    const shotCount = gameState.spells.multishot ? 3 + gameState.spells.multishot * 2 : 1;
                    for (let i = 0; i < shotCount; i++) {
                        const angle = (Math.PI * 2 / shotCount) * i + gameState.time / 1000;
                        gameState.projectiles.push({
                            x: gameState.player.x,
                            y: gameState.player.y,
                            vx: Math.cos(angle) * spell.projectileSpeed,
                            vy: Math.sin(angle) * spell.projectileSpeed,
                            damage: spell.damage * level * gameState.permanentUpgrades.damage,
                            size: 8,
                            color: '#ff6600',
                            type: 'fireball'
                        });
                    }
                    playSound('shoot');
                    break;
                    
                case 'lightning':
                    const closest = gameState.enemies.sort((a, b) => {
                        const distA = Math.hypot(a.x - gameState.player.x, a.y - gameState.player.y);
                        const distB = Math.hypot(b.x - gameState.player.x, b.y - gameState.player.y);
                        return distA - distB;
                    })[0];
                    
                    if (closest) {
                        const dist = Math.hypot(closest.x - gameState.player.x, closest.y - gameState.player.y);
                        if (dist < spell.range) {
                            closest.hp -= spell.damage * level * gameState.permanentUpgrades.damage;
                            createParticles(closest.x, closest.y, '#ffff00', 15);
                            playSound('hit');
                            
                            // Vampire healing
                            if (gameState.spells.vampire) {
                                gameState.player.hp = Math.min(gameState.player.maxHp, 
                                    gameState.player.hp + spell.damage * level * 0.05 * gameState.spells.vampire);
                            }
                            
                            if (closest.hp <= 0) {
                                dropCoin(closest.x, closest.y);
                            }
                        }
                    }
                    break;
                    
                case 'poison':
                    gameState.enemies.forEach(enemy => {
                        const dist = Math.hypot(enemy.x - gameState.player.x, enemy.y - gameState.player.y);
                        if (dist < spell.radius) {
                            enemy.hp -= spell.damage * level * gameState.permanentUpgrades.damage * 0.1;
                            if (enemy.hp <= 0) {
                                dropCoin(enemy.x, enemy.y);
                            }
                        }
                    });
                    break;
                    
                case 'tornado':
                    const tornadoAngle = gameState.time / 100;
                    const tornadoX = gameState.player.x + Math.cos(tornadoAngle) * 100;
                    const tornadoY = gameState.player.y + Math.sin(tornadoAngle) * 100;
                    
                    gameState.enemies.forEach(enemy => {
                        const dist = Math.hypot(enemy.x - tornadoX, enemy.y - tornadoY);
                        if (dist < spell.radius) {
                            enemy.hp -= spell.damage * level * gameState.permanentUpgrades.damage;
                            createParticles(enemy.x, enemy.y, '#88ccff', 5);
                            if (enemy.hp <= 0) {
                                dropCoin(enemy.x, enemy.y);
                            }
                        }
                    });
                    playSound('shoot');
                    break;
                    
                case 'meteor':
                    const w = canvas.width / (window.devicePixelRatio || 1);
                    const h = canvas.height / (window.devicePixelRatio || 1);
                    const mx = Math.random() * w;
                    const my = Math.random() * h;
                    
                    gameState.enemies.forEach(enemy => {
                        const dist = Math.hypot(enemy.x - mx, enemy.y - my);
                        if (dist < spell.radius) {
                            enemy.hp -= spell.damage * level * gameState.permanentUpgrades.damage;
                            if (enemy.hp <= 0) {
                                dropCoin(enemy.x, enemy.y);
                            }
                        }
                    });
                    
                    createParticles(mx, my, '#ff6600', 30);
                    playSound('hit');
                    break;
            }
        }

        function updateProjectiles(deltaTime) {
            gameState.projectiles.forEach(proj => {
                proj.x += proj.vx;
                proj.y += proj.vy;
                
                // Check collision with enemies
                gameState.enemies.forEach(enemy => {
                    const dist = Math.hypot(enemy.x - proj.x, enemy.y - proj.y);
                    if (dist < enemy.size + proj.size) {
                        enemy.hp -= proj.damage;
                        proj.hit = true;
                        createParticles(proj.x, proj.y, proj.color, 8);
                        playSound('hit');
                        
                        // Vampire healing
                        if (gameState.spells.vampire) {
                            gameState.player.hp = Math.min(gameState.player.maxHp, 
                                gameState.player.hp + proj.damage * 0.05 * gameState.spells.vampire);
                        }
                        
                        if (enemy.hp <= 0) {
                            dropCoin(enemy.x, enemy.y);
                        }
                    }
                });
            });
            
            const w = canvas.width / (window.devicePixelRatio || 1);
            const h = canvas.height / (window.devicePixelRatio || 1);
            gameState.projectiles = gameState.projectiles.filter(p => 
                !p.hit && p.x > -50 && p.x < w + 50 && p.y > -50 && p.y < h + 50
            );
        }

        function dropCoin(x, y) {
            gameState.projectiles.push({
                x, y,
                vx: 0, vy: 0,
                size: 8,
                color: '#ffd700',
                type: 'coin',
                magnetSpeed: 0
            });
            createParticles(x, y, '#ffd700', 10);
        }

        function updateCoins(deltaTime) {
            gameState.projectiles.filter(p => p.type === 'coin').forEach(coin => {
                const dx = gameState.player.x - coin.x;
                const dy = gameState.player.y - coin.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < 150) {
                    coin.magnetSpeed = 5;
                }
                
                if (coin.magnetSpeed > 0) {
                    coin.x += (dx / dist) * coin.magnetSpeed;
                    coin.y += (dy / dist) * coin.magnetSpeed;
                }
                
                if (dist < 20) {
                    gameState.coins++;
                    gameState.totalCoins++;
                    addExp(10);
                    coin.collected = true;
                    playSound('coin');
                }
            });
            
            gameState.projectiles = gameState.projectiles.filter(p => !p.collected);
        }

        function addExp(amount) {
            gameState.player.exp += amount;
            if (gameState.player.exp >= gameState.player.expToNext) {
                levelUp();
            }
        }

        function levelUp() {
            gameState.player.level++;
            gameState.player.exp = 0;
            gameState.player.expToNext = Math.floor(gameState.player.expToNext * 1.5);
            playSound('levelup');
            showLevelUpModal();
        }

        function showLevelUpModal() {
            gameState.isPaused = true;
            const modal = document.getElementById('levelUpModal');
            const choices = document.getElementById('spellChoices');
            choices.innerHTML = '';
            
            // Pick 3 random spells
            const availableSpells = Object.keys(spellLibrary).filter(key => {
                const spell = spellLibrary[key];
                return !gameState.spells[key] || gameState.spells[key] < spell.maxLevel;
            });
            
            const selected = [];
            for (let i = 0; i < 3 && availableSpells.length > 0; i++) {
                const idx = Math.floor(Math.random() * availableSpells.length);
                selected.push(availableSpells.splice(idx, 1)[0]);
            }
            
            selected.forEach(spellKey => {
                const spell = spellLibrary[spellKey];
                const currentLevel = gameState.spells[spellKey] || 0;
                
                const div = document.createElement('div');
                div.className = 'spell-choice';
                div.innerHTML = `
                    <div class="spell-name">${spell.name} Lv.${currentLevel + 1}</div>
                    <div class="spell-desc">${spell.desc}</div>
                `;
                div.addEventListener('click', () => {
                    gameState.spells[spellKey] = currentLevel + 1;
                    modal.style.display = 'none';
                    gameState.isPaused = false;
                    playSound('levelup');
                });
                choices.appendChild(div);
            });
            
            modal.style.display = 'block';
        }

        // Particles
        function createParticles(x, y, color, count) {
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 1 + Math.random() * 3;
                gameState.particles.push({
                    x, y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 1,
                    color,
                    size: 2 + Math.random() * 4
                });
            }
        }

        function updateParticles(deltaTime) {
            gameState.particles.forEach(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.life -= deltaTime / 1000;
            });
            gameState.particles = gameState.particles.filter(p => p.life > 0);
        }

        // Render
        function render() {
            const w = canvas.width / (window.devicePixelRatio || 1);
            const h = canvas.height / (window.devicePixelRatio || 1);
            
            // Clear
            ctx.fillStyle = 'rgba(10, 10, 20, 0.3)';
            ctx.fillRect(0, 0, w, h);
            
            // Poison aura
            if (gameState.spells.poison) {
                ctx.globalAlpha = 0.2;
                ctx.fillStyle = '#00ff00';
                ctx.beginPath();
                ctx.arc(gameState.player.x, gameState.player.y, 80, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
            
            // Player
            ctx.fillStyle = '#4af';
            ctx.beginPath();
            ctx.arc(gameState.player.x, gameState.player.y, 20, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.font = '24px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('üßô', gameState.player.x, gameState.player.y);
            
            // Enemies
            gameState.enemies.forEach(enemy => {
                ctx.fillStyle = enemy.color;
                ctx.beginPath();
                ctx.arc(enemy.x, enemy.y, enemy.size, 0, Math.PI * 2);
                ctx.fill();
                
                // HP bar
                if (enemy.hp < enemy.maxHp) {
                    ctx.fillStyle = '#000';
                    ctx.fillRect(enemy.x - 15, enemy.y - enemy.size - 10, 30, 4);
                    ctx.fillStyle = '#0f0';
                    ctx.fillRect(enemy.x - 15, enemy.y - enemy.size - 10, 30 * (enemy.hp / enemy.maxHp), 4);
                }
                
                ctx.font = enemy.isBoss ? '24px Arial' : '16px Arial';
                ctx.fillText(enemy.isBoss ? 'üëø' : 'üëæ', enemy.x, enemy.y);
            });
            
            // Projectiles
            gameState.projectiles.forEach(proj => {
                ctx.fillStyle = proj.color;
                ctx.beginPath();
                ctx.arc(proj.x, proj.y, proj.size, 0, Math.PI * 2);
                ctx.fill();
                
                if (proj.type === 'coin') {
                    ctx.font = '16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('üí∞', proj.x, proj.y);
                }
            });
            
            // Tornado
            if (gameState.spells.tornado) {
                const tornadoAngle = gameState.time / 100;
                const tornadoX = gameState.player.x + Math.cos(tornadoAngle) * 100;
                const tornadoY = gameState.player.y + Math.sin(tornadoAngle) * 100;
                
                ctx.globalAlpha = 0.6;
                ctx.fillStyle = '#88ccff';
                ctx.beginPath();
                ctx.arc(tornadoX, tornadoY, 30, 0, Math.PI * 2);
                ctx.fill();
                ctx.font = '30px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('üå™Ô∏è', tornadoX, tornadoY);
                ctx.globalAlpha = 1;
            }
            
            // Particles
            gameState.particles.forEach(p => {
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
        }

        function updateUI() {
            const hpPercent = (gameState.player.hp / gameState.player.maxHp) * 100;
            document.getElementById('hpFill').style.width = hpPercent + '%';
            document.getElementById('hpText').textContent = 
                `${Math.ceil(gameState.player.hp)} / ${gameState.player.maxHp}`;
            
            const expPercent = (gameState.player.exp / gameState.player.expToNext) * 100;
            document.getElementById('expFill').style.width = expPercent + '%';
            
            document.getElementById('levelDisplay').textContent = gameState.player.level;
            document.getElementById('waveDisplay').textContent = gameState.wave;
            document.getElementById('coinsDisplay').textContent = gameState.coins;
            
            const minutes = Math.floor(gameState.time / 60000);
            const seconds = Math.floor((gameState.time % 60000) / 1000);
            document.getElementById('timeDisplay').textContent = 
                `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        function endGame() {
            gameState.gameOver = true;
            gameState.isPaused = true;
            
            const minutes = Math.floor(gameState.time / 60000);
            const seconds = Math.floor((gameState.time % 60000) / 1000);
            document.getElementById('finalTime').textContent = 
                `${minutes}:${seconds.toString().padStart(2, '0')}`;
            document.getElementById('finalWave').textContent = gameState.wave;
            document.getElementById('earnedCoins').textContent = gameState.totalCoins;
            
            saveUpgrades();
            document.getElementById('gameOver').style.display = 'block';
        }

        document.getElementById('restartBtn').addEventListener('click', () => {
            location.reload();
        });

        // Game loop
        let lastTime = Date.now();
        function gameLoop() {
            const now = Date.now();
            const deltaTime = now - lastTime;
            lastTime = now;
            
            if (!gameState.isPaused && !gameState.gameOver) {
                gameState.time += deltaTime;
                
                // Update wave
                const newWave = Math.floor(gameState.time / 30000) + 1;
                if (newWave > gameState.wave) {
                    gameState.wave = newWave;
                    playSound('levelup');
                }
                
                // Move player
                const speedMultiplier = gameState.spells.haste ? 1 + gameState.spells.haste * 0.15 : 1;
                gameState.player.x += gameState.joystick.x * gameState.player.speed * speedMultiplier;
                gameState.player.y += gameState.joystick.y * gameState.player.speed * speedMultiplier;
                
                // Clamp player
                const w = canvas.width / (window.devicePixelRatio || 1);
                const h = canvas.height / (window.devicePixelRatio || 1);
                gameState.player.x = Math.max(20, Math.min(w - 20, gameState.player.x));
                gameState.player.y = Math.max(20, Math.min(h - 20, gameState.player.y));
                
                updateEnemies(deltaTime);
                updateSpells(deltaTime);
                updateProjectiles(deltaTime);
                updateCoins(deltaTime);
                updateParticles(deltaTime);
            }
            
            render();
            updateUI();
            
            requestAnimationFrame(gameLoop);
        }

        // Initialize
        loadUpgrades();
        gameState.spells.fireball = 1; // Start with fireball
        gameLoop();
    </script>
</body>
</html>
