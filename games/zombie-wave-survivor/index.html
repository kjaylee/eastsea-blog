<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ðŸ§Ÿ Zombie Wave Survivor</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0a0f;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Courier New', monospace;
            color: #0ff;
            overflow: hidden;
        }
        #gameContainer {
            position: relative;
            max-width: 100vw;
            max-height: 100vh;
        }
        canvas {
            display: block;
            background: #0a0a0f;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 14px;
            text-shadow: 0 0 8px #0ff;
            pointer-events: none;
            z-index: 10;
        }
        #minimap {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 150px;
            height: 150px;
            border: 2px solid #0ff;
            background: rgba(0, 0, 0, 0.7);
            z-index: 10;
        }
        #levelUpMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10, 10, 30, 0.95);
            border: 3px solid #0ff;
            padding: 30px;
            border-radius: 15px;
            display: none;
            z-index: 100;
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.5);
        }
        #levelUpMenu h2 {
            text-align: center;
            margin-bottom: 20px;
            font-size: 28px;
            color: #f0f;
            text-shadow: 0 0 10px #f0f;
        }
        .upgrade-btn {
            display: block;
            width: 100%;
            padding: 15px;
            margin: 10px 0;
            background: linear-gradient(135deg, #0a0a2e, #1a1a4e);
            border: 2px solid #0ff;
            color: #0ff;
            font-size: 16px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            transition: all 0.2s;
            border-radius: 8px;
        }
        .upgrade-btn:hover {
            background: linear-gradient(135deg, #1a1a4e, #2a2a6e);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.6);
            transform: scale(1.05);
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10, 10, 30, 0.95);
            border: 3px solid #f00;
            padding: 40px;
            border-radius: 15px;
            display: none;
            text-align: center;
            z-index: 100;
            box-shadow: 0 0 50px rgba(255, 0, 0, 0.5);
        }
        #gameOver h1 {
            color: #f00;
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 0 0 15px #f00;
        }
        #gameOver button {
            padding: 15px 40px;
            font-size: 20px;
            margin-top: 20px;
            background: linear-gradient(135deg, #2a0a0a, #4a0a0a);
            border: 2px solid #f00;
            color: #f00;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            border-radius: 8px;
        }
        #joystick {
            position: absolute;
            bottom: 50px;
            left: 50px;
            width: 120px;
            height: 120px;
            display: none;
            z-index: 50;
        }
        #joystick-base {
            position: absolute;
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: rgba(0, 255, 255, 0.2);
            border: 3px solid rgba(0, 255, 255, 0.5);
        }
        #joystick-stick {
            position: absolute;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(0, 255, 255, 0.6);
            border: 2px solid #0ff;
            top: 35px;
            left: 35px;
        }
        @media (max-width: 768px) {
            #joystick { display: block; }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="canvas"></canvas>
        <canvas id="minimap"></canvas>
        <div id="ui">
            <div>Wave: <span id="wave">1</span></div>
            <div>Kills: <span id="kills">0</span></div>
            <div>Time: <span id="time">0:00</span></div>
            <div>HP: <span id="hp">100</span>/100</div>
            <div>Level: <span id="level">1</span></div>
            <div>XP: <span id="xp">0</span>/<span id="xpNext">100</span></div>
        </div>
        <div id="levelUpMenu">
            <h2>â¬† LEVEL UP!</h2>
            <div id="upgradeOptions"></div>
        </div>
        <div id="gameOver">
            <h1>GAME OVER</h1>
            <div id="stats"></div>
            <button onclick="location.reload()">RESTART</button>
        </div>
        <div id="joystick">
            <div id="joystick-base"></div>
            <div id="joystick-stick"></div>
        </div>
    </div>
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const minimap = document.getElementById('minimap');
        const mmCtx = minimap.getContext('2d');

        const WORLD_SIZE = 3000;
        canvas.width = Math.min(window.innerWidth, 800);
        canvas.height = Math.min(window.innerHeight, 600);

        const audio = new AudioContext();
        function playSound(freq, duration, type = 'sine') {
            const osc = audio.createOscillator();
            const gain = audio.createGain();
            osc.connect(gain);
            gain.connect(audio.destination);
            osc.type = type;
            osc.frequency.value = freq;
            gain.gain.setValueAtTime(0.1, audio.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audio.currentTime + duration);
            osc.start();
            osc.stop(audio.currentTime + duration);
        }

        const keys = {};
        window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
        window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

        let joystickActive = false;
        let joystickVector = { x: 0, y: 0 };
        const joystickBase = document.getElementById('joystick-base');
        const joystickStick = document.getElementById('joystick-stick');

        joystickBase.addEventListener('touchstart', handleJoystickStart, { passive: false });
        joystickBase.addEventListener('touchmove', handleJoystickMove, { passive: false });
        joystickBase.addEventListener('touchend', handleJoystickEnd, { passive: false });

        function handleJoystickStart(e) {
            e.preventDefault();
            joystickActive = true;
        }

        function handleJoystickMove(e) {
            e.preventDefault();
            if (!joystickActive) return;
            const touch = e.touches[0];
            const rect = joystickBase.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            let dx = touch.clientX - centerX;
            let dy = touch.clientY - centerY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const maxDist = 35;
            if (distance > maxDist) {
                dx = (dx / distance) * maxDist;
                dy = (dy / distance) * maxDist;
            }
            joystickStick.style.left = (35 + dx) + 'px';
            joystickStick.style.top = (35 + dy) + 'px';
            joystickVector.x = dx / maxDist;
            joystickVector.y = dy / maxDist;
        }

        function handleJoystickEnd(e) {
            e.preventDefault();
            joystickActive = false;
            joystickStick.style.left = '35px';
            joystickStick.style.top = '35px';
            joystickVector = { x: 0, y: 0 };
        }

        const game = {
            wave: 1,
            kills: 0,
            time: 0,
            level: 1,
            xp: 0,
            xpNext: 100,
            nextWaveTime: 30,
            shake: 0,
            paused: false
        };

        const player = {
            x: WORLD_SIZE / 2,
            y: WORLD_SIZE / 2,
            hp: 100,
            maxHp: 100,
            speed: 3,
            size: 20,
            weapons: [
                { type: 'bullet', cooldown: 0, cooldownMax: 30, damage: 10, range: 300, speed: 8 }
            ],
            stats: {
                damage: 1,
                attackSpeed: 1,
                speed: 1,
                defense: 0
            }
        };

        const enemies = [];
        const projectiles = [];
        const particles = [];
        const items = [];

        const enemyTypes = {
            normal: { hp: 30, speed: 1.5, size: 15, color: '#0f0', xp: 10, damage: 10 },
            fast: { hp: 20, speed: 3, size: 12, color: '#ff0', xp: 15, damage: 8 },
            tank: { hp: 100, speed: 0.8, size: 25, color: '#f00', xp: 50, damage: 20 },
            boss: { hp: 500, speed: 1, size: 40, color: '#f0f', xp: 200, damage: 30 }
        };

        function spawnEnemies() {
            const count = game.wave * 5 + Math.floor(game.wave / 2) * 3;
            for (let i = 0; i < count; i++) {
                let type = 'normal';
                if (game.wave >= 3 && Math.random() < 0.2) type = 'fast';
                if (game.wave >= 5 && Math.random() < 0.1) type = 'tank';
                if (game.wave % 5 === 0 && i === 0) type = 'boss';
                
                const angle = Math.random() * Math.PI * 2;
                const distance = 500 + Math.random() * 500;
                const template = enemyTypes[type];
                enemies.push({
                    x: player.x + Math.cos(angle) * distance,
                    y: player.y + Math.sin(angle) * distance,
                    hp: template.hp * (1 + game.wave * 0.1),
                    maxHp: template.hp * (1 + game.wave * 0.1),
                    speed: template.speed,
                    size: template.size,
                    color: template.color,
                    xp: template.xp,
                    damage: template.damage,
                    type: type
                });
            }
        }

        function updatePlayer() {
            let dx = 0, dy = 0;
            if (keys['w'] || keys['arrowup']) dy -= 1;
            if (keys['s'] || keys['arrowdown']) dy += 1;
            if (keys['a'] || keys['arrowleft']) dx -= 1;
            if (keys['d'] || keys['arrowright']) dx += 1;
            
            if (joystickActive) {
                dx = joystickVector.x;
                dy = joystickVector.y;
            }

            if (dx !== 0 || dy !== 0) {
                const len = Math.sqrt(dx * dx + dy * dy);
                dx /= len;
                dy /= len;
                player.x += dx * player.speed * player.stats.speed;
                player.y += dy * player.speed * player.stats.speed;
                player.x = Math.max(50, Math.min(WORLD_SIZE - 50, player.x));
                player.y = Math.max(50, Math.min(WORLD_SIZE - 50, player.y));
            }

            player.weapons.forEach(weapon => {
                if (weapon.cooldown > 0) {
                    weapon.cooldown--;
                } else if (enemies.length > 0) {
                    const nearest = enemies.reduce((a, b) => {
                        const distA = Math.hypot(a.x - player.x, a.y - player.y);
                        const distB = Math.hypot(b.x - player.x, b.y - player.y);
                        return distA < distB ? a : b;
                    });
                    const dist = Math.hypot(nearest.x - player.x, nearest.y - player.y);
                    if (dist < weapon.range) {
                        const angle = Math.atan2(nearest.y - player.y, nearest.x - player.x);
                        projectiles.push({
                            x: player.x,
                            y: player.y,
                            vx: Math.cos(angle) * weapon.speed,
                            vy: Math.sin(angle) * weapon.speed,
                            damage: weapon.damage * player.stats.damage,
                            life: 60,
                            size: 5
                        });
                        weapon.cooldown = weapon.cooldownMax / player.stats.attackSpeed;
                        playSound(300, 0.05, 'square');
                    }
                }
            });
        }

        function updateEnemies() {
            enemies.forEach((e, i) => {
                const dx = player.x - e.x;
                const dy = player.y - e.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                e.x += (dx / dist) * e.speed;
                e.y += (dy / dist) * e.speed;

                if (dist < player.size + e.size) {
                    const dmg = Math.max(1, e.damage - player.stats.defense);
                    player.hp -= dmg;
                    playSound(150, 0.1, 'sawtooth');
                    game.shake = 10;
                    for (let j = 0; j < 10; j++) {
                        particles.push({
                            x: player.x,
                            y: player.y,
                            vx: (Math.random() - 0.5) * 5,
                            vy: (Math.random() - 0.5) * 5,
                            life: 30,
                            color: '#f00',
                            size: 3
                        });
                    }
                    if (player.hp <= 0) gameOver();
                }
            });
        }

        function updateProjectiles() {
            projectiles.forEach((p, i) => {
                p.x += p.vx;
                p.y += p.vy;
                p.life--;
                if (p.life <= 0 || p.x < 0 || p.x > WORLD_SIZE || p.y < 0 || p.y > WORLD_SIZE) {
                    projectiles.splice(i, 1);
                    return;
                }

                enemies.forEach((e, ei) => {
                    const dist = Math.hypot(e.x - p.x, e.y - p.y);
                    if (dist < e.size) {
                        e.hp -= p.damage;
                        projectiles.splice(i, 1);
                        playSound(200, 0.05, 'triangle');
                        for (let j = 0; j < 5; j++) {
                            particles.push({
                                x: e.x,
                                y: e.y,
                                vx: (Math.random() - 0.5) * 4,
                                vy: (Math.random() - 0.5) * 4,
                                life: 20,
                                color: '#0ff',
                                size: 2
                            });
                        }
                        if (e.hp <= 0) {
                            game.kills++;
                            game.xp += e.xp;
                            enemies.splice(ei, 1);
                            playSound(400, 0.1, 'square');
                            for (let j = 0; j < 15; j++) {
                                particles.push({
                                    x: e.x,
                                    y: e.y,
                                    vx: (Math.random() - 0.5) * 6,
                                    vy: (Math.random() - 0.5) * 6,
                                    life: 40,
                                    color: e.color,
                                    size: 4
                                });
                            }
                            if (Math.random() < 0.3) {
                                const itemTypes = ['xp', 'health', 'magnet', 'bomb'];
                                const weights = [0.5, 0.3, 0.15, 0.05];
                                let r = Math.random();
                                let itemType = 'xp';
                                for (let k = 0; k < weights.length; k++) {
                                    if (r < weights[k]) {
                                        itemType = itemTypes[k];
                                        break;
                                    }
                                    r -= weights[k];
                                }
                                items.push({
                                    x: e.x,
                                    y: e.y,
                                    type: itemType,
                                    life: 300
                                });
                            }
                        }
                    }
                });
            });
        }

        function updateItems() {
            items.forEach((item, i) => {
                const dist = Math.hypot(item.x - player.x, item.y - player.y);
                if (dist < 50 || item.magnet) {
                    const dx = player.x - item.x;
                    const dy = player.y - item.y;
                    const len = Math.sqrt(dx * dx + dy * dy);
                    item.x += (dx / len) * 5;
                    item.y += (dy / len) * 5;
                }
                if (dist < 30) {
                    items.splice(i, 1);
                    if (item.type === 'xp') {
                        game.xp += 20;
                        playSound(500, 0.05);
                    } else if (item.type === 'health') {
                        player.hp = Math.min(player.maxHp, player.hp + 30);
                        playSound(600, 0.1);
                    } else if (item.type === 'magnet') {
                        items.forEach(it => it.magnet = true);
                        playSound(700, 0.15);
                    } else if (item.type === 'bomb') {
                        enemies.forEach(e => {
                            e.hp = 0;
                            game.kills++;
                            game.xp += e.xp;
                        });
                        enemies.length = 0;
                        game.shake = 20;
                        playSound(100, 0.3, 'sawtooth');
                        for (let j = 0; j < 100; j++) {
                            particles.push({
                                x: player.x,
                                y: player.y,
                                vx: (Math.random() - 0.5) * 15,
                                vy: (Math.random() - 0.5) * 15,
                                life: 60,
                                color: '#ff0',
                                size: 6
                            });
                        }
                    }
                }
                item.life--;
                if (item.life <= 0) items.splice(i, 1);
            });
        }

        function updateParticles() {
            particles.forEach((p, i) => {
                p.x += p.vx;
                p.y += p.vy;
                p.life--;
                if (p.life <= 0) particles.splice(i, 1);
            });
        }

        function checkLevelUp() {
            if (game.xp >= game.xpNext) {
                game.level++;
                game.xp -= game.xpNext;
                game.xpNext = Math.floor(game.xpNext * 1.5);
                game.paused = true;
                showLevelUpMenu();
                playSound(800, 0.3);
                for (let i = 0; i < 50; i++) {
                    particles.push({
                        x: player.x,
                        y: player.y,
                        vx: (Math.random() - 0.5) * 10,
                        vy: (Math.random() - 0.5) * 10,
                        life: 60,
                        color: '#f0f',
                        size: 5
                    });
                }
            }
        }

        function showLevelUpMenu() {
            const menu = document.getElementById('levelUpMenu');
            const options = document.getElementById('upgradeOptions');
            options.innerHTML = '';

            const allUpgrades = [
                { name: 'âš” Damage +20%', apply: () => player.stats.damage *= 1.2 },
                { name: 'âš¡ Attack Speed +15%', apply: () => player.stats.attackSpeed *= 1.15 },
                { name: 'ðŸƒ Move Speed +15%', apply: () => player.stats.speed *= 1.15 },
                { name: 'â¤ Max HP +20', apply: () => { player.maxHp += 20; player.hp += 20; } },
                { name: 'ðŸ›¡ Defense +3', apply: () => player.stats.defense += 3 },
                { name: 'ðŸ’š Heal 50 HP', apply: () => player.hp = Math.min(player.maxHp, player.hp + 50) },
                { name: 'ðŸ”« New Weapon', apply: () => {
                    player.weapons.push({
                        type: 'missile',
                        cooldown: 0,
                        cooldownMax: 40,
                        damage: 20,
                        range: 350,
                        speed: 6
                    });
                }}
            ];

            const shuffled = allUpgrades.sort(() => Math.random() - 0.5).slice(0, 3);
            shuffled.forEach(up => {
                const btn = document.createElement('button');
                btn.className = 'upgrade-btn';
                btn.textContent = up.name;
                btn.onclick = () => {
                    up.apply();
                    menu.style.display = 'none';
                    game.paused = false;
                };
                options.appendChild(btn);
            });

            menu.style.display = 'block';
        }

        function gameOver() {
            game.paused = true;
            const stats = document.getElementById('stats');
            const best = JSON.parse(localStorage.getItem('zombieBest') || '{}');
            const current = { wave: game.wave, kills: game.kills, time: Math.floor(game.time / 60) };
            
            stats.innerHTML = `
                <p style="font-size:20px; margin:10px 0;">Wave: ${current.wave}</p>
                <p style="font-size:20px; margin:10px 0;">Kills: ${current.kills}</p>
                <p style="font-size:20px; margin:10px 0;">Time: ${current.time}s</p>
                <hr style="margin:20px 0; border-color:#0ff;">
                <p style="font-size:16px; color:#0ff;">Best Wave: ${best.wave || 0}</p>
                <p style="font-size:16px; color:#0ff;">Best Kills: ${best.kills || 0}</p>
            `;

            if (current.wave > (best.wave || 0) || current.kills > (best.kills || 0)) {
                localStorage.setItem('zombieBest', JSON.stringify({
                    wave: Math.max(current.wave, best.wave || 0),
                    kills: Math.max(current.kills, best.kills || 0),
                    time: Math.max(current.time, best.time || 0)
                }));
            }

            document.getElementById('gameOver').style.display = 'block';
        }

        function render() {
            ctx.save();
            if (game.shake > 0) {
                ctx.translate((Math.random() - 0.5) * game.shake, (Math.random() - 0.5) * game.shake);
                game.shake--;
            }

            const camX = player.x - canvas.width / 2;
            const camY = player.y - canvas.height / 2;

            ctx.fillStyle = '#0a0a0f';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.save();
            ctx.translate(-camX, -camY);

            // Grid
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            for (let i = 0; i < WORLD_SIZE; i += 100) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, WORLD_SIZE);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(WORLD_SIZE, i);
                ctx.stroke();
            }

            particles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life / 60;
                ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
            });

            items.forEach(it => {
                const colors = { xp: '#0f0', health: '#f00', magnet: '#ff0', bomb: '#f0f' };
                ctx.fillStyle = colors[it.type] || '#fff';
                ctx.globalAlpha = 0.8 + Math.sin(Date.now() / 100) * 0.2;
                ctx.beginPath();
                ctx.arc(it.x, it.y, 8, 0, Math.PI * 2);
                ctx.fill();
            });

            ctx.globalAlpha = 1;
            enemies.forEach(e => {
                ctx.fillStyle = e.color;
                ctx.beginPath();
                ctx.arc(e.x, e.y, e.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#000';
                ctx.fillRect(e.x - e.size, e.y - e.size - 8, e.size * 2, 4);
                ctx.fillStyle = '#0f0';
                ctx.fillRect(e.x - e.size, e.y - e.size - 8, (e.hp / e.maxHp) * e.size * 2, 4);
            });

            projectiles.forEach(p => {
                ctx.fillStyle = '#0ff';
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#0ff';
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            });

            ctx.fillStyle = '#0ff';
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(player.x, player.y, player.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            ctx.restore();
            ctx.restore();

            // Minimap
            mmCtx.fillStyle = '#000';
            mmCtx.fillRect(0, 0, 150, 150);
            const scale = 150 / WORLD_SIZE;
            mmCtx.fillStyle = '#0ff';
            mmCtx.fillRect(player.x * scale - 2, player.y * scale - 2, 4, 4);
            enemies.forEach(e => {
                mmCtx.fillStyle = e.color;
                mmCtx.fillRect(e.x * scale - 1, e.y * scale - 1, 2, 2);
            });

            document.getElementById('wave').textContent = game.wave;
            document.getElementById('kills').textContent = game.kills;
            document.getElementById('time').textContent = Math.floor(game.time / 60) + ':' + String(Math.floor(game.time % 60)).padStart(2, '0');
            document.getElementById('hp').textContent = Math.max(0, Math.floor(player.hp));
            document.getElementById('level').textContent = game.level;
            document.getElementById('xp').textContent = Math.floor(game.xp);
            document.getElementById('xpNext').textContent = game.xpNext;
        }

        let lastTime = 0;
        function gameLoop(timestamp) {
            if (!lastTime) lastTime = timestamp;
            const delta = timestamp - lastTime;
            lastTime = timestamp;

            if (!game.paused) {
                game.time++;
                game.nextWaveTime--;
                if (game.nextWaveTime <= 0) {
                    game.wave++;
                    spawnEnemies();
                    game.nextWaveTime = 30 * 60;
                }

                updatePlayer();
                updateEnemies();
                updateProjectiles();
                updateItems();
                updateParticles();
                checkLevelUp();
            }

            render();
            requestAnimationFrame(gameLoop);
        }

        spawnEnemies();
        requestAnimationFrame(gameLoop);
    </script>
</body>
</html>