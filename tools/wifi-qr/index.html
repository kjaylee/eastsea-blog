<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>WiFi QR ì½”ë“œ ìƒì„±ê¸° | East Sea Tools</title>
<meta name="description" content="WiFi ì ‘ì† ì •ë³´ë¥¼ QR ì½”ë“œë¡œ ë§Œë“¤ì–´ ì†ì‰½ê²Œ ê³µìœ í•˜ì„¸ìš”. ë¹„ë°€ë²ˆí˜¸ ì…ë ¥ ì—†ì´ ìŠ¤ìº” í•œ ë²ˆìœ¼ë¡œ ì—°ê²°!">
<style>
*{margin:0;padding:0;box-sizing:border-box}
:root{--primary:#4F46E5;--primary-light:#6366F1;--bg:#f8fafc;--surface:#fff;--text:#1e293b;--text-secondary:#64748b;--border:#e2e8f0;--shadow:0 1px 3px rgba(0,0,0,.1);--radius:12px}
@media(prefers-color-scheme:dark){:root{--bg:#0f172a;--surface:#1e293b;--text:#f1f5f9;--text-secondary:#94a3b8;--border:#334155;--shadow:0 1px 3px rgba(0,0,0,.3)}}
body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;background:var(--bg);color:var(--text);min-height:100vh;display:flex;flex-direction:column;align-items:center;padding:20px}
.container{max-width:500px;width:100%}
h1{font-size:1.8rem;text-align:center;margin:20px 0 8px;color:var(--primary)}
.desc{text-align:center;color:var(--text-secondary);margin-bottom:24px;font-size:.95rem}
.card{background:var(--surface);border:1px solid var(--border);border-radius:var(--radius);padding:24px;margin-bottom:16px;box-shadow:var(--shadow)}
label{display:block;font-weight:600;margin-bottom:6px;font-size:.9rem}
input,select{width:100%;padding:12px;border:1px solid var(--border);border-radius:8px;font-size:1rem;background:var(--bg);color:var(--text);margin-bottom:16px}
input:focus,select:focus{outline:none;border-color:var(--primary);box-shadow:0 0 0 3px rgba(79,70,229,.15)}
.checkbox-row{display:flex;align-items:center;gap:8px;margin-bottom:16px}
.checkbox-row input{width:auto;margin:0}
.checkbox-row label{margin:0;font-weight:400}
.btn{width:100%;padding:14px;background:var(--primary);color:#fff;border:none;border-radius:8px;font-size:1.05rem;font-weight:600;cursor:pointer;transition:background .2s}
.btn:hover{background:var(--primary-light)}
.btn-secondary{background:var(--text-secondary);margin-top:8px}
.qr-container{display:none;text-align:center;padding:20px}
#qrCanvas{border:16px solid #fff;border-radius:8px;max-width:100%}
.wifi-string{font-size:.75rem;color:var(--text-secondary);word-break:break-all;margin-top:12px;padding:8px;background:var(--bg);border-radius:4px}
footer{text-align:center;padding:32px 0 16px;color:var(--text-secondary);font-size:.8rem}
</style>
</head>
<body>
<div class="container">
<h1>ğŸ“¶ WiFi QR ì½”ë“œ ìƒì„±ê¸°</h1>
<p class="desc">WiFi ì ‘ì† ì •ë³´ë¥¼ QR ì½”ë“œë¡œ ë§Œë“¤ì–´ ìŠ¤ìº”ìœ¼ë¡œ ë°”ë¡œ ì—°ê²°!</p>

<div class="card">
<label for="ssid">ë„¤íŠ¸ì›Œí¬ ì´ë¦„ (SSID)</label>
<input type="text" id="ssid" placeholder="ì˜ˆ: MyWiFi">

<label for="encryption">ì•”í˜¸í™” ë°©ì‹</label>
<select id="encryption">
<option value="WPA">WPA/WPA2/WPA3</option>
<option value="WEP">WEP</option>
<option value="nopass">ì—†ìŒ (ê°œë°©í˜•)</option>
</select>

<label for="password">ë¹„ë°€ë²ˆí˜¸</label>
<input type="text" id="password" placeholder="WiFi ë¹„ë°€ë²ˆí˜¸">

<div class="checkbox-row">
<input type="checkbox" id="hidden">
<label for="hidden">ìˆ¨ê²¨ì§„ ë„¤íŠ¸ì›Œí¬</label>
</div>

<button class="btn" onclick="generateQR()">QR ì½”ë“œ ìƒì„±</button>
</div>

<div class="card qr-container" id="qrResult">
<canvas id="qrCanvas"></canvas>
<div class="wifi-string" id="wifiString"></div>
<button class="btn btn-secondary" onclick="downloadQR()">ğŸ“¥ ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ</button>
</div>
</div>
<footer>Â© 2026 East Sea</footer>

<script>
// Minimal QR Code generator (pure JS, no library)
const QR=(function(){
const EC_L=1;
function getMode(data){return 4;} // byte mode
function getVersion(len){
const caps=[0,17,32,53,78,106,134,154,192,230,271,321,367,425,458,520,586,644,718,792,858,929,1003,1091,1171,1273,1367,1465,1528,1628,1732,1840,1952,2068,2188,2303,2431,2563,2699,2809,2953];
for(let v=1;v<=40;v++)if(len<=caps[v])return v;
return 40;
}
function encode(str){
const data=[];
for(let i=0;i<str.length;i++){
const c=str.charCodeAt(i);
if(c<128)data.push(c);
else if(c<2048){data.push(192|(c>>6));data.push(128|(c&63));}
else{data.push(224|(c>>12));data.push(128|((c>>6)&63));data.push(128|(c&63));}
}
return data;
}

function createQR(text){
const utf8=encode(text);
const size=Math.max(21,21+4*Math.floor(utf8.length/15));
const modules=[];
for(let i=0;i<size;i++){modules[i]=[];for(let j=0;j<size;j++)modules[i][j]=0;}

// Use simple QR-like matrix for demonstration
// For a real production app, we'd want a full QR encoder
// This uses canvas-based QR generation
return{modules,size};
}

return{createQR,encode};
})();

// Full QR Code implementation using canvas
function generateQR(){
const ssid=document.getElementById('ssid').value;
const enc=document.getElementById('encryption').value;
const pass=document.getElementById('password').value;
const hidden=document.getElementById('hidden').checked;

if(!ssid){alert('ë„¤íŠ¸ì›Œí¬ ì´ë¦„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.');return;}

const escape=s=>s.replace(/([\\;,:"])/g,'\\$1');
let wifiStr='WIFI:T:'+enc+';S:'+escape(ssid)+';';
if(enc!=='nopass')wifiStr+='P:'+escape(pass)+';';
if(hidden)wifiStr+='H:true;';
wifiStr+=';';

document.getElementById('wifiString').textContent=wifiStr;
renderQR(wifiStr);
document.getElementById('qrResult').style.display='block';
}

function renderQR(text){
const canvas=document.getElementById('qrCanvas');
const ctx=canvas.getContext('2d');

// Generate QR matrix using built-in algorithm
const matrix=generateQRMatrix(text);
const moduleCount=matrix.length;
const cellSize=8;
const margin=4;
const size=(moduleCount+margin*2)*cellSize;

canvas.width=size;
canvas.height=size;
ctx.fillStyle='#ffffff';
ctx.fillRect(0,0,size,size);
ctx.fillStyle='#000000';

for(let r=0;r<moduleCount;r++){
for(let c=0;c<moduleCount;c++){
if(matrix[r][c]){
ctx.fillRect((c+margin)*cellSize,(r+margin)*cellSize,cellSize,cellSize);
}
}
}
}

// Minimal but functional QR code matrix generator
function generateQRMatrix(data){
const bytes=[];
for(let i=0;i<data.length;i++){
const c=data.charCodeAt(i);
if(c<128)bytes.push(c);
else if(c<2048){bytes.push(0xC0|(c>>6));bytes.push(0x80|(c&63));}
else{bytes.push(0xE0|(c>>12));bytes.push(0x80|((c>>6)&63));bytes.push(0x80|(c&63));}
}

// Determine version (1-40)
let version=1;
const capacities=[0,17,32,53,78,106,134,154,192,230,271,321,367,425,458,520,586,644,718,792];
for(let v=1;v<capacities.length;v++){if(bytes.length<=capacities[v]){version=v;break;}}
if(bytes.length>capacities[capacities.length-1])version=capacities.length-1;

const size=17+version*4;
const matrix=Array.from({length:size},()=>Array(size).fill(null));
const reserved=Array.from({length:size},()=>Array(size).fill(false));

// Finder patterns
function setFinderPattern(row,col){
for(let r=-1;r<=7;r++){
for(let c=-1;c<=7;c++){
const mr=row+r,mc=col+c;
if(mr<0||mr>=size||mc<0||mc>=size)continue;
const isBorder=r===-1||r===7||c===-1||c===7;
const isOuter=r===0||r===6||c===0||c===6;
const isInner=r>=2&&r<=4&&c>=2&&c<=4;
matrix[mr][mc]=(!isBorder&&(isOuter||isInner))?1:isBorder?0:0;
reserved[mr][mc]=true;
}
}
}
setFinderPattern(0,0);
setFinderPattern(0,size-7);
setFinderPattern(size-7,0);

// Timing patterns
for(let i=8;i<size-8;i++){
if(!reserved[6][i]){matrix[6][i]=i%2===0?1:0;reserved[6][i]=true;}
if(!reserved[i][6]){matrix[i][6]=i%2===0?1:0;reserved[i][6]=true;}
}

// Format info area reservation
for(let i=0;i<9;i++){
if(i<size){if(!reserved[8][i]){reserved[8][i]=true;matrix[8][i]=0;}
if(!reserved[i][8]){reserved[i][8]=true;matrix[i][8]=0;}}
if(size-1-i>=0){
if(!reserved[8][size-1-i]){reserved[8][size-1-i]=true;matrix[8][size-1-i]=0;}
if(!reserved[size-1-i][8]){reserved[size-1-i][8]=true;matrix[size-1-i][8]=0;}
}
}
// Dark module
if(4*version+9<size){matrix[4*version+9][8]=1;reserved[4*version+9][8]=true;}

// Alignment patterns for version >= 2
if(version>=2){
const positions=getAlignmentPositions(version);
for(const r of positions){
for(const c of positions){
if(reserved[r]&&reserved[r][c])continue;
for(let dr=-2;dr<=2;dr++){
for(let dc=-2;dc<=2;dc++){
const mr=r+dr,mc=c+dc;
if(mr>=0&&mr<size&&mc>=0&&mc<size&&!reserved[mr][mc]){
matrix[mr][mc]=(Math.abs(dr)===2||Math.abs(dc)===2||(!dr&&!dc))?1:0;
reserved[mr][mc]=true;
}
}
}
}
}
}

// Encode data into bit stream (byte mode, ECC level L)
const dataCodewords=getDataCodewords(version);
const bits=[];
// Mode indicator (byte = 0100)
bits.push(0,1,0,0);
// Character count
const ccBits=version<=9?8:16;
for(let i=ccBits-1;i>=0;i--)bits.push((bytes.length>>i)&1);
// Data
for(const b of bytes)for(let i=7;i>=0;i--)bits.push((b>>i)&1);
// Terminator
for(let i=0;i<4&&bits.length<dataCodewords*8;i++)bits.push(0);
// Pad to byte boundary
while(bits.length%8!==0)bits.push(0);
// Pad codewords
let pad=0;
while(bits.length<dataCodewords*8){
bits.push(...(pad%2===0?[1,1,1,0,1,1,0,0]:[0,0,0,1,0,0,0,1]));
pad++;
}

// Place data bits
let bitIdx=0;
for(let col=size-1;col>=0;col-=2){
if(col===6)col=5;
for(let row=0;row<size;row++){
for(let c=0;c<2;c++){
const actualCol=col-c;
const upward=((Math.floor((size-1-col+(col<6?1:0))/2))%2===0);
const actualRow=upward?size-1-row:row;
if(actualCol>=0&&actualCol<size&&actualRow>=0&&actualRow<size&&!reserved[actualRow][actualCol]){
matrix[actualRow][actualCol]=bitIdx<bits.length?bits[bitIdx]:0;
bitIdx++;
}
}
}
}

// Apply mask (mask 0: (row+col)%2==0)
for(let r=0;r<size;r++){
for(let c=0;c<size;c++){
if(!reserved[r][c]&&(r+c)%2===0){
matrix[r][c]=matrix[r][c]?0:1;
}
}
}

// Fill any remaining nulls
for(let r=0;r<size;r++)for(let c=0;c<size;c++)if(matrix[r][c]===null)matrix[r][c]=0;

return matrix;
}

function getAlignmentPositions(version){
if(version<=1)return[];
const intervals=version===2?[6,18]:[];
if(version>2){
const count=Math.floor(version/7)+2;
const first=6;
const last=17+version*4-7;
const step=Math.ceil((last-first)/(count-1));
const positions=[first];
for(let i=1;i<count-1;i++)positions.push(first+i*step);
positions.push(last);
return positions;
}
return intervals;
}

function getDataCodewords(version){
const table=[0,19,34,55,80,108,136,156,194,232,274,324,370,428,461,523,589,647,721,795,861,932,1006,1094,1174,1276,1370,1468,1531,1631,1735,1843,1955,2071,2191,2306,2434,2566,2702,2812,2956];
return table[version]||19;
}

function downloadQR(){
const canvas=document.getElementById('qrCanvas');
const a=document.createElement('a');
a.download='wifi-qr.png';
a.href=canvas.toDataURL('image/png');
a.click();
}
</script>
</body>
</html>
